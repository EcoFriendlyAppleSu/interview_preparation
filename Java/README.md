<details>
<summary style="font-size:20px">JVM</summary>
<div markdown="1">
<br/>
<h2>🤔 JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- JVM은 Java Virtua Machine을 이야기하며 자바 Object file을 컴퓨터가 읽을 수 있는 컴파일된 파일로 변경하는 역할을 수행합니다. 또한 JVM은 Java Project의 객체들을 관리해줍니다. 프로그래머의 메모리 관리 책임을 JVM이 해결하므로써 사용자의 편의를 도모하고 다양한 OS위에서 실행할 수 있는 프로세스여서 다기종에 제약없이 Java file을 실행할 수 있습니다.

<h3>GPT의 대답</h3>

- JVM은 Java Virtual Machine의 약어로, 자바 프로그램을 실행하기 위한 가상 머신입니다. JVM은 자바 바이트 코드를 기계어로 변환하고 실행하는 역할을 수행합니다. 이는 자바 언어의 특성 중 하나로, 플랫폼 독립성을 제공합니다. 즉, 자바 프로그램은 운영체제나 하드웨어와 직접적으로 상호작용하지 않고 JVM을 통해 실행될 수 있습니다.

- JVM은 다양한 기능을 수행합니다. 주요 기능으로는 메모리 관리, 가비지 컬렉션, 스레드 관리 등이 있습니다. 메모리 관리 측면에서는 JVM은 메모리 할당과 해제를 관리하며, 가비지 컬렉션은 더 이상 사용되지 않는 객체를 자동으로 제거하여 메모리를 최적화합니다. 또한, JVM은 다중 스레드를 관리하고 동기화를 제공하여 동시성을 지원합니다.

- JVM은 또한 자바 프로그램의 보안을 강화하기 위해 사용됩니다. 클래스 로더를 통해 클래스 파일을 검증하고, 보안 관련 규칙을 적용하여 악성 코드 실행을 방지합니다. 이러한 기능들은 자바의 안전성과 신뢰성을 높이는 데 기여합니다.

<br/>
<h2>🤔 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요</h2>

<h3>📝 나의 대답</h3>

- 아닙니다. 올릴 수 있습니다. JetBrain 사에서 만든 Kotiln 언어는 프로그램 실행 시 JVM을 통해 실행하는 것으로 알고 있습니다. 대신 Java언어에 사용되는 컴파일러가 아닌 Kotiln 컴파일러를 사용해 바이트 코드를 생성할 것으로 예상됩니다.

<h3>GPT의 대답</h3>

- Groovy, Scala, Clojure와 같은 언어도 JVM 위에서 실행됩니다. 이들 언어는 각자의 컴파일러를 사용하여 JVM에서 실행되는 바이트 코드를 생성합니다. 이러한 다양한 언어들은 자바 생태계와의 통합성을 갖고 있어, 자바 라이브러리를 사용하거나 기존 자바 코드와 상호 작용할 수 있습니다.

<br/>
<h2>🤔 반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요.</h2>

<h3>GPT의 대답</h3>

- 특정 언어에 따라 컴파일 과정이 자동화되어 사용자가 직접 컴파일할 필요가 없는 경우도 있을 수 있습니다. 예를 들어, Kotlin 언어의 경우 IntelliJ IDEA와 같은 통합 개발 환경에서 소스 코드를 작성하고 컴파일하는 과정이 자동으로 처리되어 사용자가 명시적으로 컴파일하지 않아도 됩니다. 이 경우에도 사실상 컴파일이 이루어져 JVM에서 실행 가능한 바이트 코드가 생성됩니다.

- 따라서, JVM 계열 언어는 보통 JVM에서 실행될 수 있도록 컴파일되며, 해당 언어의 컴파일러를 사용하여 JVM에서 실행 가능한 바이트 코드로 변환됩니다.

<br/>
<h2>🤔 VM을 사용함으로써 얻을 수 있는 장점과 단점에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- VM을 사용해서 얻을 수 있는 가장 큰 장점은 다양한 OS 환경에서도 실행하고자 하는 프로그램을 구동시킬 수 있다는 것입니다. 반면 단점은 VM을 통해 한 번 더 실행되어야 하기 때문에 OS에 종속적인 프로그램보다 리소스가 더 소모됩니다. 

<h3>GPT의 대답</h3>

✓ 장점

- 플랫폼 독립성: VM은 프로그램을 실행하기 위한 중간 계층으로서, 하드웨어와 운영체제(OS) 사이의 추상화를 제공합니다. 이를 통해 같은 프로그램을 다양한 운영체제에서 실행할 수 있으며, 플랫폼 간 이식성을 높여줍니다.

- 안정성과 보안성: VM은 프로그램을 격리된 환경에서 실행하고, 메모리 관리와 가비지 컬렉션 등을 자동으로 처리하여 안정성과 보안성을 향상시킵니다. 이는 프로그램의 예기치 않은 동작과 메모리 오류를 방지하는 데 도움을 줍니다.

✓ 단점

- 성능 저하: VM을 통해 프로그램을 실행하려면 추가적인 계층이 필요하므로 성능 손실이 발생할 수 있습니다. OS에 직접 실행되는 프로그램에 비해 리소스 소모가 더 크고, VM의 오버헤드가 발생할 수 있습니다.

- 의존성: VM을 사용하는 프로그램은 해당 VM이 설치되어 있어야 정상적으로 실행됩니다. 따라서, 사용자가 VM을 설치하고 관리하는 추가적인 작업이 필요할 수 있습니다.

- 제한된 하드웨어 접근: VM은 하드웨어와 직접적인 상호 작용을 제한하는 경우가 있습니다. 특정 하드웨어 기능에 직접 액세스해야 하는 프로그램의 경우 VM 위에서 실행하기 어려울 수 있습니다.

<br/>
<h2>🤔 JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요.</h2>

<h3>📝 나의 대답</h3>

- 아니요 부모-자식 프로세스 관계라고 보기 어렵습니다.

<h3>GPT의 대답</h3>

- JVM은 자바 가상 머신으로, 운영체제에서 실행되는 독립적인 프로세스입니다. JVM 내에서 실행되는 자바 프로그램은 JVM의 관리 하에서 실행되며, 이는 별도의 프로세스로서 동작합니다. 자바 프로그램은 JVM에서 동작하는 단위로 간주되며, 부모 프로세스 - 자식 프로세스 관계를 갖지 않습니다.

- 일반적으로, 부모 프로세스 - 자식 프로세스 관계는 운영체제 수준에서 발생하는 것으로, 부모 프로세스가 자식 프로세스를 생성하고 관리하는 구조입니다. 하지만 JVM 내에서 실행되는 프로그램은 JVM 자체적으로 프로세스 관리를 수행하며, 운영체제의 프로세스 관리와는 별도입니다.

</div>
</details>

<details>
<summary style="font-size:20px">final keyword</summary>
<div markdown="1">
<br/>
<h2>🤔 final 키워드를 사용하면, 어떤 이점이 있나요.</h2>

<h3>📝 나의 대답</h3>

- Java 프로그래밍 안에 존재하는 final keyword를 사용하면 객체의 생성 주기를 맞출 수 있어 JVM이 객체의 Sync를 맞출 때 발생하는 오버헤드를 줄일 수 있습니다. ❌ 틀렸습니다. ❌

<h3>GPT의 대답</h3>

- final 키워드는 변수, 메서드, 클래스에 사용될 수 있으며, 다음과 같은 이점을 가질 수 있습니다

- 변수 : final 변수는 값을 변경할 수 없는 상수로써 사용됩니다. final 변수는 값의 변경을 방지하여 프로그램의 안정성과 예측 가능성을 높입니다.

- 메서드: final 메서드는 상속을 금지하여 메서드의 오버라이딩을 방지합니다. 이를 통해 부모 클래스가 제공한 기능을 변경하지 못하도록 보장하고, 코드의 안정성과 일관성을 유지할 수 있습니다.

- 클래스: final 클래스는 상속을 금지하여 클래스의 확장을 방지합니다. 이는 클래스의 구현을 완전히 제어하고, 부모 클래스의 기능을 변경하지 못하도록 보장합니다. 또한, final 클래스는 상속으로 인한 보안이슈나 예상치 못한 동작을 방지할 수 있습니다.

<br/>
<h2>🤔 컴파일 과정에서, final 키워드는 다르게 취급되나요.</h2>

<h3>📝 나의 대답</h3>

- 네. 다르게 취급됩니다. 예를 들어 변수에 final keyword를 작성했을 때, 컴파일 시점에서 에러가 발생해 값의 변경을 추적할 수 있습니다. 메소드, 클래스 또한 마찬가지로 값 변경 시 컴파일 시점에 발견할 수 있어 런타임 시 발견되는 에러를 찾을 때보다 리소스가 적게 듭니다.

<h3>GPT의 대답</h3>

- final 키워드는 컴파일 시점에서 값 변경 또는 오버라이딩에 대한 오류를 발견할 수 있어, 런타임 시 발견되는 에러를 사전에 예방하고 리소스를 절약할 수 있습니다. 따라서, final 키워드는 컴파일 과정에서 다르게 취급되어 에러를 컴파일 시점에서 발견할 수 있다는 장점을 가지고 있습니다.
</div>
</details>

<details>
<summary style="font-size:20px">인터페이스와 추상 클래스</summary>
<div markdown="1">
<br/>
<h2>🤔 인터페이스와 추상 클래스의 차이에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 인터페이스는 프로그램 안에서 명세를 정의할 때 사용됩니다. implements한 클래스는 명세에 적힌 내용을 반드시 구현해야 합니다. 반면 추상 클래스는 명세가 아닌 행위를 정의합니다. 상속하는 클래스에선 행위를 재정의할 필요는 없습니다.

<h3>GPT의 대답</h3>

✓ 목적: 인터페이스는 클래스가 가져야 할 기능(메서드)의 명세를 정의하는데 사용됩니다. 인터페이스는 클래스가 특정 메서드를 반드시 구현하도록 강제하며, 다중 상속과 유사한 기능을 제공합니다. 반면, 추상 클래스는 클래스의 행위(behavior)를 정의하며, 구체적인 구현이 필요한 메서드와 추상 메서드를 함께 가질 수 있습니다.

✓ 구현 강제성: 클래스가 인터페이스를 implements(구현)하면, 해당 인터페이스의 모든 메서드를 구현해야 합니다. 인터페이스는 클래스에 특정한 동작을 제공하고, 이를 강제하기 위해 사용됩니다. 추상 클래스는 추상 메서드를 포함할 수 있으며, 이러한 추상 메서드는 하위 클래스에서 반드시 구현되어야 합니다. 하지만 추상 클래스는 구체적인 구현이 필요한 메서드를 가질 수 있으며, 하위 클래스에서 재정의할 필요는 없습니다.

✓ 다중 상속: 인터페이스는 다중 상속을 지원합니다. 클래스가 여러 개의 인터페이스를 구현할 수 있으며, 이를 통해 다양한 기능을 동시에 제공할 수 있습니다. 반면, 추상 클래스는 단일 상속만을 지원하며, 하나의 추상 클래스만 상속받을 수 있습니다.

✓ 인스턴스화: 인터페이스는 인스턴스화될 수 없습니다. 인터페이스는 단지 메서드의 명세를 제공하는 역할을 하며, 구체적인 객체를 생성할 수 없습니다. 추상 클래스는 인스턴스화될 수 있지만, 추상 클래스 내에 추상 메서드가 포함되어 있다면 해당 클래스는 추상 클래스로 선언되어야 합니다.

<br/>
<h2>🤔 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요.</h2>

<h3>📝 나의 대답</h3>

- Java 진영에선 클래스의 상속은 하나 인터페이스 상속은 다중으로 받을 수 있습니다. 이는 복잡성을 제한하기 위함이라고 생각합니다. 인터페이스를 사용한다면 인터페이스 안에 정의된 메소드를 구현해야합니다. 하지만 클래스 상속은 구현을 강제하지 않기 때문에 모호해질 가능성이 존재합니다. 다중 상속으로 몇 뎁스만 내려가도 이 모호함 때문에 코드의 복잡성은 증가할 것입니다.

<h3>GPT의 대답</h3>

- 

</div>
</details>