<details>
<summary style="font-size:20px">JVM</summary>
<div markdown="1">
<br/>
<h2>🤔 JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- JVM은 Java Virtua Machine을 이야기하며 자바 Object file을 컴퓨터가 읽을 수 있는 컴파일된 파일로 변경하는 역할을 수행합니다. 또한 JVM은 Java Project의 객체들을 관리해줍니다. 프로그래머의 메모리 관리 책임을 JVM이 해결하므로써 사용자의 편의를 도모하고 다양한 OS위에서 실행할 수 있는 프로세스여서 다기종에 제약없이 Java file을 실행할 수 있습니다.

<h3>GPT의 대답</h3>

- JVM은 Java Virtual Machine의 약어로, 자바 프로그램을 실행하기 위한 가상 머신입니다. JVM은 자바 바이트 코드를 기계어로 변환하고 실행하는 역할을 수행합니다. 이는 자바 언어의 특성 중 하나로, 플랫폼 독립성을 제공합니다. 즉, 자바 프로그램은 운영체제나 하드웨어와 직접적으로 상호작용하지 않고 JVM을 통해 실행될 수 있습니다.

- JVM은 다양한 기능을 수행합니다. 주요 기능으로는 메모리 관리, 가비지 컬렉션, 스레드 관리 등이 있습니다. 메모리 관리 측면에서는 JVM은 메모리 할당과 해제를 관리하며, 가비지 컬렉션은 더 이상 사용되지 않는 객체를 자동으로 제거하여 메모리를 최적화합니다. 또한, JVM은 다중 스레드를 관리하고 동기화를 제공하여 동시성을 지원합니다.

- JVM은 또한 자바 프로그램의 보안을 강화하기 위해 사용됩니다. 클래스 로더를 통해 클래스 파일을 검증하고, 보안 관련 규칙을 적용하여 악성 코드 실행을 방지합니다. 이러한 기능들은 자바의 안전성과 신뢰성을 높이는 데 기여합니다.

<br/>
<h2>🤔 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요</h2>

<h3>📝 나의 대답</h3>

- 아닙니다. 올릴 수 있습니다. JetBrain 사에서 만든 Kotiln 언어는 프로그램 실행 시 JVM을 통해 실행하는 것으로 알고 있습니다. 대신 Java언어에 사용되는 컴파일러가 아닌 Kotiln 컴파일러를 사용해 바이트 코드를 생성할 것으로 예상됩니다.

<h3>GPT의 대답</h3>

- Groovy, Scala, Clojure와 같은 언어도 JVM 위에서 실행됩니다. 이들 언어는 각자의 컴파일러를 사용하여 JVM에서 실행되는 바이트 코드를 생성합니다. 이러한 다양한 언어들은 자바 생태계와의 통합성을 갖고 있어, 자바 라이브러리를 사용하거나 기존 자바 코드와 상호 작용할 수 있습니다.

<br/>
<h2>🤔 반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요.</h2>

<h3>GPT의 대답</h3>

- 특정 언어에 따라 컴파일 과정이 자동화되어 사용자가 직접 컴파일할 필요가 없는 경우도 있을 수 있습니다. 예를 들어, Kotlin 언어의 경우 IntelliJ IDEA와 같은 통합 개발 환경에서 소스 코드를 작성하고 컴파일하는 과정이 자동으로 처리되어 사용자가 명시적으로 컴파일하지 않아도 됩니다. 이 경우에도 사실상 컴파일이 이루어져 JVM에서 실행 가능한 바이트 코드가 생성됩니다.

- 따라서, JVM 계열 언어는 보통 JVM에서 실행될 수 있도록 컴파일되며, 해당 언어의 컴파일러를 사용하여 JVM에서 실행 가능한 바이트 코드로 변환됩니다.

<br/>
<h2>🤔 VM을 사용함으로써 얻을 수 있는 장점과 단점에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- VM을 사용해서 얻을 수 있는 가장 큰 장점은 다양한 OS 환경에서도 실행하고자 하는 프로그램을 구동시킬 수 있다는 것입니다. 반면 단점은 VM을 통해 한 번 더 실행되어야 하기 때문에 OS에 종속적인 프로그램보다 리소스가 더 소모됩니다. 

<h3>GPT의 대답</h3>

✓ 장점

- 플랫폼 독립성: VM은 프로그램을 실행하기 위한 중간 계층으로서, 하드웨어와 운영체제(OS) 사이의 추상화를 제공합니다. 이를 통해 같은 프로그램을 다양한 운영체제에서 실행할 수 있으며, 플랫폼 간 이식성을 높여줍니다.

- 안정성과 보안성: VM은 프로그램을 격리된 환경에서 실행하고, 메모리 관리와 가비지 컬렉션 등을 자동으로 처리하여 안정성과 보안성을 향상시킵니다. 이는 프로그램의 예기치 않은 동작과 메모리 오류를 방지하는 데 도움을 줍니다.

✓ 단점

- 성능 저하: VM을 통해 프로그램을 실행하려면 추가적인 계층이 필요하므로 성능 손실이 발생할 수 있습니다. OS에 직접 실행되는 프로그램에 비해 리소스 소모가 더 크고, VM의 오버헤드가 발생할 수 있습니다.

- 의존성: VM을 사용하는 프로그램은 해당 VM이 설치되어 있어야 정상적으로 실행됩니다. 따라서, 사용자가 VM을 설치하고 관리하는 추가적인 작업이 필요할 수 있습니다.

- 제한된 하드웨어 접근: VM은 하드웨어와 직접적인 상호 작용을 제한하는 경우가 있습니다. 특정 하드웨어 기능에 직접 액세스해야 하는 프로그램의 경우 VM 위에서 실행하기 어려울 수 있습니다.

<br/>
<h2>🤔 JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요.</h2>

<h3>📝 나의 대답</h3>

- 아니요 부모-자식 프로세스 관계라고 보기 어렵습니다.

<h3>GPT의 대답</h3>

- JVM은 자바 가상 머신으로, 운영체제에서 실행되는 독립적인 프로세스입니다. JVM 내에서 실행되는 자바 프로그램은 JVM의 관리 하에서 실행되며, 이는 별도의 프로세스로서 동작합니다. 자바 프로그램은 JVM에서 동작하는 단위로 간주되며, 부모 프로세스 - 자식 프로세스 관계를 갖지 않습니다.

- 일반적으로, 부모 프로세스 - 자식 프로세스 관계는 운영체제 수준에서 발생하는 것으로, 부모 프로세스가 자식 프로세스를 생성하고 관리하는 구조입니다. 하지만 JVM 내에서 실행되는 프로그램은 JVM 자체적으로 프로세스 관리를 수행하며, 운영체제의 프로세스 관리와는 별도입니다.

</div>
</details>

<details>
<summary style="font-size:20px">final keyword</summary>
<div markdown="1">
<br/>
<h2>🤔 final 키워드를 사용하면, 어떤 이점이 있나요.</h2>

<h3>📝 나의 대답</h3>

- Java 프로그래밍 안에 존재하는 final keyword를 사용하면 객체의 생성 주기를 맞출 수 있어 JVM이 객체의 Sync를 맞출 때 발생하는 오버헤드를 줄일 수 있습니다. ❌ 틀렸습니다. ❌

<h3>GPT의 대답</h3>

- final 키워드는 변수, 메서드, 클래스에 사용될 수 있으며, 다음과 같은 이점을 가질 수 있습니다

- 변수 : final 변수는 값을 변경할 수 없는 상수로써 사용됩니다. final 변수는 값의 변경을 방지하여 프로그램의 안정성과 예측 가능성을 높입니다.

- 메서드: final 메서드는 상속을 금지하여 메서드의 오버라이딩을 방지합니다. 이를 통해 부모 클래스가 제공한 기능을 변경하지 못하도록 보장하고, 코드의 안정성과 일관성을 유지할 수 있습니다.

- 클래스: final 클래스는 상속을 금지하여 클래스의 확장을 방지합니다. 이는 클래스의 구현을 완전히 제어하고, 부모 클래스의 기능을 변경하지 못하도록 보장합니다. 또한, final 클래스는 상속으로 인한 보안이슈나 예상치 못한 동작을 방지할 수 있습니다.

<br/>
<h2>🤔 컴파일 과정에서, final 키워드는 다르게 취급되나요.</h2>

<h3>📝 나의 대답</h3>

- 네. 다르게 취급됩니다. 예를 들어 변수에 final keyword를 작성했을 때, 컴파일 시점에서 에러가 발생해 값의 변경을 추적할 수 있습니다. 메소드, 클래스 또한 마찬가지로 값 변경 시 컴파일 시점에 발견할 수 있어 런타임 시 발견되는 에러를 찾을 때보다 리소스가 적게 듭니다.

<h3>GPT의 대답</h3>

- final 키워드는 컴파일 시점에서 값 변경 또는 오버라이딩에 대한 오류를 발견할 수 있어, 런타임 시 발견되는 에러를 사전에 예방하고 리소스를 절약할 수 있습니다. 따라서, final 키워드는 컴파일 과정에서 다르게 취급되어 에러를 컴파일 시점에서 발견할 수 있다는 장점을 가지고 있습니다.
</div>
</details>

<details>
<summary style="font-size:20px">인터페이스와 추상 클래스</summary>
<div markdown="1">
<br/>
<h2>🤔 인터페이스와 추상 클래스의 차이에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 인터페이스는 프로그램 안에서 명세를 정의할 때 사용됩니다. implements한 클래스는 명세에 적힌 내용을 반드시 구현해야 합니다. 반면 추상 클래스는 명세가 아닌 행위를 정의합니다. 상속하는 클래스에선 행위를 재정의할 필요는 없습니다.

<h3>GPT의 대답</h3>

✓ 목적: 인터페이스는 클래스가 가져야 할 기능(메서드)의 명세를 정의하는데 사용됩니다. 인터페이스는 클래스가 특정 메서드를 반드시 구현하도록 강제하며, 다중 상속과 유사한 기능을 제공합니다. 반면, 추상 클래스는 클래스의 행위(behavior)를 정의하며, 구체적인 구현이 필요한 메서드와 추상 메서드를 함께 가질 수 있습니다.

✓ 구현 강제성: 클래스가 인터페이스를 implements(구현)하면, 해당 인터페이스의 모든 메서드를 구현해야 합니다. 인터페이스는 클래스에 특정한 동작을 제공하고, 이를 강제하기 위해 사용됩니다. 추상 클래스는 추상 메서드를 포함할 수 있으며, 이러한 추상 메서드는 하위 클래스에서 반드시 구현되어야 합니다. 하지만 추상 클래스는 구체적인 구현이 필요한 메서드를 가질 수 있으며, 하위 클래스에서 재정의할 필요는 없습니다.

✓ 다중 상속: 인터페이스는 다중 상속을 지원합니다. 클래스가 여러 개의 인터페이스를 구현할 수 있으며, 이를 통해 다양한 기능을 동시에 제공할 수 있습니다. 반면, 추상 클래스는 단일 상속만을 지원하며, 하나의 추상 클래스만 상속받을 수 있습니다.

✓ 인스턴스화: 인터페이스는 인스턴스화될 수 없습니다. 인터페이스는 단지 메서드의 명세를 제공하는 역할을 하며, 구체적인 객체를 생성할 수 없습니다. 추상 클래스는 인스턴스화될 수 있지만, 추상 클래스 내에 추상 메서드가 포함되어 있다면 해당 클래스는 추상 클래스로 선언되어야 합니다.

<br/>
<h2>🤔 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요.</h2>

<h3>📝 나의 대답</h3>

- Java 진영에선 클래스의 상속은 하나 인터페이스 상속은 다중으로 받을 수 있습니다. 이는 복잡성을 제한하기 위함이라고 생각합니다. 인터페이스를 사용한다면 인터페이스 안에 정의된 메소드를 구현해야합니다. 하지만 클래스 상속은 구현을 강제하지 않기 때문에 모호해질 가능성이 존재합니다. 다중 상속으로 몇 뎁스만 내려가도 이 모호함 때문에 코드의 복잡성은 증가할 것입니다.

</div>
</details>

<details>
<summary style="font-size:20px">리플렉션</summary>
<div markdown="1">
<br/>
<h2>🤔 리플렉션에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 리플렉션이란 private으로 keyword로 선언된 메소드, 변수에 접근할 수 있는 기법입니다.

<h3>GPT의 대답</h3>

- 리플렉션(Reflection)은 프로그램이 자기 자신을 검사하고, 클래스의 정보를 동적으로 분석하고 조작할 수 있는 기능을 의미합니다. 리플렉션은 Java의 리플렉션 API를 통해 제공되며, 클래스, 메서드, 필드 등의 정보를 조사하고 호출하며, 인스턴스를 생성하고, 접근 제어자에 관계없이 멤버에 접근할 수 있는 기능을 제공합니다.

<br/>
<h2>🤔 의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요.</h2>

<h3>📝 나의 대답</h3>

- 네. 리플렉션을 잘 이해하지 못하고 무분별하게 사용한다면 코드 스멜을 유발할 것입니다. 이유는 리플렉션은 프로그램 실행 시 동적으로 동작하기 때문입니다. 해결 방법으로는 리플렉션 사용을 하지 않고 동적. 즉, 런타임 때 실행하는 로직은 컴파일 레벨로 내려 구성하는 것이 좋습니다.

<br/>
<h2>🤔 그렇다면 리플렉션을 언제 활용할 수 있을까요.</h2>

<h3>GPT의 대답</h3>

✅ 외부 라이브러리나 프레임워크와의 상호작용: 외부 라이브러리나 프레임워크가 제공하는 클래스나 인터페이스를 사용해야 하는데, 컴파일 시점에는 그 클래스의 정보를 알 수 없는 경우에 리플렉션을 사용할 수 있습니다. 이를 통해 런타임에 외부 라이브러리나 프레임워크와 상호작용할 수 있습니다.

✅ 동적으로 객체의 메서드나 필드에 접근해야 할 때: 프로그램이 실행 중에 특정 객체의 메서드나 필드에 접근해야 하는 경우에 리플렉션을 사용할 수 있습니다. 예를 들어, 객체의 private 메서드에 접근하여 테스트 코드를 작성하거나, 동적으로 필드 값을 변경해야 하는 경우에 리플렉션을 활용할 수 있습니다.

✅ 애노테이션 처리: 리플렉션은 애노테이션(annotation) 정보를 동적으로 분석하고 처리하는 데에도 활용될 수 있습니다. 프로그램이 실행 중에 애노테이션 정보를 검사하거나, 애노테이션을 가진 클래스나 메서드를 동적으로 처리해야 하는 경우에 리플렉션을 사용할 수 있습니다.

</div>
</details>

<details>
<summary style="font-size:20px">static keyword</summary>
<div markdown="1">
<br/>
<h2>🤔 static class와 static method를 비교해 주세요.</h2>

<h3>📝 나의 대답</h3>

- static keyword를 사용하면 JVM method 영역에 생성되며 클래스 로더가 바이트 코드를 해석 시 생성됩니다. static class를 사용하게 되면 같은 이름으로 생성할 수 없고 프로그램 내 하나 뿐 존재하지 않습니다. static method를 사용 시엔 인스턴스 생성 없이 바로 호출해 사용할 수 있습니다. 

<h3>GPT의 대답</h3>

- static keyword: static 키워드는 클래스 레벨에서 사용되는 키워드로, 해당 멤버를 클래스 수준으로 선언하고 인스턴스 생성 없이 클래스 이름을 통해 직접 접근할 수 있도록 합니다. static 멤버는 클래스의 모든 인스턴스에 공유되며, 클래스 로딩 시에 메모리에 할당됩니다.

- static class (정적 중첩 클래스): Java에서는 중첩 클래스를 정의할 수 있습니다. 그 중에는 정적 중첩 클래스(static nested class)라는 개념이 있습니다. 정적 중첩 클래스는 외부 클래스의 인스턴스와 독립적으로 존재하며, 외부 클래스의 인스턴스와 연결되지 않습니다. 정적 중첩 클래스는 외부 클래스의 내부에 선언되고, 정적 멤버나 인스턴스 멤버 모두 접근할 수 있습니다.

- static method (정적 메서드): 정적 메서드는 클래스 수준에서 선언되며, 인스턴스 생성 없이 클래스 이름을 통해 직접 호출할 수 있는 메서드입니다. 정적 메서드는 해당 클래스의 인스턴스와 독립적으로 동작하며, 정적 변수나 다른 정적 메서드에 접근할 수 있습니다. 정적 메서드는 인스턴스 변수나 인스턴스 메서드에 접근할 수 없으며, this 키워드를 사용할 수 없습니다.

<br/>
<h2>🤔 static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요.</h2>

<h3>📝 나의 대답</h3>

- static method를 사용하면 인스턴스 생성 없이 method를 사용할 수 있는 장점이 있습니다. 그러나 무분별하게 사용하면 method 영역의 공간이 부족에 오버 플로의 위험이 존재합니다. static nested class를 사용한다면 캡슐화되어 있어 뎁스가 늘어날 수 있습니다.

<h3>GPT의 대답</h3>

- 제약사항: static 멤버는 클래스 수준으로 선언되므로, 해당 클래스의 인스턴스와 독립적으로 동작합니다. 이로 인해 인스턴스 멤버에 직접 접근할 수 없습니다. 또한, 정적 멤버는 공유되기 때문에 멀티스레드 환경에서 동기화를 고려해야 할 수도 있습니다. 또한, 너무 많은 static 멤버를 사용하면 메모리 사용량이 증가할 수 있으며, 과도한 정적 메모리 사용은 성능 저하나 오버플로우의 위험성을 가질 수 있습니다.

<br/>
<h2>🤔 컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- static keyword가 붙어 있다면 method 영역에 관련 정보를 생성합니다.

<h3>GPT의 대답</h3>

✅ 정적 변수(static variable)

- static 키워드가 변수 선언 앞에 사용되면, 해당 변수는 정적 변수(static variable)가 됩니다. 정적 변수는 클래스 수준에서 선언되며, 프로그램 실행 시 메모리의 데이터 영역에 할당됩니다. 정적 변수는 프로그램 실행 동안 계속해서 유지되며, 클래스의 모든 인스턴스가 공유하는 변수입니다. 컴파일 과정에서는 **정적 변수의 메모리 할당과 초기화가 처리됩니다.**

✅ 정적 메서드(static method)

- static 키워드가 메서드 선언 앞에 사용되면, 해당 메서드는 정적 메서드(static method)가 됩니다. 정적 메서드는 인스턴스 생성 없이 클래스 이름을 통해 직접 호출할 수 있는 메서드입니다. 정적 메서드는 해당 클래스와 관련된 동작을 수행하거나, 유틸리티 메서드를 구현하는 데 사용됩니다. **컴파일 과정에서는 정적 메서드의 바이트 코드가 생성됩니다.**
</div>
</details>

<details>
<summary style="font-size:20px">Exception</summary>
<div markdown="1">
<br/>
<h2>🤔 Java Exception</h2>

<h3>📝 나의 대답</h3>

- Java에선 크게 실행 시 발견되는 Runtime Exception 그리고 코드 작성 시 확인할 수 있는 Compile Exception으로 나눌 수 있습니다. ❌ 틀렸습니다. ❌

<h3>GPT의 대답</h3>

- Java에선 예외는 Trowable 클래스를 상송하는 클래스의 객체로서 표현됩니다. Throwable 클래스는 두 가지 하위 클래스를 갖고 있습니다.

✓ Error : rror 클래스는 시스템 수준에서 발생하는 심각한 오류를 나타냅니다. 이러한 오류는 일반적으로 개발자가 처리할 수 없으며, 예를 들어 가상 머신의 장애 또는 불안정한 환경으로 인한 오류입니다.

✓ Exception : Exception 클래스는 프로그램의 실행 중에 발생하는 예외 상황을 나타냅니다. 이러한 예외는 개발자가 처리하고 관리할 수 있습니다. Exception 클래스는 다시 두 가지 하위 클래스로 나뉩니다.

1. Checked Exception: Checked Exception은 컴파일 시점에서 확인되는 예외입니다. 이 예외들은 명시적으로 처리되어야 하며, 메서드 시그니처에 throws 절로 선언되거나 try-catch 블록으로 처리되어야 합니다. 예를 들어, 파일 입출력 예외(IOException), SQL 예외(SQLException) 등이 이에 해당합니다.

2. Unchecked Exception (Runtime Exception): Unchecked Exception은 컴파일 시점에서 확인되지 않는 예외입니다. 이 예외들은 명시적으로 처리하지 않아도 되며, try-catch 블록으로 처리하지 않아도 됩니다. 주로 프로그래머의 실수나 잘못된 사용으로 인해 발생하는 예외입니다.

<br/>
<h2>🤔 예외처리가 성능에 큰 영향을 미치나요? 만약 그렇다면, 어떻게 하면 부하를 줄일 수 있을까요.</h2>

<h3>📝 나의 대답</h3>

- 예외가 발생하면 해당 예외 발생한 객체를 시작으로 Stack에서 꺼내 예외를 추적합니다. 클래스 생성 시 해당 클래스가 단일 채임 원칙을 따른다면 하나의 클래스가 갖고 있는 코드의 볼륨은 어느 정도 줄일 수 있다고 생각합니다. 따라서 예외 발생 시 부하도 어느 정도 감소할 수 있겠습니다.

<h3>GPT의 대답</h3>

- 예외 처리는 프로그램의 실행 중에 추가적인 비용을 발생시킬 수 있습니다. 예외가 발생하면 예외 객체를 생성하고 스택 추적을 수행하여 예외 처리 메커니즘에 따라 예외를 전파합니다. 이러한 과정은 일반적인 프로그램 실행 경로보다 더 많은 시간과 자원을 소비할 수 있습니다.

- 예외 발생 미리 방지, 예외 처리 범위 최소화, 예외의 종류에 따라 처리 방식 선택, 로깅을 활용한 디버깅, 최적화된 예외 처리 방식 선택을 선택해 비용을 줄일 수 있습니다.

</div>
</details>

<details>
<summary style="font-size:20px">Synchronized</summary>
<div markdown="1">
<br/>
<h2>🤔 Synchronized 키워드에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- Java에 존재하는 키워드 Synchronized는 공유 자원으로 선언 된 자원에 접근할 수 있는 객체가 오직 하나임을 나타내는 역할을 수행합니다.

<h3>GPT의 대답</h3>

- 자바의 synchronized 키워드는 멀티스레드 환경에서의 동기화를 위해 사용되는 키워드입니다. synchronized 키워드를 사용하면 특정 블록이나 메서드에 대한 동기화가 가능해지며, 한 번에 하나의 스레드만 해당 블록 또는 메서드에 접근할 수 있게 됩니다.

- synchronized 키워드를 사용하여 동기화를 구현하면 여러 스레드가 공유 데이터에 동시에 접근하는 것을 방지할 수 있습니다. 이를 통해 스레드 간의 데이터 일관성과 안정성을 보장할 수 있습니다. 그러나 synchronized 키워드는 락을 얻고 해제하는 과정에서 성능 저하를 초래할 수 있으므로, 필요한 경우에만 사용해야 합니다.

<br/>
<h2>🤔 Synchronized 키워드가 어디에 붙는지에 따라 의미가 약간씩 변화하는데, 각각 어떤 의미를 갖게 되는지 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- Synchronized keyword가 객체 앞에 선언되었을 때, 메서드 앞에 선언되었을 때 다릅니다. 우선 공통적으로 공유하는 자원 주체로 동시성 문제를 해결하기 위해 한 번에 한 스레드가 접을 할 수 있습니다. 객체 앞에 존재하면 선언된 객체에 대한 락을 얻은 스레드만 해당 객체를 사용할 수 있고 메서드 앞에 붙으면 인스턴스에 존재하는 다른 메소드는 공유해 사용할 수 있지만 Synchronized가 붙은 메서드 한정으로 락을 획득해 사용해야합니다. ❌ 틀렸습니다. ❌

<h3>GPT의 대답</h3>

✅ 객체 앞에 Synchronized가 선언된 경우

- 해당 객체에 대한 락을 획득한 스레드만 객체를 사용할 수 있습니다.

- 다른 스레드가 해당 객체의 Synchronized 메서드나 Synchronized 블록에 접근하려고 하면, 락이 해제될 때까지 대기 상태에 있게 됩니다.

- 객체 단위로 동기화를 수행하므로, 동일한 객체를 사용하는 다른 메서드에도 영향을 미칩니다.

✅ 메서드 앞에 Synchronized가 선언된 경우

- 인스턴스 메서드에 Synchronized 키워드가 선언되면, 해당 인스턴스에 대한 락을 획득한 스레드만 해당 메서드를 실행할 수 있습니다.

- 다른 스레드가 동일한 인스턴스의 다른 메서드에 접근하려고 해도, 락이 해제되기 전까지 대기 상태에 있게 됩니다.

- 정적(static) 메서드에 Synchronized 키워드가 선언되면, 해당 클래스의 모든 인스턴스에 대한 락을 획득한 스레드만 해당 메서드를 실행할 수 있습니다. 👍🏻

<br/>
<h2>🤔 효율적인 코드 작성 측면에서, Synchronized는 좋은 키워드일까요.</h2>

<h3>📝 나의 대답</h3>

- 효율의 대상을 어디에 두느냐에 따라 다르겠지만 일관성을 반드시 유지해야 할 경우를 제외하곤 Synchronized를 사용하지 않는 것이 성능 면에서 좋습니다.

<br/>
<h2>🤔 Synchronized 를 대체할 수 있는 자바의 다른 동기화 기법에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 공유 자원에 대해 CMS(Compare and Swap)를 제공하는 Atomic 클래스를 사용하면 공유 자원에 대한 동기화 문제를 어느정도 해결할 수 있습니다.

<br/>
<h2>🤔 Thread Local에 대해 설명해 주세요.</h2>

<h3>GPT의 대답</h3>

✅ Thread Local은 Java에서 제공하는 기능으로, 각각의 스레드에 대해 고유한 값의 저장과 검색을 가능하게 해줍니다. 스레드 로컬(Thread Local)은 Thread 클래스의 정적 변수인 ThreadLocal 객체를 통해 사용됩니다.

- Thread Local을 사용하면 한 스레드에서 저장한 데이터는 다른 스레드에서 접근할 수 없습니다. 즉, 스레드 로컬 변수에 저장된 데이터는 해당 스레드 내에서만 유효하며, 다른 스레드에서는 각각 별도의 값을 가질 수 있습니다. 이는 동일한 클래스의 인스턴스를 여러 스레드에서 공유하는 경우 유용할 수 있습니다.

- Thread Local은 다음과 같은 상황에서 유용하게 사용될 수 있습니다:

1. 각각의 스레드가 독립적으로 값을 유지해야 하는 경우

2. 스레드 간에 공유되지 않고 독립적으로 처리되어야 하는 데이터

3. 웹 애플리케이션에서 사용자 세션과 관련된 정보를 저장할 때

- Thread Local은 스레드별로 데이터를 분리하여 처리할 수 있기 때문에 스레드 간의 데이터 충돌을 방지하고 동시성 문제를 해결하는 데 도움이 됩니다. 그러나 Thread Local을 사용할 때에는 메모리 누수에 주의해야 하며, 사용이 완료된 후에는 명시적으로 제거해야 합니다.

</div>
</details>

<details>
<summary style="font-size:20px">Stream</summary>
<div markdown="1">
<br/>
<h2>🤔 Java Stream에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- Java 8 이후에 도입된 기능으로 파이프 라인을 생성해 중간에 노이즈가 발생하지 않게 반복 수행해 일관된 처리를 제공합니다.

<h3>GPT의 대답</h3>

- Java Stream은 Java 8 이후에 도입된 기능으로, 컬렉션과 다양한 데이터 소스를 처리하는 데 사용됩니다. Stream은 데이터의 흐름을 나타내는 개념으로, 중간 연산과 최종 연산으로 구성된 파이프 라인을 생성할 수 있습니다.

- 데이터 처리 파이프라인, 지연 평가, 병렬 처리, 다양한 연산 제공

<br/>
<h2>🤔 Stream과 for ~ loop의 성능 차이를 비교해 주세요</h2>

<h3>📝 나의 대답</h3>

- for ~ loop을 사용하면 지연 처리가 수행되지 않습니다. 반면 Stream은 파이프 라인 마지막까지 중간 연산이 수행되지 않고 Lazy 처리가 됩니다. 또한 Stream이 paraell을 사용한다면 반복 시행이 독립되어 실행해도 무관할 때 멀티 코어를 사용해 빠르게 작업을 처리 할 수 있습니다.

<br/>
<h2>🤔 Stream에서 사용할 수 있는 함수형 인터페이스에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- Stream에서 FP를 사용할 수 있습니다. Java에서 인터페이스를 만들 때, @FuncionalInterface annotaion을 선언하면 하나의 메소드만 명세 가능합니다.

- 함수형 인터페이스를 사용하면 람다식을 사용할 수 있게됩니다. 이는 함수의 구현을 직접 전달할 수 있게 해줍니다. 이를 통해, 코드의 간결성과 가독성을 높일 수 있습니다.

- Stream에서 함수형 인터페이스 즉, 람다식을 사용하게 된다면 stream을 직접 사요하는 것이 아닌 로직 자체를 직접 담을 수 있어 가독성이 늘어납니다.

<br/>
<h2>🤔 Stream에서 사용할 수 있는 함수형 인터페이스에 대해 설명해 주세요.
</h2>

<h3>GPT의 대답</h3>

✅ Consumer\<T>: T 타입의 인수를 받아서 결과를 반환하지 않는 작업을 수행합니다. 주로 Stream의 forEach() 메서드와 함께 사용됩니다.

✅ Supplier\<T>: 인수를 받지 않고 T 타입의 결과를 생성하는 작업을 수행합니다. 주로 Stream의 generate() 메서드나 collect() 메서드의 결과로 사용됩니다.

✅ Predicate\<T>: T 타입의 인수를 받아서 boolean 값을 반환하는 작업을 수행합니다. 주로 Stream의 filter() 메서드와 함께 사용됩니다.

✅ Function\<T, R>: T 타입의 인수를 받아서 R 타입의 결과를 반환하는 작업을 수행합니다. 주로 Stream의 map() 메서드와 함께 사용됩니다.

<br/>
<h2>🤔 가끔 외부 변수를 사용할 때, final 키워드를 붙여서 사용하는데 왜 그럴까요? 꼭 그래야 할까요.</h2>

<h3>📝 나의 대답</h3>

- 네. final을 붙이지 않는다면 동시에 같은 자원에 스레드가 접근할 때, 값이 변경될 수 있습니다.

<h3>GPT의 대답</h3>

- 외부 변수를 람다식 내부에서 수정하는 것은 주의해야 할 부분입니다. 외부 변수를 람다식에서 수정하면서 동시에 병렬 처리를 수행하는 경우, 여러 스레드가 동시에 변수를 수정하려고 시도할 수 있습니다. 이는 스레드 안전성 문제를 일으킬 수 있습니다. 따라서, 외부 변수를 람다식에서 수정하는 경우에는 동기화나 원자적 연산 등의 스레드 안전성을 고려해야 합니다.

</div>
</details>

<details>
<summary style="font-size:20px">GC</summary>
<div markdown="1">
<br/>
<h2>🤔 Java의 GC에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- GC란 가비지 컬렉터를 의미하면 가비지 컬렉터는 가비지 컬렉팅을 수행합니다. C와 C++ 언어는 프로그래머가 메모리 관리를 직접 수행했다면 GC는 JVM이 메모리 관리 측면에서 사용합니다. 이로써 메모리 관리의 책임을 GC에게 맡겨 프로그래머의 생산성을 늘릴 수 있습니다.

<h3>GPT의 대답</h3>

- Java의 GC(Garbage Collector)는 자동 메모리 관리를 수행하는 기능입니다. GC는 더 이상 참조되지 않는 객체를 감지하고, 해당 객체의 메모리를 회수하여 다시 사용 가능한 메모리로 반환합니다. 이를 통해 프로그래머는 메모리 관리에 대한 부담을 덜 수 있으며, 생산성을 향상시킬 수 있습니다.

<br/>
<h2>🤔 finalize() 를 수동으로 호출하는 것은 왜 문제가 될 수 있을까요.</h2>

<h3>GPT의 대답</h3>

✓ finalize() 메서드는 Java에서 객체의 소멸 직전에 호출되는 메서드입니다. 하지만 finalize() 메서드는 Java 9부터는 deprecated되었으며, Java 11부터는 제거되었습니다. 이제는 권장되지 않는 기능입니다.

✅ 제어할 수 없는 타이밍: finalize() 메서드는 가비지 컬렉터에 의해 호출되며, 가비지 컬렉터의 동작은 예측하기 어렵습니다. 수동으로 finalize() 메서드를 호출하면 객체의 소멸 시점을 원하는 시점에 제어할 수 없게 되며, 원하지 않은 부작용이 발생할 수 있습니다.

✅ 성능 저하: finalize() 메서드를 호출하는 과정은 가비지 컬렉터의 동작을 중단시키고 다른 스레드를 활성화하여 소멸 과정을 수행합니다. 이는 성능 저하를 일으킬 수 있으며, 예상치 못한 결과를 초래할 수 있습니다.

✅ 자원 누수: finalize() 메서드 내부에서 자원을 정리하지 않고 빠져나가는 경우, 자원 누수가 발생할 수 있습니다. finalize() 메서드는 객체의 소멸 전에 호출되기 때문에, 객체가 더 이상 사용되지 않더라도 자원을 해제하지 않을 수 있습니다.

<br/>
<h2>🤔 어떤 변수의 값이 null이 되었다면, 이 값은 GC가 될 가능성이 있을까요.</h2>

<h3>📝 나의 대답</h3>

- 네. 변수를 갖고 있는 인스턴스가 더 이상 사용되지 않는다면 GC 시 같이 GC의 대상이 됩니다.

<h3>GPT의 대답</h3>

- 
</div>


</details>