<details>
<summary style="font-size:20px">JVM</summary>
<div markdown="1">
<br/>
<h2>🤔 JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- JVM은 Java Virtua Machine을 이야기하며 자바 Object file을 컴퓨터가 읽을 수 있는 컴파일된 파일로 변경하는 역할을 수행합니다. 또한 JVM은 Java Project의 객체들을 관리해줍니다. 프로그래머의 메모리 관리 책임을 JVM이 해결하므로써 사용자의 편의를 도모하고 다양한 OS위에서 실행할 수 있는 프로세스여서 다기종에 제약없이 Java file을 실행할 수 있습니다.

<h3>GPT의 대답</h3>

- JVM은 Java Virtual Machine의 약어로, 자바 프로그램을 실행하기 위한 가상 머신입니다. JVM은 자바 바이트 코드를 기계어로 변환하고 실행하는 역할을 수행합니다. 이는 자바 언어의 특성 중 하나로, 플랫폼 독립성을 제공합니다. 즉, 자바 프로그램은 운영체제나 하드웨어와 직접적으로 상호작용하지 않고 JVM을 통해 실행될 수 있습니다.

- JVM은 다양한 기능을 수행합니다. 주요 기능으로는 메모리 관리, 가비지 컬렉션, 스레드 관리 등이 있습니다. 메모리 관리 측면에서는 JVM은 메모리 할당과 해제를 관리하며, 가비지 컬렉션은 더 이상 사용되지 않는 객체를 자동으로 제거하여 메모리를 최적화합니다. 또한, JVM은 다중 스레드를 관리하고 동기화를 제공하여 동시성을 지원합니다.

- JVM은 또한 자바 프로그램의 보안을 강화하기 위해 사용됩니다. 클래스 로더를 통해 클래스 파일을 검증하고, 보안 관련 규칙을 적용하여 악성 코드 실행을 방지합니다. 이러한 기능들은 자바의 안전성과 신뢰성을 높이는 데 기여합니다.

<br/>
<h2>🤔 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요</h2>

<h3>📝 나의 대답</h3>

- 아닙니다. 올릴 수 있습니다. JetBrain 사에서 만든 Kotiln 언어는 프로그램 실행 시 JVM을 통해 실행하는 것으로 알고 있습니다. 대신 Java언어에 사용되는 컴파일러가 아닌 Kotiln 컴파일러를 사용해 바이트 코드를 생성할 것으로 예상됩니다.

<h3>GPT의 대답</h3>

- Groovy, Scala, Clojure와 같은 언어도 JVM 위에서 실행됩니다. 이들 언어는 각자의 컴파일러를 사용하여 JVM에서 실행되는 바이트 코드를 생성합니다. 이러한 다양한 언어들은 자바 생태계와의 통합성을 갖고 있어, 자바 라이브러리를 사용하거나 기존 자바 코드와 상호 작용할 수 있습니다.

<br/>
<h2>🤔 반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요.</h2>

<h3>GPT의 대답</h3>

- 특정 언어에 따라 컴파일 과정이 자동화되어 사용자가 직접 컴파일할 필요가 없는 경우도 있을 수 있습니다. 예를 들어, Kotlin 언어의 경우 IntelliJ IDEA와 같은 통합 개발 환경에서 소스 코드를 작성하고 컴파일하는 과정이 자동으로 처리되어 사용자가 명시적으로 컴파일하지 않아도 됩니다. 이 경우에도 사실상 컴파일이 이루어져 JVM에서 실행 가능한 바이트 코드가 생성됩니다.

- 따라서, JVM 계열 언어는 보통 JVM에서 실행될 수 있도록 컴파일되며, 해당 언어의 컴파일러를 사용하여 JVM에서 실행 가능한 바이트 코드로 변환됩니다.

<br/>
<h2>🤔 VM을 사용함으로써 얻을 수 있는 장점과 단점에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- VM을 사용해서 얻을 수 있는 가장 큰 장점은 다양한 OS 환경에서도 실행하고자 하는 프로그램을 구동시킬 수 있다는 것입니다. 반면 단점은 VM을 통해 한 번 더 실행되어야 하기 때문에 OS에 종속적인 프로그램보다 리소스가 더 소모됩니다. 

<h3>GPT의 대답</h3>

✓ 장점

- 플랫폼 독립성: VM은 프로그램을 실행하기 위한 중간 계층으로서, 하드웨어와 운영체제(OS) 사이의 추상화를 제공합니다. 이를 통해 같은 프로그램을 다양한 운영체제에서 실행할 수 있으며, 플랫폼 간 이식성을 높여줍니다.

- 안정성과 보안성: VM은 프로그램을 격리된 환경에서 실행하고, 메모리 관리와 가비지 컬렉션 등을 자동으로 처리하여 안정성과 보안성을 향상시킵니다. 이는 프로그램의 예기치 않은 동작과 메모리 오류를 방지하는 데 도움을 줍니다.

✓ 단점

- 성능 저하: VM을 통해 프로그램을 실행하려면 추가적인 계층이 필요하므로 성능 손실이 발생할 수 있습니다. OS에 직접 실행되는 프로그램에 비해 리소스 소모가 더 크고, VM의 오버헤드가 발생할 수 있습니다.

- 의존성: VM을 사용하는 프로그램은 해당 VM이 설치되어 있어야 정상적으로 실행됩니다. 따라서, 사용자가 VM을 설치하고 관리하는 추가적인 작업이 필요할 수 있습니다.

- 제한된 하드웨어 접근: VM은 하드웨어와 직접적인 상호 작용을 제한하는 경우가 있습니다. 특정 하드웨어 기능에 직접 액세스해야 하는 프로그램의 경우 VM 위에서 실행하기 어려울 수 있습니다.

<br/>
<h2>🤔 JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요.</h2>

<h3>📝 나의 대답</h3>

- 아니요 부모-자식 프로세스 관계라고 보기 어렵습니다.

<h3>GPT의 대답</h3>

- JVM은 자바 가상 머신으로, 운영체제에서 실행되는 독립적인 프로세스입니다. JVM 내에서 실행되는 자바 프로그램은 JVM의 관리 하에서 실행되며, 이는 별도의 프로세스로서 동작합니다. 자바 프로그램은 JVM에서 동작하는 단위로 간주되며, 부모 프로세스 - 자식 프로세스 관계를 갖지 않습니다.

- 일반적으로, 부모 프로세스 - 자식 프로세스 관계는 운영체제 수준에서 발생하는 것으로, 부모 프로세스가 자식 프로세스를 생성하고 관리하는 구조입니다. 하지만 JVM 내에서 실행되는 프로그램은 JVM 자체적으로 프로세스 관리를 수행하며, 운영체제의 프로세스 관리와는 별도입니다.

</div>
</details>

<details>
<summary style="font-size:20px">final keyword</summary>
<div markdown="1">
<br/>
<h2>🤔 final 키워드를 사용하면, 어떤 이점이 있나요.</h2>

<h3>📝 나의 대답</h3>

- Java 프로그래밍 안에 존재하는 final keyword를 사용하면 객체의 생성 주기를 맞출 수 있어 JVM이 객체의 Sync를 맞출 때 발생하는 오버헤드를 줄일 수 있습니다. ❌ 틀렸습니다. ❌

<h3>GPT의 대답</h3>

- final 키워드는 변수, 메서드, 클래스에 사용될 수 있으며, 다음과 같은 이점을 가질 수 있습니다

- 변수 : final 변수는 값을 변경할 수 없는 상수로써 사용됩니다. final 변수는 값의 변경을 방지하여 프로그램의 안정성과 예측 가능성을 높입니다.

- 메서드: final 메서드는 상속을 금지하여 메서드의 오버라이딩을 방지합니다. 이를 통해 부모 클래스가 제공한 기능을 변경하지 못하도록 보장하고, 코드의 안정성과 일관성을 유지할 수 있습니다.

- 클래스: final 클래스는 상속을 금지하여 클래스의 확장을 방지합니다. 이는 클래스의 구현을 완전히 제어하고, 부모 클래스의 기능을 변경하지 못하도록 보장합니다. 또한, final 클래스는 상속으로 인한 보안이슈나 예상치 못한 동작을 방지할 수 있습니다.

<br/>
<h2>🤔 컴파일 과정에서, final 키워드는 다르게 취급되나요.</h2>

<h3>📝 나의 대답</h3>

- 네. 다르게 취급됩니다. 예를 들어 변수에 final keyword를 작성했을 때, 컴파일 시점에서 에러가 발생해 값의 변경을 추적할 수 있습니다. 메소드, 클래스 또한 마찬가지로 값 변경 시 컴파일 시점에 발견할 수 있어 런타임 시 발견되는 에러를 찾을 때보다 리소스가 적게 듭니다.

<h3>GPT의 대답</h3>

- final 키워드는 컴파일 시점에서 값 변경 또는 오버라이딩에 대한 오류를 발견할 수 있어, 런타임 시 발견되는 에러를 사전에 예방하고 리소스를 절약할 수 있습니다. 따라서, final 키워드는 컴파일 과정에서 다르게 취급되어 에러를 컴파일 시점에서 발견할 수 있다는 장점을 가지고 있습니다.
</div>
</details>

<details>
<summary style="font-size:20px">인터페이스와 추상 클래스</summary>
<div markdown="1">
<br/>
<h2>🤔 인터페이스와 추상 클래스의 차이에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 인터페이스는 프로그램 안에서 명세를 정의할 때 사용됩니다. implements한 클래스는 명세에 적힌 내용을 반드시 구현해야 합니다. 반면 추상 클래스는 명세가 아닌 행위를 정의합니다. 상속하는 클래스에선 행위를 재정의할 필요는 없습니다.

<h3>GPT의 대답</h3>

✓ 목적: 인터페이스는 클래스가 가져야 할 기능(메서드)의 명세를 정의하는데 사용됩니다. 인터페이스는 클래스가 특정 메서드를 반드시 구현하도록 강제하며, 다중 상속과 유사한 기능을 제공합니다. 반면, 추상 클래스는 클래스의 행위(behavior)를 정의하며, 구체적인 구현이 필요한 메서드와 추상 메서드를 함께 가질 수 있습니다.

✓ 구현 강제성: 클래스가 인터페이스를 implements(구현)하면, 해당 인터페이스의 모든 메서드를 구현해야 합니다. 인터페이스는 클래스에 특정한 동작을 제공하고, 이를 강제하기 위해 사용됩니다. 추상 클래스는 추상 메서드를 포함할 수 있으며, 이러한 추상 메서드는 하위 클래스에서 반드시 구현되어야 합니다. 하지만 추상 클래스는 구체적인 구현이 필요한 메서드를 가질 수 있으며, 하위 클래스에서 재정의할 필요는 없습니다.

✓ 다중 상속: 인터페이스는 다중 상속을 지원합니다. 클래스가 여러 개의 인터페이스를 구현할 수 있으며, 이를 통해 다양한 기능을 동시에 제공할 수 있습니다. 반면, 추상 클래스는 단일 상속만을 지원하며, 하나의 추상 클래스만 상속받을 수 있습니다.

✓ 인스턴스화: 인터페이스는 인스턴스화될 수 없습니다. 인터페이스는 단지 메서드의 명세를 제공하는 역할을 하며, 구체적인 객체를 생성할 수 없습니다. 추상 클래스는 인스턴스화될 수 있지만, 추상 클래스 내에 추상 메서드가 포함되어 있다면 해당 클래스는 추상 클래스로 선언되어야 합니다.

<br/>
<h2>🤔 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요.</h2>

<h3>📝 나의 대답</h3>

- Java 진영에선 클래스의 상속은 하나 인터페이스 상속은 다중으로 받을 수 있습니다. 이는 복잡성을 제한하기 위함이라고 생각합니다. 인터페이스를 사용한다면 인터페이스 안에 정의된 메소드를 구현해야합니다. 하지만 클래스 상속은 구현을 강제하지 않기 때문에 모호해질 가능성이 존재합니다. 다중 상속으로 몇 뎁스만 내려가도 이 모호함 때문에 코드의 복잡성은 증가할 것입니다.

</div>
</details>

<details>
<summary style="font-size:20px">리플렉션</summary>
<div markdown="1">
<br/>
<h2>🤔 리플렉션에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 리플렉션이란 private으로 keyword로 선언된 메소드, 변수에 접근할 수 있는 기법입니다.

<h3>GPT의 대답</h3>

- 리플렉션(Reflection)은 프로그램이 자기 자신을 검사하고, 클래스의 정보를 동적으로 분석하고 조작할 수 있는 기능을 의미합니다. 리플렉션은 Java의 리플렉션 API를 통해 제공되며, 클래스, 메서드, 필드 등의 정보를 조사하고 호출하며, 인스턴스를 생성하고, 접근 제어자에 관계없이 멤버에 접근할 수 있는 기능을 제공합니다.

<br/>
<h2>🤔 의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요.</h2>

<h3>📝 나의 대답</h3>

- 네. 리플렉션을 잘 이해하지 못하고 무분별하게 사용한다면 코드 스멜을 유발할 것입니다. 이유는 리플렉션은 프로그램 실행 시 동적으로 동작하기 때문입니다. 해결 방법으로는 리플렉션 사용을 하지 않고 동적. 즉, 런타임 때 실행하는 로직은 컴파일 레벨로 내려 구성하는 것이 좋습니다.

<br/>
<h2>🤔 그렇다면 리플렉션을 언제 활용할 수 있을까요.</h2>

<h3>GPT의 대답</h3>

✅ 외부 라이브러리나 프레임워크와의 상호작용: 외부 라이브러리나 프레임워크가 제공하는 클래스나 인터페이스를 사용해야 하는데, 컴파일 시점에는 그 클래스의 정보를 알 수 없는 경우에 리플렉션을 사용할 수 있습니다. 이를 통해 런타임에 외부 라이브러리나 프레임워크와 상호작용할 수 있습니다.

✅ 동적으로 객체의 메서드나 필드에 접근해야 할 때: 프로그램이 실행 중에 특정 객체의 메서드나 필드에 접근해야 하는 경우에 리플렉션을 사용할 수 있습니다. 예를 들어, 객체의 private 메서드에 접근하여 테스트 코드를 작성하거나, 동적으로 필드 값을 변경해야 하는 경우에 리플렉션을 활용할 수 있습니다.

✅ 애노테이션 처리: 리플렉션은 애노테이션(annotation) 정보를 동적으로 분석하고 처리하는 데에도 활용될 수 있습니다. 프로그램이 실행 중에 애노테이션 정보를 검사하거나, 애노테이션을 가진 클래스나 메서드를 동적으로 처리해야 하는 경우에 리플렉션을 사용할 수 있습니다.

</div>
</details>

<details>
<summary style="font-size:20px">static keyword</summary>
<div markdown="1">
<br/>
<h2>🤔 static class와 static method를 비교해 주세요.</h2>

<h3>📝 나의 대답</h3>

- static keyword를 사용하면 JVM method 영역에 생성되며 클래스 로더가 바이트 코드를 해석 시 생성됩니다. static class를 사용하게 되면 같은 이름으로 생성할 수 없고 프로그램 내 하나 뿐 존재하지 않습니다. static method를 사용 시엔 인스턴스 생성 없이 바로 호출해 사용할 수 있습니다. 

<h3>GPT의 대답</h3>

- static keyword: static 키워드는 클래스 레벨에서 사용되는 키워드로, 해당 멤버를 클래스 수준으로 선언하고 인스턴스 생성 없이 클래스 이름을 통해 직접 접근할 수 있도록 합니다. static 멤버는 클래스의 모든 인스턴스에 공유되며, 클래스 로딩 시에 메모리에 할당됩니다.

- static class (정적 중첩 클래스): Java에서는 중첩 클래스를 정의할 수 있습니다. 그 중에는 정적 중첩 클래스(static nested class)라는 개념이 있습니다. 정적 중첩 클래스는 외부 클래스의 인스턴스와 독립적으로 존재하며, 외부 클래스의 인스턴스와 연결되지 않습니다. 정적 중첩 클래스는 외부 클래스의 내부에 선언되고, 정적 멤버나 인스턴스 멤버 모두 접근할 수 있습니다.

- static method (정적 메서드): 정적 메서드는 클래스 수준에서 선언되며, 인스턴스 생성 없이 클래스 이름을 통해 직접 호출할 수 있는 메서드입니다. 정적 메서드는 해당 클래스의 인스턴스와 독립적으로 동작하며, 정적 변수나 다른 정적 메서드에 접근할 수 있습니다. 정적 메서드는 인스턴스 변수나 인스턴스 메서드에 접근할 수 없으며, this 키워드를 사용할 수 없습니다.

<br/>
<h2>🤔 static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요.</h2>

<h3>📝 나의 대답</h3>

- static method를 사용하면 인스턴스 생성 없이 method를 사용할 수 있는 장점이 있습니다. 그러나 무분별하게 사용하면 method 영역의 공간이 부족에 오버 플로의 위험이 존재합니다. static nested class를 사용한다면 캡슐화되어 있어 뎁스가 늘어날 수 있습니다.

<h3>GPT의 대답</h3>

- 제약사항: static 멤버는 클래스 수준으로 선언되므로, 해당 클래스의 인스턴스와 독립적으로 동작합니다. 이로 인해 인스턴스 멤버에 직접 접근할 수 없습니다. 또한, 정적 멤버는 공유되기 때문에 멀티스레드 환경에서 동기화를 고려해야 할 수도 있습니다. 또한, 너무 많은 static 멤버를 사용하면 메모리 사용량이 증가할 수 있으며, 과도한 정적 메모리 사용은 성능 저하나 오버플로우의 위험성을 가질 수 있습니다.

<br/>
<h2>🤔 컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- static keyword가 붙어 있다면 method 영역에 관련 정보를 생성합니다.

<h3>GPT의 대답</h3>

✅ 정적 변수(static variable)

- static 키워드가 변수 선언 앞에 사용되면, 해당 변수는 정적 변수(static variable)가 됩니다. 정적 변수는 클래스 수준에서 선언되며, 프로그램 실행 시 메모리의 데이터 영역에 할당됩니다. 정적 변수는 프로그램 실행 동안 계속해서 유지되며, 클래스의 모든 인스턴스가 공유하는 변수입니다. 컴파일 과정에서는 **정적 변수의 메모리 할당과 초기화가 처리됩니다.**

✅ 정적 메서드(static method)

- static 키워드가 메서드 선언 앞에 사용되면, 해당 메서드는 정적 메서드(static method)가 됩니다. 정적 메서드는 인스턴스 생성 없이 클래스 이름을 통해 직접 호출할 수 있는 메서드입니다. 정적 메서드는 해당 클래스와 관련된 동작을 수행하거나, 유틸리티 메서드를 구현하는 데 사용됩니다. **컴파일 과정에서는 정적 메서드의 바이트 코드가 생성됩니다.**
</div>
</details>

<details>
<summary style="font-size:20px">Exception</summary>
<div markdown="1">
<br/>
<h2>🤔 Java Exception</h2>

<h3>📝 나의 대답</h3>

- Java에선 크게 실행 시 발견되는 Runtime Exception 그리고 코드 작성 시 확인할 수 있는 Compile Exception으로 나눌 수 있습니다. ❌ 틀렸습니다. ❌

<h3>GPT의 대답</h3>

- Java에선 예외는 Trowable 클래스를 상송하는 클래스의 객체로서 표현됩니다. Throwable 클래스는 두 가지 하위 클래스를 갖고 있습니다.

✓ Error : rror 클래스는 시스템 수준에서 발생하는 심각한 오류를 나타냅니다. 이러한 오류는 일반적으로 개발자가 처리할 수 없으며, 예를 들어 가상 머신의 장애 또는 불안정한 환경으로 인한 오류입니다.

✓ Exception : Exception 클래스는 프로그램의 실행 중에 발생하는 예외 상황을 나타냅니다. 이러한 예외는 개발자가 처리하고 관리할 수 있습니다. Exception 클래스는 다시 두 가지 하위 클래스로 나뉩니다.

1. Checked Exception: Checked Exception은 컴파일 시점에서 확인되는 예외입니다. 이 예외들은 명시적으로 처리되어야 하며, 메서드 시그니처에 throws 절로 선언되거나 try-catch 블록으로 처리되어야 합니다. 예를 들어, 파일 입출력 예외(IOException), SQL 예외(SQLException) 등이 이에 해당합니다.

2. Unchecked Exception (Runtime Exception): Unchecked Exception은 컴파일 시점에서 확인되지 않는 예외입니다. 이 예외들은 명시적으로 처리하지 않아도 되며, try-catch 블록으로 처리하지 않아도 됩니다. 주로 프로그래머의 실수나 잘못된 사용으로 인해 발생하는 예외입니다.

<br/>
<h2>🤔 예외처리가 성능에 큰 영향을 미치나요? 만약 그렇다면, 어떻게 하면 부하를 줄일 수 있을까요.</h2>

<h3>📝 나의 대답</h3>

- 예외가 발생하면 해당 예외 발생한 객체를 시작으로 Stack에서 꺼내 예외를 추적합니다. 클래스 생성 시 해당 클래스가 단일 채임 원칙을 따른다면 하나의 클래스가 갖고 있는 코드의 볼륨은 어느 정도 줄일 수 있다고 생각합니다. 따라서 예외 발생 시 부하도 어느 정도 감소할 수 있겠습니다.

<h3>GPT의 대답</h3>

- 예외 처리는 프로그램의 실행 중에 추가적인 비용을 발생시킬 수 있습니다. 예외가 발생하면 예외 객체를 생성하고 스택 추적을 수행하여 예외 처리 메커니즘에 따라 예외를 전파합니다. 이러한 과정은 일반적인 프로그램 실행 경로보다 더 많은 시간과 자원을 소비할 수 있습니다.

- 예외 발생 미리 방지, 예외 처리 범위 최소화, 예외의 종류에 따라 처리 방식 선택, 로깅을 활용한 디버깅, 최적화된 예외 처리 방식 선택을 선택해 비용을 줄일 수 있습니다.

</div>
</details>

<details>
<summary style="font-size:20px">Synchronized</summary>
<div markdown="1">
<br/>
<h2>🤔 Synchronized 키워드에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- Java에 존재하는 키워드 Synchronized는 공유 자원으로 선언 된 자원에 접근할 수 있는 객체가 오직 하나임을 나타내는 역할을 수행합니다.

<h3>GPT의 대답</h3>

- 자바의 synchronized 키워드는 멀티스레드 환경에서의 동기화를 위해 사용되는 키워드입니다. synchronized 키워드를 사용하면 특정 블록이나 메서드에 대한 동기화가 가능해지며, 한 번에 하나의 스레드만 해당 블록 또는 메서드에 접근할 수 있게 됩니다.

- synchronized 키워드를 사용하여 동기화를 구현하면 여러 스레드가 공유 데이터에 동시에 접근하는 것을 방지할 수 있습니다. 이를 통해 스레드 간의 데이터 일관성과 안정성을 보장할 수 있습니다. 그러나 synchronized 키워드는 락을 얻고 해제하는 과정에서 성능 저하를 초래할 수 있으므로, 필요한 경우에만 사용해야 합니다.

<br/>
<h2>🤔 Synchronized 키워드가 어디에 붙는지에 따라 의미가 약간씩 변화하는데, 각각 어떤 의미를 갖게 되는지 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- Synchronized keyword가 객체 앞에 선언되었을 때, 메서드 앞에 선언되었을 때 다릅니다. 우선 공통적으로 공유하는 자원 주체로 동시성 문제를 해결하기 위해 한 번에 한 스레드가 접을 할 수 있습니다. 객체 앞에 존재하면 선언된 객체에 대한 락을 얻은 스레드만 해당 객체를 사용할 수 있고 메서드 앞에 붙으면 인스턴스에 존재하는 다른 메소드는 공유해 사용할 수 있지만 Synchronized가 붙은 메서드 한정으로 락을 획득해 사용해야합니다. ❌ 틀렸습니다. ❌

<h3>GPT의 대답</h3>

✅ 객체 앞에 Synchronized가 선언된 경우

- 해당 객체에 대한 락을 획득한 스레드만 객체를 사용할 수 있습니다.

- 다른 스레드가 해당 객체의 Synchronized 메서드나 Synchronized 블록에 접근하려고 하면, 락이 해제될 때까지 대기 상태에 있게 됩니다.

- 객체 단위로 동기화를 수행하므로, 동일한 객체를 사용하는 다른 메서드에도 영향을 미칩니다.

✅ 메서드 앞에 Synchronized가 선언된 경우

- 인스턴스 메서드에 Synchronized 키워드가 선언되면, 해당 인스턴스에 대한 락을 획득한 스레드만 해당 메서드를 실행할 수 있습니다.

- 다른 스레드가 동일한 인스턴스의 다른 메서드에 접근하려고 해도, 락이 해제되기 전까지 대기 상태에 있게 됩니다.

- 정적(static) 메서드에 Synchronized 키워드가 선언되면, 해당 클래스의 모든 인스턴스에 대한 락을 획득한 스레드만 해당 메서드를 실행할 수 있습니다. 👍🏻

<br/>
<h2>🤔 효율적인 코드 작성 측면에서, Synchronized는 좋은 키워드일까요.</h2>

<h3>📝 나의 대답</h3>

- 효율의 대상을 어디에 두느냐에 따라 다르겠지만 일관성을 반드시 유지해야 할 경우를 제외하곤 Synchronized를 사용하지 않는 것이 성능 면에서 좋습니다.

<br/>
<h2>🤔 Synchronized 를 대체할 수 있는 자바의 다른 동기화 기법에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 공유 자원에 대해 CMS(Compare and Swap)를 제공하는 Atomic 클래스를 사용하면 공유 자원에 대한 동기화 문제를 어느정도 해결할 수 있습니다.

<br/>
<h2>🤔 Thread Local에 대해 설명해 주세요.</h2>

<h3>GPT의 대답</h3>

✅ Thread Local은 Java에서 제공하는 기능으로, 각각의 스레드에 대해 고유한 값의 저장과 검색을 가능하게 해줍니다. 스레드 로컬(Thread Local)은 Thread 클래스의 정적 변수인 ThreadLocal 객체를 통해 사용됩니다.

- Thread Local을 사용하면 한 스레드에서 저장한 데이터는 다른 스레드에서 접근할 수 없습니다. 즉, 스레드 로컬 변수에 저장된 데이터는 해당 스레드 내에서만 유효하며, 다른 스레드에서는 각각 별도의 값을 가질 수 있습니다. 이는 동일한 클래스의 인스턴스를 여러 스레드에서 공유하는 경우 유용할 수 있습니다.

- Thread Local은 다음과 같은 상황에서 유용하게 사용될 수 있습니다:

1. 각각의 스레드가 독립적으로 값을 유지해야 하는 경우

2. 스레드 간에 공유되지 않고 독립적으로 처리되어야 하는 데이터

3. 웹 애플리케이션에서 사용자 세션과 관련된 정보를 저장할 때

- Thread Local은 스레드별로 데이터를 분리하여 처리할 수 있기 때문에 스레드 간의 데이터 충돌을 방지하고 동시성 문제를 해결하는 데 도움이 됩니다. 그러나 Thread Local을 사용할 때에는 메모리 누수에 주의해야 하며, 사용이 완료된 후에는 명시적으로 제거해야 합니다.

</div>
</details>

<details>
<summary style="font-size:20px">Stream</summary>
<div markdown="1">
<br/>
<h2>🤔 Java Stream에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- Java 8 이후에 도입된 기능으로 파이프 라인을 생성해 중간에 노이즈가 발생하지 않게 반복 수행해 일관된 처리를 제공합니다.

<h3>GPT의 대답</h3>

- Java Stream은 Java 8 이후에 도입된 기능으로, 컬렉션과 다양한 데이터 소스를 처리하는 데 사용됩니다. Stream은 데이터의 흐름을 나타내는 개념으로, 중간 연산과 최종 연산으로 구성된 파이프 라인을 생성할 수 있습니다.

- 데이터 처리 파이프라인, 지연 평가, 병렬 처리, 다양한 연산 제공

<br/>
<h2>🤔 Stream과 for ~ loop의 성능 차이를 비교해 주세요</h2>

<h3>📝 나의 대답</h3>

- for ~ loop을 사용하면 지연 처리가 수행되지 않습니다. 반면 Stream은 파이프 라인 마지막까지 중간 연산이 수행되지 않고 Lazy 처리가 됩니다. 또한 Stream이 paraell을 사용한다면 반복 시행이 독립되어 실행해도 무관할 때 멀티 코어를 사용해 빠르게 작업을 처리 할 수 있습니다.

<br/>
<h2>🤔 Stream에서 사용할 수 있는 함수형 인터페이스에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- Stream에서 FP를 사용할 수 있습니다. Java에서 인터페이스를 만들 때, @FuncionalInterface annotaion을 선언하면 하나의 메소드만 명세 가능합니다.

- 함수형 인터페이스를 사용하면 람다식을 사용할 수 있게됩니다. 이는 함수의 구현을 직접 전달할 수 있게 해줍니다. 이를 통해, 코드의 간결성과 가독성을 높일 수 있습니다.

- Stream에서 함수형 인터페이스 즉, 람다식을 사용하게 된다면 stream을 직접 사요하는 것이 아닌 로직 자체를 직접 담을 수 있어 가독성이 늘어납니다.

<br/>
<h2>🤔 Stream에서 사용할 수 있는 함수형 인터페이스에 대해 설명해 주세요.
</h2>

<h3>GPT의 대답</h3>

✅ Consumer\<T>: T 타입의 인수를 받아서 결과를 반환하지 않는 작업을 수행합니다. 주로 Stream의 forEach() 메서드와 함께 사용됩니다.

✅ Supplier\<T>: 인수를 받지 않고 T 타입의 결과를 생성하는 작업을 수행합니다. 주로 Stream의 generate() 메서드나 collect() 메서드의 결과로 사용됩니다.

✅ Predicate\<T>: T 타입의 인수를 받아서 boolean 값을 반환하는 작업을 수행합니다. 주로 Stream의 filter() 메서드와 함께 사용됩니다.

✅ Function\<T, R>: T 타입의 인수를 받아서 R 타입의 결과를 반환하는 작업을 수행합니다. 주로 Stream의 map() 메서드와 함께 사용됩니다.

<br/>
<h2>🤔 가끔 외부 변수를 사용할 때, final 키워드를 붙여서 사용하는데 왜 그럴까요? 꼭 그래야 할까요.</h2>

<h3>📝 나의 대답</h3>

- 네. final을 붙이지 않는다면 동시에 같은 자원에 스레드가 접근할 때, 값이 변경될 수 있습니다.

<h3>GPT의 대답</h3>

- 외부 변수를 람다식 내부에서 수정하는 것은 주의해야 할 부분입니다. 외부 변수를 람다식에서 수정하면서 동시에 병렬 처리를 수행하는 경우, 여러 스레드가 동시에 변수를 수정하려고 시도할 수 있습니다. 이는 스레드 안전성 문제를 일으킬 수 있습니다. 따라서, 외부 변수를 람다식에서 수정하는 경우에는 동기화나 원자적 연산 등의 스레드 안전성을 고려해야 합니다.

</div>
</details>

<details>
<summary style="font-size:20px">GC</summary>
<div markdown="1">
<br/>
<h2>🤔 Java의 GC에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- GC란 가비지 컬렉터를 의미하면 가비지 컬렉터는 가비지 컬렉팅을 수행합니다. C와 C++ 언어는 프로그래머가 메모리 관리를 직접 수행했다면 GC는 JVM이 메모리 관리 측면에서 사용합니다. 이로써 메모리 관리의 책임을 GC에게 맡겨 프로그래머의 생산성을 늘릴 수 있습니다.

<h3>GPT의 대답</h3>

- Java의 GC(Garbage Collector)는 자동 메모리 관리를 수행하는 기능입니다. GC는 더 이상 참조되지 않는 객체를 감지하고, 해당 객체의 메모리를 회수하여 다시 사용 가능한 메모리로 반환합니다. 이를 통해 프로그래머는 메모리 관리에 대한 부담을 덜 수 있으며, 생산성을 향상시킬 수 있습니다.

<br/>
<h2>🤔 finalize() 를 수동으로 호출하는 것은 왜 문제가 될 수 있을까요.</h2>

<h3>GPT의 대답</h3>

✓ finalize() 메서드는 Java에서 객체의 소멸 직전에 호출되는 메서드입니다. 하지만 finalize() 메서드는 Java 9부터는 deprecated되었으며, Java 11부터는 제거되었습니다. 이제는 권장되지 않는 기능입니다.

✅ 제어할 수 없는 타이밍: finalize() 메서드는 가비지 컬렉터에 의해 호출되며, 가비지 컬렉터의 동작은 예측하기 어렵습니다. 수동으로 finalize() 메서드를 호출하면 객체의 소멸 시점을 원하는 시점에 제어할 수 없게 되며, 원하지 않은 부작용이 발생할 수 있습니다.

✅ 성능 저하: finalize() 메서드를 호출하는 과정은 가비지 컬렉터의 동작을 중단시키고 다른 스레드를 활성화하여 소멸 과정을 수행합니다. 이는 성능 저하를 일으킬 수 있으며, 예상치 못한 결과를 초래할 수 있습니다.

✅ 자원 누수: finalize() 메서드 내부에서 자원을 정리하지 않고 빠져나가는 경우, 자원 누수가 발생할 수 있습니다. finalize() 메서드는 객체의 소멸 전에 호출되기 때문에, 객체가 더 이상 사용되지 않더라도 자원을 해제하지 않을 수 있습니다.

<br/>
<h2>🤔 어떤 변수의 값이 null이 되었다면, 이 값은 GC가 될 가능성이 있을까요.</h2>

<h3>📝 나의 대답</h3>

- 네. 변수를 갖고 있는 인스턴스가 더 이상 사용되지 않는다면 GC 시 같이 GC의 대상이 됩니다.

</div>
</details>

<details>
<summary style="font-size:20px">equals()와 hashcode()</summary>
<div markdown="1">
<br/>
<h2>🤔 equals()와 hashcode()에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- equals는 객체의 값이 일치하는 지 확인하는 것이고 hashcode는 객체가 갖고 있는 주소 값이 같은 지 비교하는 것입니다. 객체의 값이 동등하다고 해서 동일한 것은 아니며 완벽하게 일치하는 객체를 비교할 땐 equals와 hashcode를 선언해 사용해야합니다.

<br/>
<h2>🤔 본인이 hashcode() 를 정의해야 한다면, 어떤 점을 염두에 두고 구현할 것 같으세요.</h2>

<h3>📝 나의 대답</h3>

- 해시 값을 통해 동일성을 판단함으로 hashcode를 만든다면 해시 충돌을 염두하고 코드를 작성할 것 같습니다.

<br/>
<h2>🤔 그렇다면 equals() 를 재정의 해야 할 때, 어떤 점을 염두에 두어야 하는지 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 동등성을 비교하기 위해서 equals 메소드를 사용하기 때문에 객체 내부에 선언되어 있는 변수 값들을 비교하는 로직을 염두해 코드를 작성할 것입니다.

<h3>GPT의 대답</h3>

- 일관성과 대칭성: equals() 메서드는 일관성과 대칭성을 유지해야 합니다. 객체 A와 B를 비교할 때, A.equals(B)가 true라면 B.equals(A)도 true가 되어야 합니다. 또한, 객체의 내부 상태가 변경되지 않는 한 동일한 결과를 반환해야 합니다.

- null 비교: equals() 메서드를 구현할 때는 null 값에 대한 처리도 고려해야 합니다. 객체와 null을 비교할 때 NullPointerException이 발생하지 않도록 적절한 처리를 해야 합니다.

- 상속 고려: equals() 메서드를 재정의할 때는 상속 관계를 고려해야 합니다. 상위 클래스에서 equals()를 재정의한 경우 하위 클래스에서도 일관성을 유지하기 위해 재정의해야 할 수도 있습니다.

</div>
</details>

<details>
<summary style="font-size:20px">IoC and DI</summary>
<div markdown="1">
<br/>
<h2>🤔 IoC와 DI에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- IoC는 제어의 역전을 의미하며 프로세스의 흐름 관리를 프로그래머가 갖는 것이 아닌 Framework이 갖고 있는 것을 의미합니다.

- DI는 의존성 역전을 의미하며 인터페이스를 사용해 기능을 구현, Runtime 시, 구현 코드를 결정하고 실행하는 것을 의미합니다. 실행되는 객체는 인터페이스를 상속받은 객체이며 이를 통해 OCP를 달성할 수 있습니다.

<h3>GPT의 대답</h3>

- DI (Dependency Injection)는 의존성 역전을 의미합니다. DI는 객체 간의 의존 관계를 코드 내부에서 직접 생성하는 것이 아니라 외부에서 주입받는 방식으로 처리합니다. 일반적으로 인터페이스를 정의하고 이를 구현한 객체를 주입하여 실행 시점에 객체의 종속성을 해결합니다.

<br/>
<h2>🤔 후보 없이 특정 기능을 하는 클래스가 딱 한 개하면, 구체 클래스를 그냥 사용해도 되지 않나요? 그럼에도 불구하고 왜 Spring에선 Bean을 사용 할까요.</h2>

<h3>📝 나의 대답</h3>

- 특정 기능을 수행하는 클래스가 하나더라도 Bean을 사용하는 이유는 제어의 역전과 의존성 주입 때문에 사용합니다. 실행 시 컨텍스트에 Bean 정보가 없다면 인스턴스 자체가 생성되지 않기 때문입니다.

<br/>
<h2>🤔 Spring의 Bean 생성 주기에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 애플리케이션 실행 시, spring의 context manager가 bean 정보를 저장합니다. 이 때, 인스턴스가 생성되는 것이 아닌 bean의 메타 정보만 생성되며 해당 bean이 실행될 때 인스턴스가 생성되어 주입됩니다. 객체 사용이 끝난다면 bean을 주입받은 객체가 GC에 의해 회수되기 전 내부 주입된 Bean 먼저 회수된 후 회수됩니다. 또한 bean은 싱글톤으로 유지되기 때문에 재사용될 수 있습니다.

<h3>GPT의 대답</h3>

- Bean의 인스턴스화, 의존성 주입, 초기화, 사용, 소멸 과정을 거칩니다.

<br/>
<h2>🤔 프로토타입 빈은 무엇인가요.</h2>

<h3>GPT의 대답</h3>

✅ 프로토타입(Prototype) 빈은 Spring Framework에서 제공하는 Bean의 스코프(scope) 중 하나입니다. 프로토타입 빈은 요청할 때마다 새로운 인스턴스가 생성되는 스코프입니다.

✅ 프로토타입 빈은 매번 요청할 때마다 새로운 객체 인스턴스가 생성되므로 싱글톤(Singleton)과는 달리 각각의 인스턴스가 독립적으로 동작합니다. 이는 매 요청마다 새로운 상태를 가진 객체가 필요할 때 유용합니다.
</div>
</details>

<details>
<summary style="font-size:20px">AOP</summary>
<div markdown="1">
<br/>
<h2>🤔 AOP란 무엇인가요?</h2>

<h3>📝 나의 대답</h3>

- AOP란 프로그램 내에 존재하는 여러 프로세스에 공통으로 사용되는 관심사를 분리하는 것입니다. 예를 들어 사용자의 인가 처리가 이에 해당됩니다.

<h3>GPT의 대답</h3>

- AOP(Aspect-Oriented Programming)는 프로그래밍에서 관심사의 분리를 위한 개념입니다. 프로그램은 일반적으로 여러 관심사를 가지고 있으며, 이러한 관심사들은 여러 모듈 또는 객체들에 걸쳐 분산되어 있을 수 있습니다. AOP는 이러한 관심사들을 분리하여 모듈화하고, 필요한 부분에서 적용함으로써 코드의 중복을 줄이고 유지보수성을 향상시킬 수 있습니다.

<br/>
<h2>🤔 @Aspect는 어떻게 동작하나요.</h2>

<h3>GPT의 대답</h3>

✅ @Aspect 어노테이션이 적용된 클래스는 Spring 컨테이너에 의해 스캔되어 애스펙트로 등록되며, 애플리케이션에서 해당 애스펙트의 포인트컷이 적용되는 지점에서 어드바이스가 동작하게 됩니다. 이를 통해 AOP의 효과적인 구현과 관심사의 분리를 할 수 있습니다.

✅ 포인트컷(Pointcut): 애스펙트에서 공통 관심사가 적용될 지점을 선택하기 위해 포인트컷을 정의합니다. 포인트컷은 특정 메서드, 클래스, 패키지 등과 같은 지정된 지점을 나타내는 표현식입니다. Spring은 다양한 포인트컷 표현식을 지원하며, @Pointcut 어노테이션을 사용하여 포인트컷을 정의합니다.

✅ 어드바이스(Advice): 포인트컷이 선택한 지점에 실제로 수행될 동작을 정의합니다. 예를 들어, 메서드 실행 전/후에 실행되는 메서드, 예외 발생 시 실행되는 메서드 등을 정의할 수 있습니다. Spring은 다양한 어드바이스 종류를 지원하며, @Before, @After, @Around, @AfterThrowing, @AfterReturning 등의 어노테이션을 사용하여 어드바이스를 정의합니다.

✅ 위빙(Weaving): 애스펙트를 적용할 대상 객체에 애스펙트를 연결하는 과정을 의미합니다. Spring은 위빙을 통해 프록시 패턴 또는 다이나믹 프록시를 사용하여 애스펙트와 핵심 로직을 연결합니다. 이를 통해 애스펙트에 정의된 공통 관심사가 적용됩니다.

</div>
</details>

<details>
<summary style="font-size:20px">interceptor, filter</summary>
<div markdown="1">
<br/>
<h2>🤔 Spring 에서 Interceptor와 Servlet Filter에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- Interceptor는 Spring framework에서 제공하는 Library이며 filter는 servlet에서 제공하는 Library입니다. interface는 요청을 dispatcher servlet이 받은 뒤에 저리하며 filter는 요청이 dispatcher에 전에 처리하는 역할을 맡습니다.

<h3>GPT의 대답</h3>

- Interceptor는 Spring Framework에서 제공하는 기능으로, Dispatcher Servlet이 요청을 처리하기 전후로 수행되는 역할을 담당합니다. Interceptor는 주로 전역적인 작업이나 공통된 로직을 처리하기 위해 사용됩니다. 예를 들어, 요청의 인증, 권한 검사, 로깅, 예외 처리 등과 같은 공통된 작업을 Interceptor를 통해 처리할 수 있습니다. Interceptor는 HandlerInterceptor 인터페이스를 구현하여 정의하며, preHandle, postHandle, afterCompletion 등의 메서드를 제공하여 요청 처리 전후에 필요한 작업을 수행할 수 있습니다.

- Servlet Filter는 Java Servlet 스펙에서 제공하는 기능으로, 요청이 서블릿으로 전달되기 전후에 수행되는 역할을 담당합니다. Servlet Filter는 주로 HTTP 요청 및 응답의 전처리 및 후처리 작업을 처리하기 위해 사용됩니다. 예를 들어, 요청/응답 인코딩, XSS 방지, 세션 관리, 캐싱 등과 같은 작업을 Filter를 통해 처리할 수 있습니다. Servlet Filter는 javax.servlet.Filter 인터페이스를 구현하여 정의하며, doFilter 메서드를 통해 요청과 응답에 대한 필터링 작업을 수행합니다.

<br/>
<h2>🤔 설명만 들어보면 인터셉터만 쓰는게 나아보이는데, 아닌가요? 필터는 어떤 상황에 사용 해야 하나요.</h2>

<h3>📝 나의 대답</h3>

- Filter가 반드시 필요할 때가 존재합니다. interceptor를 사용하게 된다면 매 요청 전처리마다 인코딩 혹은 디코딩 과정이 포함되어 있는데 이 것은 dispatcher servlet 전에 존재하는 filter에게 역할을 맡기게 된다면 공통으로 처리할 수 있게되어 리소스가 절약됩니다.

<h3>GPT의 대답</h3>

- Interceptor는 Spring Framework와 함께 사용되며, Spring의 빈과 통합되어 동작합니다. Filter는 Java Servlet 스펙에 따라 동작하므로, 어떠한 웹 프레임워크에서도 사용할 수 있습니다.

- Filter는 주로 HTTP 요청 및 응답에 대한 전처리 및 후처리 작업을 처리하기 위해 사용하며, 여러 서블릿에서 공통으로 수행해야 할 작업에 적합합니다.

- Interceptor는 Spring Framework와 함께 사용되며, 전역적인 작업이나 공통된 로직을 처리하기 위해 사용되며, Spring의 빈과 통합되어 동작합니다.

</div>
</details>

<details>
<summary style="font-size:20px">dispatcher</summary>
<div markdown="1">
<br/>
<h2>🤔 DispatcherServlet 의 역할에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- Dispatcher Servlet은 Http 요청을 Thread에 할당하는 역할을 수행하며 해당 요청의 스펙을 확인해 해석하는 역할을 담당합니다. 

<h3>GPT의 대답</h3>

- DispatcherServlet은 클라이언트로부터 들어오는 HTTP 요청을 받아들이고, 해당 요청을 처리하기 위해 핸들러(컨트롤러)로 매핑해주는 역할을 합니다. 요청이 들어오면 DispatcherServlet은 URL 매핑 정보를 참조하여 적절한 핸들러로 요청을 전달합니다. 핸들러는 일반적으로 컨트롤러(Controller)로서 요청을 처리하고, 결과를 DispatcherServlet에 반환합니다.

- DispatcherServlet은 Spring MVC 웹 애플리케이션에서 중앙 집중식으로 요청을 처리하는 역할을 수행하며, 핸들러 매핑, 핸들러 실행, 뷰 리졸브, 뷰 렌더링 등 다양한 기능을 제공합니다. 이를 통해 웹 애플리케이션의 개발과 유지보수를 효과적으로 할 수 있습니다.

<br/>
<h2>🤔 여러 요청이 들어온다고 가정할 때, DispatcherServlet은 한번에 여러 요청을 모두 받을 수 있나요.</h2>

<h3>GPT의 대답</h3>

✅ DispatcherServlet은 실질적으로 서블릿 컨테이너가 관리하는 서블릿입니다. 서블릿 컨테이너는 서버에 도착하는 각 요청에 대해 별도의 스레드를 생성합니다. DispatcherServlet이 사용자 요청을 처리하는 동안, 새로운 스레드가 생성되어 추가적인 요청을 처리할 수 있게 됩니다.

- 이로 인해 한 번에 여러 요청을 동시에 받아 처리할 수 있는 멀티스레딩 환경이 구성됩니다. 이런 멀티스레딩 동작 방식은 웹 애플리케이션이 많은 수의 동시 요청을 효과적으로 처리할 수 있게 해줍니다.

- 또한 WAS가 처음 시작될 때, Thread를 Pool에 미리 생성해둬 생성 시간을 줄여 오버헤드를 감소시킬 수 있습니다.

<br/>
<h2>🤔 수많은 @Controller 를 DispatcherServlet은 어떻게 구분 할까요.</h2>

<h3>📝 나의 대답</h3>

- Thread Local Pattern을 사용해 구분할 수 있습니다. Thread Local은 Thread에게 고유한 상태를 갖게 하는 것이며 이를 통해 구분할 수 있습니다. ❌ 틀렸습니다.

<h3>GPT의 대답</h3>

✅ DispatcherServlet이 여러 @Controller를 구분하는 방법은 주로 요청의 URL, HTTP 메소드 등을 기반으로 합니다. 이는 컨트롤러의 @RequestMapping, @GetMapping, @PostMapping 등의 어노테이션과 함께 동작하여 특정 요청이 어떤 컨트롤러에 의해 처리될 것인지 결정합니다.

- "Thread Local 패턴"은 각 스레드가 자신만의 데이터를 가질 수 있도록 하는 패턴으로, 동시성 문제를 다룰 때 유용합니다. 하지만 이것은 DispatcherServlet이 여러 @Controller를 구분하는 방식과는 직접적으로 관련이 없습니다.

</div>
</details>

<details>
<summary style="font-size:20px">JPA</summary>
<div markdown="1">
<br/>
<h2>🤔 JPA와 같은 ORM을 사용하는 이유가 무엇인가요?</h2>

<h3>📝 나의 대답</h3>

- ORM 기술을 사용하는 이유는 데이터 중심의 진행 과정에서 관계 중심의 처리를 사용하기 위함입니다.

<h3>GPT의 대답</h3>

1. 개발 생산성 향상: ORM 프레임워크를 사용하면 개발자는 SQL을 직접 작성하지 않아도 되므로, 데이터베이스 작업을 더 빠르고 효율적으로 처리할 수 있습니다. 이렇게 함으로써 개발자는 비즈니스 로직에 더 집중할 수 있습니다.

2. 데이터베이스 독립성: ORM은 데이터베이스 시스템 간의 차이점을 추상화하여, 개발자가 특정 데이터베이스에 의존하지 않고 개발할 수 있게 해줍니다. 따라서 코드의 이식성이 향상됩니다.

3. 객체지향적인 코드 작성 가능: ORM을 사용하면, 데이터를 객체로 관리할 수 있으므로 객체 지향 프로그래밍을 더 잘 수행할 수 있습니다. 이는 코드의 재사용성과 유지보수성을 향상시킵니다.

4. 데이터 무결성 보장: ORM은 종종 트랜잭션 관리와 같은 기능을 제공합니다. 이를 통해 데이터 무결성을 보장하고, 복잡한 상황에서도 데이터의 일관성을 유지할 수 있습니다.

<br/>
<h2>🤔 영속성은 어떤 기능을 하나요? 이게 진짜 성능 향상에 큰 도움이 되나요.</h2>

<h3>📝 나의 대답</h3>

- 영속성 컨텍스트는 Bean을 등록해 관리할 때 사용합니다. 변경 감지를 제공하며 조회 시 내부 캐시를 사용해 DB의 접근 횟수를 줄여 성능 향상에 도움을 줍니다.

<h3>GPT의 대답</h3>

- 영속성(persistence)은 데이터를 애플리케이션의 생명 주기를 넘어서서도 유지할 수 있게 하는 기능입니다. 이는 일반적으로 데이터베이스나 파일 시스템과 같은 영구적인 저장 공간에 데이터를 저장하고 필요할 때 다시 불러올 수 있게 해줍니다.

- ORM(Object-Relational Mapping) 시스템에서, "영속성 컨텍스트"라는 용어는 종종 ORM이 관리하는 엔티티 객체의 생명 주기를 가리킵니다. 이러한 컨텍스트에서 객체는 일반적으로 다음의 상태 중 하나에 있습니다: "비영속", "영속", "준영속", "삭제". 여기서 "영속" 상태는 객체가 영속성 컨텍스트에 의해 관리되고 있음을 의미합니다.

1. 1차 캐시: 영속성 컨텍스트는 일반적으로 1차 캐시를 내장하고 있습니다. 이 캐시에는 이미 한 번 로드된 엔티티 객체의 복사본이 저장됩니다. 같은 객체를 다시 요청하면, 데이터베이스 대신 이 캐시에서 객체를 가져오므로 데이터베이스 접근 횟수를 줄일 수 있습니다.

2. 변경 감지(Dirty Checking): 영속성 컨텍스트는 관리 중인 엔티티 객체의 변경을 감지하고, 이를 데이터베이스에 자동으로 반영합니다. 이를 통해 개발자는 직접적인 업데이트 SQL을 작성하지 않아도 되며, 변경이 필요한 경우에만 데이터베이스 작업이 이루어지므로 성능 향상에 도움이 됩니다.

3. 쓰기 지연 (Write-behind): 영속성 컨텍스트는 가능한 한 트랜잭션의 끝까지 데이터베이스 쓰기를 지연시킵니다. 이를 통해 필요한 경우 한 번에 여러 개의 변경을 묶어서 처리할 수 있습니다.

<br/>
<h2>🤔 N + 1 문제에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- N + 1 문제는 ORM 기술 사용 시 엔티티 사이 관계를 맺고 있을 때, 찾고자 하는 1의 데이터 이외 N개의 추가 쿼리가 발생하는 문제를 이야기합니다.

</div>
</details>

<details>
<summary style="font-size:20px">Annotation</summary>
<div markdown="1">
<br/>
<h2>🤔 Java 에서 Annotation 은 어떤 기능을 하나요.</h2>

<h3>📝 나의 대답</h3>

- Java에서 Annotation은 메타 정보를 클래스에 부여하는 역할을 수행합니다. Annotation은 인스턴스를 갖지 않지만 클래스의 구분을 도와 역할을 구분할 수 있게 만들 수 있습니다.

<h3>GPT의 대답</h3>

- Java에서 Annotation은 프로그램의 메타데이터를 나타내는 특별한 형식의 주석입니다. Annotation은 컴파일러, 런타임 시스템, 개발 도구 등에게 정보를 전달하고 특정 기능을 활성화하기 위해 사용됩니다.

- 정보 제공(@Override), 컴파일 타임 검사(@Deprecated), 실행 시 동작 제어(@Autowired), 리플렉션을 통한 메타데이터 액세스, 코드 생성(@Getter)
</div>
</details>

<details>
<summary style="font-size:20px">Tomcat</summary>
<div markdown="1">
<br/>
<h2>🤔 Tomcat이 정확히 어떤 역할을 하는 도구인가요?</h2>

<h3>📝 나의 대답</h3>

- tomcat은 웹을 동적으로 처리할 수 있게 도와주는 서버입니다.

<h3>GPT의 대답</h3>

- 웹 서버: Tomcat은 정적인 웹 페이지(HTML, CSS, JavaScript 등)를 서비스하는 기능을 가지고 있습니다. 클라이언트의 요청에 따라 정적인 컨텐츠를 제공하고, HTTP 프로토콜을 사용하여 클라이언트와 통신합니다.

- 서블릿 컨테이너: Tomcat은 Java Servlet과 JSP와 같은 동적인 웹 애플리케이션을 실행하는 서블릿 컨테이너로서의 역할을 수행합니다. 서블릿 컨테이너는 서블릿 코드를 실행하고 관리하며, 클라이언트의 요청에 따라 동적인 컨텐츠를 생성합니다.

- 요청 처리 및 스레드 관리: Tomcat은 클라이언트의 요청을 처리하기 위한 다중 스레드 모델을 가지고 있습니다. 동시에 여러 요청을 처리하고, 스레드 풀을 사용하여 효율적으로 리소스를 관리합니다.

- 세션 관리: Tomcat은 세션 관리 기능을 제공하여 클라이언트의 상태를 유지합니다. 세션을 사용하여 사용자 식별, 인증, 상태 추적 등을 처리할 수 있습니다.

- 보안: Tomcat은 보안 기능을 제공하여 애플리케이션의 안전성을 강화합니다. SSL/TLS 암호화를 지원하고, 접근 제어, 인증, 권한 부여 등의 보안 메커니즘을 제공합니다.

- 확장성: Tomcat은 확장 가능한 아키텍처를 가지고 있습니다. 다양한 기능을 제공하는 플러그인과 확장 모듈을 사용하여 기능을 추가하거나 커스터마이징할 수 있습니다.

<br/>
<h2>🤔 tomcat과 netty</h2>

<h3>GPT의 대답</h3>

✅ Tomcat: Tomcat은 기본적으로 스레드 풀을 사용하여 클라이언트 요청을 처리합니다. 스레드 풀은 동기 방식으로 동작하며, 요청당 하나의 스레드를 할당하여 처리합니다. 따라서, Tomcat은 많은 스레드를 사용하여 동시에 많은 요청을 처리할 수 있지만, 스레드당 메모리 오버헤드가 발생할 수 있습니다. Tomcat은 일반적으로 비동기 작업을 수행하기 위해 스레드를 사용하는 방식을 선호하지는 않습니다.

✅ Netty: Netty는 이벤트 드리븐 아키텍처와 비동기 I/O 모델을 사용하여 비동기 처리를 효율적으로 수행합니다. Netty는 단일 이벤트 루프를 사용하여 다중 클라이언트 요청을 처리하며, I/O 작업은 블로킹하지 않고 비동기로 처리됩니다. 이를 통해 단일 스레드로 많은 요청을 처리하고, 스레드간의 컨텍스트 스위칭 비용을 줄이며, 메모리 사용을 최적화할 수 있습니다. Netty는 비동기 작업에 최적화되어 있어 대용량 및 고성능 네트워크 애플리케이션에서 효과적으로 사용될 수 있습니다.

- 따라서, Tomcat은 주로 전통적인 웹 애플리케이션을 구축하고 관리하는 데 사용되며, 비동기 처리에 대한 요구가 높지 않을 경우 적합합니다. Netty는 대규모 및 실시간 네트워크 애플리케이션에서 비동기 처리와 고성능이 필요한 경우 특히 유용합니다. 선택은 애플리케이션의 요구 사항과 성능/확장성 요구 사항에 따라 결정되어야 합니다.
</div>
</details>