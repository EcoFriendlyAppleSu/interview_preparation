<details>
<summary style="font-size:20px">JVM</summary>
<div markdown="1">
<br/>
<h2>🤔 JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- JVM은 Java Virtua Machine을 이야기하며 자바 Object file을 컴퓨터가 읽을 수 있는 컴파일된 파일로 변경하는 역할을 수행합니다. 또한 JVM은 Java Project의 객체들을 관리해줍니다. 프로그래머의 메모리 관리 책임을 JVM이 해결하므로써 사용자의 편의를 도모하고 다양한 OS위에서 실행할 수 있는 프로세스여서 다기종에 제약없이 Java file을 실행할 수 있습니다.

<h3>GPT의 대답</h3>

- JVM은 Java Virtual Machine의 약어로, 자바 프로그램을 실행하기 위한 가상 머신입니다. JVM은 자바 바이트 코드를 기계어로 변환하고 실행하는 역할을 수행합니다. 이는 자바 언어의 특성 중 하나로, 플랫폼 독립성을 제공합니다. 즉, 자바 프로그램은 운영체제나 하드웨어와 직접적으로 상호작용하지 않고 JVM을 통해 실행될 수 있습니다.

- JVM은 다양한 기능을 수행합니다. 주요 기능으로는 메모리 관리, 가비지 컬렉션, 스레드 관리 등이 있습니다. 메모리 관리 측면에서는 JVM은 메모리 할당과 해제를 관리하며, 가비지 컬렉션은 더 이상 사용되지 않는 객체를 자동으로 제거하여 메모리를 최적화합니다. 또한, JVM은 다중 스레드를 관리하고 동기화를 제공하여 동시성을 지원합니다.

- JVM은 또한 자바 프로그램의 보안을 강화하기 위해 사용됩니다. 클래스 로더를 통해 클래스 파일을 검증하고, 보안 관련 규칙을 적용하여 악성 코드 실행을 방지합니다. 이러한 기능들은 자바의 안전성과 신뢰성을 높이는 데 기여합니다.

<br/>
<h2>🤔 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요</h2>

<h3>📝 나의 대답</h3>

- 아닙니다. 올릴 수 있습니다. JetBrain 사에서 만든 Kotiln 언어는 프로그램 실행 시 JVM을 통해 실행하는 것으로 알고 있습니다. 대신 Java언어에 사용되는 컴파일러가 아닌 Kotiln 컴파일러를 사용해 바이트 코드를 생성할 것으로 예상됩니다.

<h3>GPT의 대답</h3>

- Groovy, Scala, Clojure와 같은 언어도 JVM 위에서 실행됩니다. 이들 언어는 각자의 컴파일러를 사용하여 JVM에서 실행되는 바이트 코드를 생성합니다. 이러한 다양한 언어들은 자바 생태계와의 통합성을 갖고 있어, 자바 라이브러리를 사용하거나 기존 자바 코드와 상호 작용할 수 있습니다.

<br/>
<h2>🤔 반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요.</h2>

<h3>GPT의 대답</h3>

- 특정 언어에 따라 컴파일 과정이 자동화되어 사용자가 직접 컴파일할 필요가 없는 경우도 있을 수 있습니다. 예를 들어, Kotlin 언어의 경우 IntelliJ IDEA와 같은 통합 개발 환경에서 소스 코드를 작성하고 컴파일하는 과정이 자동으로 처리되어 사용자가 명시적으로 컴파일하지 않아도 됩니다. 이 경우에도 사실상 컴파일이 이루어져 JVM에서 실행 가능한 바이트 코드가 생성됩니다.

- 따라서, JVM 계열 언어는 보통 JVM에서 실행될 수 있도록 컴파일되며, 해당 언어의 컴파일러를 사용하여 JVM에서 실행 가능한 바이트 코드로 변환됩니다.

<br/>
<h2>🤔 VM을 사용함으로써 얻을 수 있는 장점과 단점에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- VM을 사용해서 얻을 수 있는 가장 큰 장점은 다양한 OS 환경에서도 실행하고자 하는 프로그램을 구동시킬 수 있다는 것입니다. 반면 단점은 VM을 통해 한 번 더 실행되어야 하기 때문에 OS에 종속적인 프로그램보다 리소스가 더 소모됩니다. 

<h3>GPT의 대답</h3>

✓ 장점

- 플랫폼 독립성: VM은 프로그램을 실행하기 위한 중간 계층으로서, 하드웨어와 운영체제(OS) 사이의 추상화를 제공합니다. 이를 통해 같은 프로그램을 다양한 운영체제에서 실행할 수 있으며, 플랫폼 간 이식성을 높여줍니다.

- 안정성과 보안성: VM은 프로그램을 격리된 환경에서 실행하고, 메모리 관리와 가비지 컬렉션 등을 자동으로 처리하여 안정성과 보안성을 향상시킵니다. 이는 프로그램의 예기치 않은 동작과 메모리 오류를 방지하는 데 도움을 줍니다.

✓ 단점

- 성능 저하: VM을 통해 프로그램을 실행하려면 추가적인 계층이 필요하므로 성능 손실이 발생할 수 있습니다. OS에 직접 실행되는 프로그램에 비해 리소스 소모가 더 크고, VM의 오버헤드가 발생할 수 있습니다.

- 의존성: VM을 사용하는 프로그램은 해당 VM이 설치되어 있어야 정상적으로 실행됩니다. 따라서, 사용자가 VM을 설치하고 관리하는 추가적인 작업이 필요할 수 있습니다.

- 제한된 하드웨어 접근: VM은 하드웨어와 직접적인 상호 작용을 제한하는 경우가 있습니다. 특정 하드웨어 기능에 직접 액세스해야 하는 프로그램의 경우 VM 위에서 실행하기 어려울 수 있습니다.

<br/>
<h2>🤔 JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요.</h2>

<h3>📝 나의 대답</h3>

- 아니요 부모-자식 프로세스 관계라고 보기 어렵습니다.

<h3>GPT의 대답</h3>

- JVM은 자바 가상 머신으로, 운영체제에서 실행되는 독립적인 프로세스입니다. JVM 내에서 실행되는 자바 프로그램은 JVM의 관리 하에서 실행되며, 이는 별도의 프로세스로서 동작합니다. 자바 프로그램은 JVM에서 동작하는 단위로 간주되며, 부모 프로세스 - 자식 프로세스 관계를 갖지 않습니다.

- 일반적으로, 부모 프로세스 - 자식 프로세스 관계는 운영체제 수준에서 발생하는 것으로, 부모 프로세스가 자식 프로세스를 생성하고 관리하는 구조입니다. 하지만 JVM 내에서 실행되는 프로그램은 JVM 자체적으로 프로세스 관리를 수행하며, 운영체제의 프로세스 관리와는 별도입니다.

</div>
</details>

<details>
<summary style="font-size:20px">final keyword</summary>
<div markdown="1">
<br/>
<h2>🤔 final 키워드를 사용하면, 어떤 이점이 있나요.</h2>

<h3>📝 나의 대답</h3>

- Java 프로그래밍 안에 존재하는 final keyword를 사용하면 객체의 생성 주기를 맞출 수 있어 JVM이 객체의 Sync를 맞출 때 발생하는 오버헤드를 줄일 수 있습니다. ❌ 틀렸습니다. ❌

<h3>GPT의 대답</h3>

- final 키워드는 변수, 메서드, 클래스에 사용될 수 있으며, 다음과 같은 이점을 가질 수 있습니다

- 변수 : final 변수는 값을 변경할 수 없는 상수로써 사용됩니다. final 변수는 값의 변경을 방지하여 프로그램의 안정성과 예측 가능성을 높입니다.

- 메서드: final 메서드는 상속을 금지하여 메서드의 오버라이딩을 방지합니다. 이를 통해 부모 클래스가 제공한 기능을 변경하지 못하도록 보장하고, 코드의 안정성과 일관성을 유지할 수 있습니다.

- 클래스: final 클래스는 상속을 금지하여 클래스의 확장을 방지합니다. 이는 클래스의 구현을 완전히 제어하고, 부모 클래스의 기능을 변경하지 못하도록 보장합니다. 또한, final 클래스는 상속으로 인한 보안이슈나 예상치 못한 동작을 방지할 수 있습니다.

<br/>
<h2>🤔 컴파일 과정에서, final 키워드는 다르게 취급되나요.</h2>

<h3>📝 나의 대답</h3>

- 네. 다르게 취급됩니다. 예를 들어 변수에 final keyword를 작성했을 때, 컴파일 시점에서 에러가 발생해 값의 변경을 추적할 수 있습니다. 메소드, 클래스 또한 마찬가지로 값 변경 시 컴파일 시점에 발견할 수 있어 런타임 시 발견되는 에러를 찾을 때보다 리소스가 적게 듭니다.

<h3>GPT의 대답</h3>

- final 키워드는 컴파일 시점에서 값 변경 또는 오버라이딩에 대한 오류를 발견할 수 있어, 런타임 시 발견되는 에러를 사전에 예방하고 리소스를 절약할 수 있습니다. 따라서, final 키워드는 컴파일 과정에서 다르게 취급되어 에러를 컴파일 시점에서 발견할 수 있다는 장점을 가지고 있습니다.
</div>
</details>

<details>
<summary style="font-size:20px">인터페이스와 추상 클래스</summary>
<div markdown="1">
<br/>
<h2>🤔 인터페이스와 추상 클래스의 차이에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 인터페이스는 프로그램 안에서 명세를 정의할 때 사용됩니다. implements한 클래스는 명세에 적힌 내용을 반드시 구현해야 합니다. 반면 추상 클래스는 명세가 아닌 행위를 정의합니다. 상속하는 클래스에선 행위를 재정의할 필요는 없습니다.

<h3>GPT의 대답</h3>

✓ 목적: 인터페이스는 클래스가 가져야 할 기능(메서드)의 명세를 정의하는데 사용됩니다. 인터페이스는 클래스가 특정 메서드를 반드시 구현하도록 강제하며, 다중 상속과 유사한 기능을 제공합니다. 반면, 추상 클래스는 클래스의 행위(behavior)를 정의하며, 구체적인 구현이 필요한 메서드와 추상 메서드를 함께 가질 수 있습니다.

✓ 구현 강제성: 클래스가 인터페이스를 implements(구현)하면, 해당 인터페이스의 모든 메서드를 구현해야 합니다. 인터페이스는 클래스에 특정한 동작을 제공하고, 이를 강제하기 위해 사용됩니다. 추상 클래스는 추상 메서드를 포함할 수 있으며, 이러한 추상 메서드는 하위 클래스에서 반드시 구현되어야 합니다. 하지만 추상 클래스는 구체적인 구현이 필요한 메서드를 가질 수 있으며, 하위 클래스에서 재정의할 필요는 없습니다.

✓ 다중 상속: 인터페이스는 다중 상속을 지원합니다. 클래스가 여러 개의 인터페이스를 구현할 수 있으며, 이를 통해 다양한 기능을 동시에 제공할 수 있습니다. 반면, 추상 클래스는 단일 상속만을 지원하며, 하나의 추상 클래스만 상속받을 수 있습니다.

✓ 인스턴스화: 인터페이스는 인스턴스화될 수 없습니다. 인터페이스는 단지 메서드의 명세를 제공하는 역할을 하며, 구체적인 객체를 생성할 수 없습니다. 추상 클래스는 인스턴스화될 수 있지만, 추상 클래스 내에 추상 메서드가 포함되어 있다면 해당 클래스는 추상 클래스로 선언되어야 합니다.

<br/>
<h2>🤔 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요.</h2>

<h3>📝 나의 대답</h3>

- Java 진영에선 클래스의 상속은 하나 인터페이스 상속은 다중으로 받을 수 있습니다. 이는 복잡성을 제한하기 위함이라고 생각합니다. 인터페이스를 사용한다면 인터페이스 안에 정의된 메소드를 구현해야합니다. 하지만 클래스 상속은 구현을 강제하지 않기 때문에 모호해질 가능성이 존재합니다. 다중 상속으로 몇 뎁스만 내려가도 이 모호함 때문에 코드의 복잡성은 증가할 것입니다.

</div>
</details>

<details>
<summary style="font-size:20px">리플렉션</summary>
<div markdown="1">
<br/>
<h2>🤔 리플렉션에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 리플렉션이란 private으로 keyword로 선언된 메소드, 변수에 접근할 수 있는 기법입니다.

<h3>GPT의 대답</h3>

- 리플렉션(Reflection)은 프로그램이 자기 자신을 검사하고, 클래스의 정보를 동적으로 분석하고 조작할 수 있는 기능을 의미합니다. 리플렉션은 Java의 리플렉션 API를 통해 제공되며, 클래스, 메서드, 필드 등의 정보를 조사하고 호출하며, 인스턴스를 생성하고, 접근 제어자에 관계없이 멤버에 접근할 수 있는 기능을 제공합니다.

<br/>
<h2>🤔 의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요.</h2>

<h3>📝 나의 대답</h3>

- 네. 리플렉션을 잘 이해하지 못하고 무분별하게 사용한다면 코드 스멜을 유발할 것입니다. 이유는 리플렉션은 프로그램 실행 시 동적으로 동작하기 때문입니다. 해결 방법으로는 리플렉션 사용을 하지 않고 동적. 즉, 런타임 때 실행하는 로직은 컴파일 레벨로 내려 구성하는 것이 좋습니다.

<br/>
<h2>🤔 그렇다면 리플렉션을 언제 활용할 수 있을까요.</h2>

<h3>GPT의 대답</h3>

✅ 외부 라이브러리나 프레임워크와의 상호작용: 외부 라이브러리나 프레임워크가 제공하는 클래스나 인터페이스를 사용해야 하는데, 컴파일 시점에는 그 클래스의 정보를 알 수 없는 경우에 리플렉션을 사용할 수 있습니다. 이를 통해 런타임에 외부 라이브러리나 프레임워크와 상호작용할 수 있습니다.

✅ 동적으로 객체의 메서드나 필드에 접근해야 할 때: 프로그램이 실행 중에 특정 객체의 메서드나 필드에 접근해야 하는 경우에 리플렉션을 사용할 수 있습니다. 예를 들어, 객체의 private 메서드에 접근하여 테스트 코드를 작성하거나, 동적으로 필드 값을 변경해야 하는 경우에 리플렉션을 활용할 수 있습니다.

✅ 애노테이션 처리: 리플렉션은 애노테이션(annotation) 정보를 동적으로 분석하고 처리하는 데에도 활용될 수 있습니다. 프로그램이 실행 중에 애노테이션 정보를 검사하거나, 애노테이션을 가진 클래스나 메서드를 동적으로 처리해야 하는 경우에 리플렉션을 사용할 수 있습니다.

</div>
</details>

<details>
<summary style="font-size:20px">static keyword</summary>
<div markdown="1">
<br/>
<h2>🤔 static class와 static method를 비교해 주세요.</h2>

<h3>📝 나의 대답</h3>

- static keyword를 사용하면 JVM method 영역에 생성되며 클래스 로더가 바이트 코드를 해석 시 생성됩니다. static class를 사용하게 되면 같은 이름으로 생성할 수 없고 프로그램 내 하나 뿐 존재하지 않습니다. static method를 사용 시엔 인스턴스 생성 없이 바로 호출해 사용할 수 있습니다. 

<h3>GPT의 대답</h3>

- static keyword: static 키워드는 클래스 레벨에서 사용되는 키워드로, 해당 멤버를 클래스 수준으로 선언하고 인스턴스 생성 없이 클래스 이름을 통해 직접 접근할 수 있도록 합니다. static 멤버는 클래스의 모든 인스턴스에 공유되며, 클래스 로딩 시에 메모리에 할당됩니다.

- static class (정적 중첩 클래스): Java에서는 중첩 클래스를 정의할 수 있습니다. 그 중에는 정적 중첩 클래스(static nested class)라는 개념이 있습니다. 정적 중첩 클래스는 외부 클래스의 인스턴스와 독립적으로 존재하며, 외부 클래스의 인스턴스와 연결되지 않습니다. 정적 중첩 클래스는 외부 클래스의 내부에 선언되고, 정적 멤버나 인스턴스 멤버 모두 접근할 수 있습니다.

- static method (정적 메서드): 정적 메서드는 클래스 수준에서 선언되며, 인스턴스 생성 없이 클래스 이름을 통해 직접 호출할 수 있는 메서드입니다. 정적 메서드는 해당 클래스의 인스턴스와 독립적으로 동작하며, 정적 변수나 다른 정적 메서드에 접근할 수 있습니다. 정적 메서드는 인스턴스 변수나 인스턴스 메서드에 접근할 수 없으며, this 키워드를 사용할 수 없습니다.

<br/>
<h2>🤔 static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요.</h2>

<h3>📝 나의 대답</h3>

- static method를 사용하면 인스턴스 생성 없이 method를 사용할 수 있는 장점이 있습니다. 그러나 무분별하게 사용하면 method 영역의 공간이 부족에 오버 플로의 위험이 존재합니다. static nested class를 사용한다면 캡슐화되어 있어 뎁스가 늘어날 수 있습니다.

<h3>GPT의 대답</h3>

- 제약사항: static 멤버는 클래스 수준으로 선언되므로, 해당 클래스의 인스턴스와 독립적으로 동작합니다. 이로 인해 인스턴스 멤버에 직접 접근할 수 없습니다. 또한, 정적 멤버는 공유되기 때문에 멀티스레드 환경에서 동기화를 고려해야 할 수도 있습니다. 또한, 너무 많은 static 멤버를 사용하면 메모리 사용량이 증가할 수 있으며, 과도한 정적 메모리 사용은 성능 저하나 오버플로우의 위험성을 가질 수 있습니다.

<br/>
<h2>🤔 컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- static keyword가 붙어 있다면 method 영역에 관련 정보를 생성합니다.

<h3>GPT의 대답</h3>

✅ 정적 변수(static variable)

- static 키워드가 변수 선언 앞에 사용되면, 해당 변수는 정적 변수(static variable)가 됩니다. 정적 변수는 클래스 수준에서 선언되며, 프로그램 실행 시 메모리의 데이터 영역에 할당됩니다. 정적 변수는 프로그램 실행 동안 계속해서 유지되며, 클래스의 모든 인스턴스가 공유하는 변수입니다. 컴파일 과정에서는 **정적 변수의 메모리 할당과 초기화가 처리됩니다.**

✅ 정적 메서드(static method)

- static 키워드가 메서드 선언 앞에 사용되면, 해당 메서드는 정적 메서드(static method)가 됩니다. 정적 메서드는 인스턴스 생성 없이 클래스 이름을 통해 직접 호출할 수 있는 메서드입니다. 정적 메서드는 해당 클래스와 관련된 동작을 수행하거나, 유틸리티 메서드를 구현하는 데 사용됩니다. **컴파일 과정에서는 정적 메서드의 바이트 코드가 생성됩니다.**
</div>
</details>