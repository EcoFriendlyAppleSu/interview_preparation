<details>
<summary style="font-size:20px">쿠키와 세션</summary>
<div markdown="1">
<br/>
<h2>🤔 쿠키와 세션의 차이에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 쿠키는 Http Stateless의 단점을 보완하기 위해 Client의 정보를 담고 있는 웹 저장소입니다. 세션은 Client에게 서버에서 발급되는 정보이며 이를 통해 Client는 서버의 다양한 리소스에 접근할 수 있습니다.

- 쿠키와 세션의 차이는 관리되는 공간에 차이가 존재합니다. Client에서 쿠키를 관리하며 세션은 서버에서 관리합니다.

<h3>GPT의 대답</h3>

- 쿠키와 세션 모두 사용자의 상태 정보를 저장하는 방법입니다. 하지만 그들이 데이터를 저장하고 사용하는 방식과 보안성에 차이가 있습니다. 쿠키는 클라이언트 측에서 데이터를 저장하며, 세션은 서버 측에서 데이터를 저장합니다.

- 쿠키는 사용자가 사이트에 방문할 때마다 보내지는 작은 데이터 조각입니다. 클라이언트는 이 세션 ID를 가지고 서버에 요청을 할 때마다 전달함으로써, 서버는 클라이언트를 식별할 수 있습니다. 보안은 서버에서 관리가되는 세션이 쿠키보다 좋습니다.

<br/>
<h2>🤔 세션 방식의 로그인 과정에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 먼저 가입된 클라이언트에 관한 정보가 서버에 존재해야 합니다. 로그인을 진행할 때, 세션이 생성되며 해당 세션에 관한 정보를 저장합니다. 이 후 요청에 대한 응답이 진행될 때, 쿠키 세션에 정보를 집어 넣어 Client에게 전달합니다.

<h3>GPT의 대답</h3>

- 세션 방식의 로그인 과정은 다음과 같습니다. 먼저, 사용자가 자신의 인증 정보 (예: 사용자 이름 및 암호)를 사용하여 로그인을 시도합니다. 서버는 이 정보를 받아 인증을 진행하고, **성공적인 경우 세션을 생성합니다.** 이 세션은 고유한 세션 ID를 포함하고, 이 ID는 서버가 사용자를 추적하고 사용자의 로그인 상태를 유지하는 데 사용됩니다.

- 생성된 세션 ID는 클라이언트에게 응답으로 전송되며, 이는 클라이언트 측의 쿠키에 저장됩니다. 그 후, 클라이언트는 이 세션 ID를 포함하여 서버에 요청을 보낼 때마다 이 쿠키를 함께 전송합니다. 서버는 이 세션 ID를 통해 사용자를 인식하고, 이에 대응하는 사용자 세션을 찾아 사용자의 로그인 상태를 유지합니다.

- 따라서 사용자가 로그아웃하거나 세션이 만료되면, 해당 세션 ID는 무효화되며, 사용자는 다시 로그인해야 합니다.

<br/>
<h2>🤔 HTTP의 특성인 Stateless에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- HTTP의 Stateless는 상태를 갖고 있지 않은 것을 의미하며 Stateful에 비해 흐름을 기억할 필요가 없어 리소스가 적게 듭니다. 하지만, 매 요청에서 상태값을 기억하지 못하기 때문에 쿠키의 도움을 받아 값을 저장하고 매 요청마다 서버에 함께 쿠키를 전달해 Stateless의 단점을 보완합니다.

<h3>GPT의 대답</h3>

- HTTP의 Stateless 특성은 서버가 클라이언트의 상태 정보를 저장하지 않는 것을 의미합니다. 즉, 각 요청이 독립적이며, 서버는 이전의 요청에 대한 정보를 기억하지 않습니다. 이는 성능 향상을 가져오며, 많은 수의 동시 연결을 처리할 수 있게 합니다.

<br/>
<h2>🤔 Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?</h2>

<h3>📝 나의 대답</h3>

- 아닙니다. 세션이 필요할 때가 존재합니다. Client의 상태를 추적하기 위해 그리고 Client의 잘못된 접근으로 Client를 제한하기 위해선 세션이 필요합니다.

<br/>
<h2>🤔 규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?</h2>

<h3>📝 나의 대답</h3>

- 여러 대의 서버에 요청이 가기 전 Entry Point에 세션 처리를 담당하는 서버를 하나 생성해 Client의 요청을 처리하는 것으로 세션을 관리할 수 있습니다.

<h3>GPT의 대답</h3>

- 규모가 커져 서버가 여러 개가 되었을 때 세션을 관리하는 방법은 여러 가지가 있습니다. 일반적으로 사용되는 방법 중 하나는 **세션 클러스터링**입니다. 이 방법은 여러 서버가 동일한 세션 정보를 공유할 수 있도록 합니다. 이를 통해, 한 서버에서 생성된 세션을 다른 서버에서도 사용할 수 있게 됩니다.

또 다른 방법은 **세션 정보를 중앙 데이터베이스 또는 캐시에 저장**하는 것입니다. 이 방법은 모든 서버가 동일한 저장소를 조회하므로 어느 서버로 요청이 들어오더라도 일관된 세션 정보를 제공할 수 있습니다.
</div>
</details>

<details>
<summary style="font-size:20px">HTTP 응답코드</summary>
<div markdown="1">
<br/>
<h2>🤔 HTTP 응답코드에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- HTTP 응답 코드는 200, 300, 400, 500 번대가 존재하며 200번대는 서버에 요청이 성공을 300번대는 리다이렉션, 400번대는 Client의 요청에 오류가 있을 경우, 500 번대는 서버 내부에서 요청을 처리하지 못한 경우 사용됩니다.

<br/>
<h2>🤔 401 (Unauthorized) 와 403 (Forbidden)은 의미적으로 어떤 차이가 있나요?</h2>

<h3>📝 나의 대답</h3>

- 401은 인가가 허락되지 않은 요청에 대한 상태코드이고 403은 인가와 상관 없이 금지된 서버 자원에 접근할 때 사용되는 상태코드입니다.

<h3>GPT의 대답</h3>

- 401 Unauthorized는 클라이언트가 자신을 인증하지 않았거나 인증이 실패한 경우에 반환되는 상태 코드입니다.

- 403 Forbidden은 서버가 클라이언트의 요청을 이해하고, 클라이언트의 신원도 알고 있지만, 해당 요청을 수행하는 것을 거부하는 상태 코드입니다.

- 401은 "인증되지 않음"을 의미하며, 403은 "접근이 거부됨"을 의미

<br/>
<h2>🤔 200 (ok) 와 201 (created) 의 차이에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 200 응답코드는 Client의 요청이 옳바르게 처리 됐음을 의미하고 201은 요청에의해 서버에 데이터가 추가됐다는 의미입니다.

<h3>GPT의 대답</h3>

- 201 Created 응답은 일반적으로 생성된 리소스의 위치를 가리키는 'Location' 헤더와 함께 제공됩니다.
</div>
</details>

<details>
<summary style="font-size:20px">HTTP Method</summary>
<div markdown="1">
<br/>
<h2>🤔 HTTP Method 에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- HTTP Method는 Client HTTP 요청 Header에 명시되며 전달되는 리소스의 행위를 지정할 수 있습니다.

- GET은 조회를, POST는 리소스 생성, PUT은 Update, Delete는 삭제를 서버에게 전달합니다.

<h3>GPT의 대답</h3>

- HTTP 메소드는 클라이언트가 웹 서버에 요청하는 작업의 종류를 나타냅니다.

- PUT: 존재하는 리소스를 새 데이터로 완전히 대체합니다. 이는 리소스의 전체 업데이트에 사용됩니다.

- PATCH: 존재하는 리소스의 일부를 수정합니다. 이는 리소스의 부분적인 업데이트에 사용됩니다.

<br/>
<h2>🤔 HTTP Method의 멱등성에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- HTTP 멱등성이란 HTTP Method 요청이 진행된다 하더라도 도출되는 값은 항상 같아야 한다는 것을 의미합니다. 멱등성을 지킴으로써 프로세스의 신뢰도를 높일 수 있습니다. ❌ 틀렸습니다. ❌

<h3>GPT의 대답</h3>

- HTTP 메소드의 멱등성(idempotency)이란 동일한 요청을 한 번 또는 여러 번 수행하더라도 서버에 똑같은 효과를 가져야 함을 의미합니다. 이것은 네트워크의 불안정성 등의 이유로 같은 요청이 여러 번 수행되는 경우에도 안전하게 시스템을 운영할 수 있도록 합니다. POST 요청은 멱등성을 갖지 않습니다.

<br/>
<h2>🤔 GET과 POST의 차이는 무엇인가요?</h2>

<h3>📝 나의 대답</h3>

- GET은 서버에게 자원을 요청하는 것이고 POST는 서버에게 자원 생성을 요청하는 것입니다.

<h3>GPT의 대답</h3>

- GET은 일반적으로 정보를 요청하는 데 사용됩니다. GET 요청은 웹 브라우저의 주소 표시 줄에 표시되며, 전송되는 모든 정보는 URL의 일부로 인코딩됩니다. GET은 멱등성을 가집니다, 즉 요청을 여러 번 수행해도 동일한 결과를 가져옵니다.

- POST는 서버에 새로운 데이터를 전송하거나 기존 데이터를 변경하는 데 사용됩니다. POST 요청은 HTTP 요청 본문에 데이터를 포함하여 보냅니다. 이는 데이터를 URL에 직접 포함시키지 않으므로, GET보다 더 많은 데이터를 보낼 수 있습니다. 또한, POST는 멱등성이 없으므로 동일한 요청을 여러 번 보내면 서버의 상태가 여러 번 변경될 수 있습니다."

<br/>
<h2>🤔 POST와 PUT, PATCH의 차이는 무엇인가요?</h2>

<h3>📝 나의 대답</h3>

- POST, PUT, PATCH 모두 HTTP Body에 데이터를 갖고 있습니다. POST는 자원을 생성하는 것이고 멱등성을 보장하지 않습니다. PUT은 전체 데이터를 수정하고 PATCH는 부분 데이터를 수정합니다. PUT과 PATCH는 멱등성을 갖습니다.


<br/>
<h2>🤔 HTTP 1.1 이후로, GET에도 Body에 데이터를 실을 수 있게 되었습니다. 그럼에도 불구하고 왜 아직도 이런 방식을 지양하는 것일까요?</h2>

<h3>📝 나의 대답</h3>

- 이전의 코드들에서 요청을 처리할 때 예전의 GET Method 방식을 택하고 있어 요청을 처리하지 못할 수 있기 때문입니다.

<h3>GPT의 대답</h3>

✅ 호환성 문제 : 많은 중간 프록시 및 서버가 HTTP/1.0 기준으로 구현되어 있으며, 이러한 구현체들은 GET 요청의 본문을 무시하거나 오류를 일으킬 수 있습니다.

✅ 의미론적 부적합성 : HTTP 메서드의 의미론(semantics)에 따라, GET은 서버로부터 정보를 조회하는 데 사용되는 것으로 정의되어 있습니다. 본문 데이터를 통해 서버에 추가 정보를 제공하는 것은 POST 또는 PUT, PATCH와 같은 다른 HTTP 메서드의 역할입니다.

✅ 캐싱 및 재시도(Retry) : GET 요청은 본문 데이터 없이 URL만으로 요청을 식별하므로, 캐싱이 가능하고, 요청이 실패한 경우 재시도할 수 있습니다. 본문 데이터를 포함하면 이러한 장점이 무력화될 수 있습니다.
</div>
</details>

<details>
<summary style="font-size:20px">HTTP</summary>
<div markdown="1">
<br/>
<h2>🤔 HTTP에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- HTTP는 WEB에서 HTML을 전달하기 위한 프로토콜이며 Header Body를 갖고 있습니다. HTTP는 Web의 Stateless 특성을 갖고 있어 서버의 정보를 Client가 갖고 있지 않습니다.

- HTTP는 연결을 맺을 때, TCP/IP Threehand Shake를 통해 검증을 거쳐 연결을 맺으며 현재 사용되는 많은 수의 HTTP는 단 건으로 요청에 대한 응답을 처리하는 것이 아닌 연결 파이프라인을 구축해 연결 리소스를 줄입니다.

<h3>GPT의 대답</h3>

- HTTP(Hypertext Transfer Protocol)는 클라이언트와 서버 간에 웹 기반 데이터를 주고받는 데 사용되는 프로토콜입니다. HTTP는 Stateless 프로토콜로, 각 요청이 독립적이며 이전 요청의 상태를 기억하지 않습니다.

- HTTP 메시지는 요청과 응답으로 나뉘며, 각각은 **헤더와 본문(Body)으로 구성됩니다. 헤더에는 메타데이터가 포함되며, 본문에는 실제 데이터가 포함**됩니다.

- HTTP 메소드는 클라이언트가 수행하려는 동작을 서버에게 알려줍니다. 이에는 GET, POST, PUT, DELETE 등이 있습니다.

- HTTP 상태 코드는 서버가 클라이언트에게 요청 처리 결과를 알려줍니다. 예를 들어 200은 성공을, 404는 Not Found를, 500은 Internal Server Error를 나타냅니다.

- HTTP/1.1에서는 **Keep-Alive 및 파이프라인 기능을 통해 연결을 재사용**하고, 여러 요청을 동시에 처리할 수 있게 되었습니다. HTTP/2.0에서는 이를 더욱 개선하여 멀티플렉싱과 서버 푸시 등의 기능을 추가하였습니다. 이러한 변화를 통해, 웹 성능이 크게 향상되었습니다.

<br/>
<h2>🤔 공개키와 대칭키에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 공개키와 대칭키 모두 암호화를 위해 사용되는 기법입니다. 공개키는 

<h3>GPT의 대답</h3>

- 
</div>
왜 HTTPS Handshake 과정에서는 인증서를 사용하는 것 일까요?
SSL과 TLS의 차이는 무엇인가요?
</details>