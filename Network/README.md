<details>
<summary style="font-size:20px">쿠키와 세션</summary>
<div markdown="1">
<br/>
<h2>🤔 쿠키와 세션의 차이에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 쿠키는 Http Stateless의 단점을 보완하기 위해 Client의 정보를 담고 있는 웹 저장소입니다. 세션은 Client에게 서버에서 발급되는 정보이며 이를 통해 Client는 서버의 다양한 리소스에 접근할 수 있습니다.

- 쿠키와 세션의 차이는 관리되는 공간에 차이가 존재합니다. Client에서 쿠키를 관리하며 세션은 서버에서 관리합니다.

<h3>GPT의 대답</h3>

- 쿠키와 세션 모두 사용자의 상태 정보를 저장하는 방법입니다. 하지만 그들이 데이터를 저장하고 사용하는 방식과 보안성에 차이가 있습니다. 쿠키는 클라이언트 측에서 데이터를 저장하며, 세션은 서버 측에서 데이터를 저장합니다.

- 쿠키는 사용자가 사이트에 방문할 때마다 보내지는 작은 데이터 조각입니다. 클라이언트는 이 세션 ID를 가지고 서버에 요청을 할 때마다 전달함으로써, 서버는 클라이언트를 식별할 수 있습니다. 보안은 서버에서 관리가되는 세션이 쿠키보다 좋습니다.

<br/>
<h2>🤔 세션 방식의 로그인 과정에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 먼저 가입된 클라이언트에 관한 정보가 서버에 존재해야 합니다. 로그인을 진행할 때, 세션이 생성되며 해당 세션에 관한 정보를 저장합니다. 이 후 요청에 대한 응답이 진행될 때, 쿠키 세션에 정보를 집어 넣어 Client에게 전달합니다.

<h3>GPT의 대답</h3>

- 세션 방식의 로그인 과정은 다음과 같습니다. 먼저, 사용자가 자신의 인증 정보 (예: 사용자 이름 및 암호)를 사용하여 로그인을 시도합니다. 서버는 이 정보를 받아 인증을 진행하고, **성공적인 경우 세션을 생성합니다.** 이 세션은 고유한 세션 ID를 포함하고, 이 ID는 서버가 사용자를 추적하고 사용자의 로그인 상태를 유지하는 데 사용됩니다.

- 생성된 세션 ID는 클라이언트에게 응답으로 전송되며, 이는 클라이언트 측의 쿠키에 저장됩니다. 그 후, 클라이언트는 이 세션 ID를 포함하여 서버에 요청을 보낼 때마다 이 쿠키를 함께 전송합니다. 서버는 이 세션 ID를 통해 사용자를 인식하고, 이에 대응하는 사용자 세션을 찾아 사용자의 로그인 상태를 유지합니다.

- 따라서 사용자가 로그아웃하거나 세션이 만료되면, 해당 세션 ID는 무효화되며, 사용자는 다시 로그인해야 합니다.

<br/>
<h2>🤔 HTTP의 특성인 Stateless에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- HTTP의 Stateless는 상태를 갖고 있지 않은 것을 의미하며 Stateful에 비해 흐름을 기억할 필요가 없어 리소스가 적게 듭니다. 하지만, 매 요청에서 상태값을 기억하지 못하기 때문에 쿠키의 도움을 받아 값을 저장하고 매 요청마다 서버에 함께 쿠키를 전달해 Stateless의 단점을 보완합니다.

<h3>GPT의 대답</h3>

- HTTP의 Stateless 특성은 서버가 클라이언트의 상태 정보를 저장하지 않는 것을 의미합니다. 즉, 각 요청이 독립적이며, 서버는 이전의 요청에 대한 정보를 기억하지 않습니다. 이는 성능 향상을 가져오며, 많은 수의 동시 연결을 처리할 수 있게 합니다.

<br/>
<h2>🤔 Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?</h2>

<h3>📝 나의 대답</h3>

- 아닙니다. 세션이 필요할 때가 존재합니다. Client의 상태를 추적하기 위해 그리고 Client의 잘못된 접근으로 Client를 제한하기 위해선 세션이 필요합니다.

<br/>
<h2>🤔 규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?</h2>

<h3>📝 나의 대답</h3>

- 여러 대의 서버에 요청이 가기 전 Entry Point에 세션 처리를 담당하는 서버를 하나 생성해 Client의 요청을 처리하는 것으로 세션을 관리할 수 있습니다.

<h3>GPT의 대답</h3>

- 규모가 커져 서버가 여러 개가 되었을 때 세션을 관리하는 방법은 여러 가지가 있습니다. 일반적으로 사용되는 방법 중 하나는 **세션 클러스터링**입니다. 이 방법은 여러 서버가 동일한 세션 정보를 공유할 수 있도록 합니다. 이를 통해, 한 서버에서 생성된 세션을 다른 서버에서도 사용할 수 있게 됩니다.

또 다른 방법은 **세션 정보를 중앙 데이터베이스 또는 캐시에 저장**하는 것입니다. 이 방법은 모든 서버가 동일한 저장소를 조회하므로 어느 서버로 요청이 들어오더라도 일관된 세션 정보를 제공할 수 있습니다.
</div>
</details>

<details>
<summary style="font-size:20px">HTTP 응답코드</summary>
<div markdown="1">
<br/>
<h2>🤔 HTTP 응답코드에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- HTTP 응답 코드는 200, 300, 400, 500 번대가 존재하며 200번대는 서버에 요청이 성공을 300번대는 리다이렉션, 400번대는 Client의 요청에 오류가 있을 경우, 500 번대는 서버 내부에서 요청을 처리하지 못한 경우 사용됩니다.

<br/>
<h2>🤔 401 (Unauthorized) 와 403 (Forbidden)은 의미적으로 어떤 차이가 있나요?</h2>

<h3>📝 나의 대답</h3>

- 401은 인가가 허락되지 않은 요청에 대한 상태코드이고 403은 인가와 상관 없이 금지된 서버 자원에 접근할 때 사용되는 상태코드입니다.

<h3>GPT의 대답</h3>

- 401 Unauthorized는 클라이언트가 자신을 인증하지 않았거나 인증이 실패한 경우에 반환되는 상태 코드입니다.

- 403 Forbidden은 서버가 클라이언트의 요청을 이해하고, 클라이언트의 신원도 알고 있지만, 해당 요청을 수행하는 것을 거부하는 상태 코드입니다.

- 401은 "인증되지 않음"을 의미하며, 403은 "접근이 거부됨"을 의미

<br/>
<h2>🤔 200 (ok) 와 201 (created) 의 차이에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 200 응답코드는 Client의 요청이 옳바르게 처리 됐음을 의미하고 201은 요청에의해 서버에 데이터가 추가됐다는 의미입니다.

<h3>GPT의 대답</h3>

- 201 Created 응답은 일반적으로 생성된 리소스의 위치를 가리키는 'Location' 헤더와 함께 제공됩니다.
</div>
</details>

<details>
<summary style="font-size:20px">HTTP Method</summary>
<div markdown="1">
<br/>
<h2>🤔 HTTP Method 에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- HTTP Method는 Client HTTP 요청 Header에 명시되며 전달되는 리소스의 행위를 지정할 수 있습니다.

- GET은 조회를, POST는 리소스 생성, PUT은 Update, Delete는 삭제를 서버에게 전달합니다.

<h3>GPT의 대답</h3>

- HTTP 메소드는 클라이언트가 웹 서버에 요청하는 작업의 종류를 나타냅니다.

- PUT: 존재하는 리소스를 새 데이터로 완전히 대체합니다. 이는 리소스의 전체 업데이트에 사용됩니다.

- PATCH: 존재하는 리소스의 일부를 수정합니다. 이는 리소스의 부분적인 업데이트에 사용됩니다.

<br/>
<h2>🤔 HTTP Method의 멱등성에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- HTTP 멱등성이란 HTTP Method 요청이 진행된다 하더라도 도출되는 값은 항상 같아야 한다는 것을 의미합니다. 멱등성을 지킴으로써 프로세스의 신뢰도를 높일 수 있습니다. ❌ 틀렸습니다. ❌

<h3>GPT의 대답</h3>

- HTTP 메소드의 멱등성(idempotency)이란 동일한 요청을 한 번 또는 여러 번 수행하더라도 서버에 똑같은 효과를 가져야 함을 의미합니다. 이것은 네트워크의 불안정성 등의 이유로 같은 요청이 여러 번 수행되는 경우에도 안전하게 시스템을 운영할 수 있도록 합니다. POST 요청은 멱등성을 갖지 않습니다.

<br/>
<h2>🤔 GET과 POST의 차이는 무엇인가요?</h2>

<h3>📝 나의 대답</h3>

- GET은 서버에게 자원을 요청하는 것이고 POST는 서버에게 자원 생성을 요청하는 것입니다.

<h3>GPT의 대답</h3>

- GET은 일반적으로 정보를 요청하는 데 사용됩니다. GET 요청은 웹 브라우저의 주소 표시 줄에 표시되며, 전송되는 모든 정보는 URL의 일부로 인코딩됩니다. GET은 멱등성을 가집니다, 즉 요청을 여러 번 수행해도 동일한 결과를 가져옵니다.

- POST는 서버에 새로운 데이터를 전송하거나 기존 데이터를 변경하는 데 사용됩니다. POST 요청은 HTTP 요청 본문에 데이터를 포함하여 보냅니다. 이는 데이터를 URL에 직접 포함시키지 않으므로, GET보다 더 많은 데이터를 보낼 수 있습니다. 또한, POST는 멱등성이 없으므로 동일한 요청을 여러 번 보내면 서버의 상태가 여러 번 변경될 수 있습니다."

<br/>
<h2>🤔 POST와 PUT, PATCH의 차이는 무엇인가요?</h2>

<h3>📝 나의 대답</h3>

- POST, PUT, PATCH 모두 HTTP Body에 데이터를 갖고 있습니다. POST는 자원을 생성하는 것이고 멱등성을 보장하지 않습니다. PUT은 전체 데이터를 수정하고 PATCH는 부분 데이터를 수정합니다. PUT과 PATCH는 멱등성을 갖습니다.


<br/>
<h2>🤔 HTTP 1.1 이후로, GET에도 Body에 데이터를 실을 수 있게 되었습니다. 그럼에도 불구하고 왜 아직도 이런 방식을 지양하는 것일까요?</h2>

<h3>📝 나의 대답</h3>

- 이전의 코드들에서 요청을 처리할 때 예전의 GET Method 방식을 택하고 있어 요청을 처리하지 못할 수 있기 때문입니다.

<h3>GPT의 대답</h3>

✅ 호환성 문제 : 많은 중간 프록시 및 서버가 HTTP/1.0 기준으로 구현되어 있으며, 이러한 구현체들은 GET 요청의 본문을 무시하거나 오류를 일으킬 수 있습니다.

✅ 의미론적 부적합성 : HTTP 메서드의 의미론(semantics)에 따라, GET은 서버로부터 정보를 조회하는 데 사용되는 것으로 정의되어 있습니다. 본문 데이터를 통해 서버에 추가 정보를 제공하는 것은 POST 또는 PUT, PATCH와 같은 다른 HTTP 메서드의 역할입니다.

✅ 캐싱 및 재시도(Retry) : GET 요청은 본문 데이터 없이 URL만으로 요청을 식별하므로, 캐싱이 가능하고, 요청이 실패한 경우 재시도할 수 있습니다. 본문 데이터를 포함하면 이러한 장점이 무력화될 수 있습니다.
</div>
</details>

<details>
<summary style="font-size:20px">HTTP</summary>
<div markdown="1">
<br/>
<h2>🤔 HTTP에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- HTTP는 WEB에서 HTML을 전달하기 위한 프로토콜이며 Header Body를 갖고 있습니다. HTTP는 Web의 Stateless 특성을 갖고 있어 서버의 정보를 Client가 갖고 있지 않습니다.

- HTTP는 연결을 맺을 때, TCP/IP Threehand Shake를 통해 검증을 거쳐 연결을 맺으며 현재 사용되는 많은 수의 HTTP는 단 건으로 요청에 대한 응답을 처리하는 것이 아닌 연결 파이프라인을 구축해 연결 리소스를 줄입니다.

<h3>GPT의 대답</h3>

- HTTP(Hypertext Transfer Protocol)는 클라이언트와 서버 간에 웹 기반 데이터를 주고받는 데 사용되는 프로토콜입니다. HTTP는 Stateless 프로토콜로, 각 요청이 독립적이며 이전 요청의 상태를 기억하지 않습니다.

- HTTP 메시지는 요청과 응답으로 나뉘며, 각각은 **헤더와 본문(Body)으로 구성됩니다. 헤더에는 메타데이터가 포함되며, 본문에는 실제 데이터가 포함**됩니다.

- HTTP 메소드는 클라이언트가 수행하려는 동작을 서버에게 알려줍니다. 이에는 GET, POST, PUT, DELETE 등이 있습니다.

- HTTP 상태 코드는 서버가 클라이언트에게 요청 처리 결과를 알려줍니다. 예를 들어 200은 성공을, 404는 Not Found를, 500은 Internal Server Error를 나타냅니다.

- HTTP/1.1에서는 **Keep-Alive 및 파이프라인 기능을 통해 연결을 재사용**하고, 여러 요청을 동시에 처리할 수 있게 되었습니다. HTTP/2.0에서는 이를 더욱 개선하여 멀티플렉싱과 서버 푸시 등의 기능을 추가하였습니다. 이러한 변화를 통해, 웹 성능이 크게 향상되었습니다.

<br/>
<h2>🤔 공개키와 대칭키에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 공개키와 대칭키 모두 암호화를 위해 사용되는 기법입니다. 대칭키는 보내는 클라이언트 쪽과 서버 쪽에서 동일한 암호화 키를 갖고 암호화, 복호화를 하는 것을 의미합니다. 이를 통해 암호화를 진행할 때, 초기 암호화 테이블을 보낼 시 네트워크 상에서 탈취당할 수 있습니다.

- 공개키(비공개키)는 클라이언트와 서버의 키가 다르며 CA에서 인증된 키를 사용자에게 발급하고 서버가 갖고 있는 개인키는 외부에 노출시키지 않는 것을 의미합니다.

<h3>GPT의 대답</h3>

- 대칭키 암호화는 동일한 키를 이용해 암호화와 복호화를 진행하는 방식입니다. 이 방식의 장점은 처리 속도가 빠르다는 것이며, 단점은 키의 배포와 관리가 어렵다는 점입니다. 왜냐하면 키를 안전하게 공유해야 하는데, 이는 간단하지 않기 때문입니다.

- 공개키(비대칭키) 암호화는 두 개의 키(공개키와 개인키)를 사용하는 방식입니다. 공개키로 암호화된 데이터는 오직 매칭되는 개인키를 가진 사람만이 복호화할 수 있습니다. 이 방식의 장점은 키 배포 문제가 해결된다는 것이며, 단점은 대칭키 암호화에 비해 처리 속도가 느리다는 점입니다.

<br/>
<h2>🤔 왜 HTTPS Handshake 과정에서는 인증서를 사용하는 것 일까요?</h2>

<h3>📝 나의 대답</h3>

- CA에서 발급되는 인증서를 사용하는 이유는 HTTPS 연결 시 옳바른 공개키를 사용하고 있음을 판단하기 위해서입니다. ❌ 틀렸습니다. ❌

<h3>GPT의 대답</h3>

- 인증서는 웹사이트가 그들이 주장하는 대로 신뢰할 수 있는 주체인지 확인하는 역할을 합니다. 이 인증서는 신뢰할 수 있는 제 3자(CA, Certificate Authority)에 의해 서명되며, CA는 공개키와 해당 웹사이트의 정보를 포함하고 있습니다.

- 클라이언트가 웹사이트에 접속할 때 HTTPS Handshake 과정에서 인증서가 전송되며, 클라이언트는 이 인증서를 검증하여 해당 웹사이트가 신뢰할 수 있는 주체인지 확인합니다. 만약 인증서가 유효하지 않다면, 클라이언트는 보안 경고를 받게 됩니다. 이 과정을 통해 사용자는 자신의 민감한 정보(예: 비밀번호, 신용카드 정보 등)가 피싱 사이트 같은 비신뢰할 수 있는 곳으로 가지 않게 됩니다.

<br/>
<h2>🤔 SSL과 TLS의 차이는 무엇인가요?</h2>

<h3>GPT의 대답</h3>

- SSL(Secure Sockets Layer)과 TLS(Transport Layer Security)는 암호화 프로토콜로서, 컴퓨터 네트워크에서 통신 보안을 제공하는데 사용됩니다. 이 두 프로토콜은 일반적으로 데이터를 안전하게 전송하기 위해 사용되며, SSL이 먼저 개발되었고, 그 후에 그것의 후속 버전으로 TLS가 개발되었습니다.

- SSL과 TLS는 비슷한 역할을 하지만, TLS는 보안 강화와 몇 가지 기능 개선을 통해 SSL의 노출된 취약점을 보완한 보다 현대적인 암호화 프로토콜입니다.
</div>
</details>

<details>
<summary style="font-size:20px">Web Socket</summary>
<div markdown="1">
<br/>
<h2>🤔 웹소켓과 소켓 통신의 차이에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 웹 소켓은 웹 통신 시 오고 가는 하나의 통신 단위이며, 소켓을 통해 통신이 이뤄집니다. ❌ 틀렸습니다. ❌

<h3>GPT의 대답</h3>

✅ 소켓 : 이는 네트워크에서 데이터를 교환하는 두 대의 장치 간의 점대점(end-to-end) 연결을 의미합니다. 소켓 통신은 TCP/IP 프로토콜을 사용하며, 서버와 클라이언트가 연결이 끊어질 때까지 양방향 통신을 수행할 수 있습니다.

✅ 웹소켓 : 이는 HTTP 프로토콜 기반의 연결 상에서 웹 서버와 클라이언트 간에 지속적인(full-duplex), 양방향 연결을 가능하게 하는 특수한 프로토콜입니다. 웹소켓은 웹 애플리케이션에서 실시간(real-time) 데이터 전송을 가능하게 하며, 주로 채팅 애플리케이션, 실시간 게임 등에서 사용됩니다.

- 웹소켓은 특정한 소켓 통신의 한 형태이지만, 그것은 웹 환경에서 실시간 양방향 통신을 가능하게 하는 특수한 목적을 가지고 있습니다.

<br/>
<h2>🤔 소켓과 포트의 차이가 무엇인가요?</h2>

<h3>📝 나의 대답</h3>

- 소켓은 네트워크에서 데이터를 교환하는 두 대의 장치 간의 점대점 연결을 의미하며 포트는 특정 네트워크 주소의 역할을 지정한 네트워크 창구입니다. 포트를 지정하게 되면 요청한 포트 번호를 읽어 해당 네트워크에 요청을 전달합니다.

<h3>GPT의 대답</h3>

- 소켓은 네트워크 통신의 한 종류로, 서버와 클라이언트 사이에서 데이터를 주고받을 수 있는 연결 통로를 의미합니다.

- 포트는 서버 내에서 실행되는 특정 프로세스나 서비스에 대한 연결 요청을 식별하는 데 사용되는 숫자입니다.

<br/>
<h2>🤔 여러 소켓이 있다고 할 때, 그 소켓의 포트 번호는 모두 다른가요?</h2>

<h3>📝 나의 대답</h3>

- 아니요. 같습니다. 소켓은 TCP/IP를 사용해 서버와 클라이언트 사이에 데이터를 주고 받을 수 있는 통로를 의미하며 포트는 특정 서비스 혹은 프로세스의 연결 요청을 식별하는데 사용되는 것이기 때문에 연결 통로는 다를 수 있어도 포트는 서버의 동일한 포트를 사용합니다.

<h3>GPT의 대답</h3>

- 서버 내에서 여러 개의 프로세스나 서비스가 동시에 실행될 수 있기 때문에 **각각의 프로세스는 자신만의 소켓을 가지며, 각 소켓은 서로 다른 포트 번호를 할당받을 수 있습니다.**

- 그렇다고 해서 모든 소켓이 반드시 다른 포트를 가지는 것은 아닙니다. 같은 프로세스 내에서 여러 개의 소켓이 동일한 포트를 공유할 수 있습니다. 예를 들어, 웹 서버는 수천 개의 클라이언트로부터 동시에 연결 요청을 받을 수 있으며, 이때 모든 클라이언트 연결은 웹 서버의 80포트 (HTTP) 또는 443포트 (HTTPS)를 사용합니다.

</div>
</details>

<details>
<summary style="font-size:20px">HTTP/1.1과 HTTP/2</summary>
<div markdown="1">
<br/>
<h2>🤔 HTTP/1.1과 HTTP/2의 차이점은 무엇인가요?</h2>

<h3>📝 나의 대답</h3>

- HTTP/1.1은 매 요청을 처리할 때마다 연결을 새로 맺지 않고 keep-alive를 제공합니다. 이를 통해 성능을 높일 수 있었고 HTTP/2는 Multi Flexing기능이 추가되어 비동기적 처리가 가능해 성능을 높였습니다. ❌ 틀렸습니다. ❌

<h3>GPT의 대답</h3>

- HTTP/1.1은 텍스트 기반의 프로토콜이며, 각 요청을 순차적으로 처리하고 각 요청에 대해 새로운 TCP 연결을 열었습니다. 이로 인해 "head-of-line blocking" 문제가 발생하였습니다. 이 문제는 한 번에 하나의 요청만 처리할 수 있다는 것을 의미하며, 이로 인해 웹사이트의 로딩 시간이 늘어나는 문제가 있었습니다.

- HTTP/2는 바이너리 기반의 프로토콜이며, 여러 개의 요청과 응답 메시지를 동시에 하나의 연결을 통해 전송할 수 있는 멀티플렉싱 기능을 제공합니다. 이는 서버와 클라이언트 간의 통신을 효율적으로 만들어줍니다. 또한, HTTP/2는 헤더 압축, 서버 푸시 등과 같은 여러 가지 성능 개선 기능을 제공합니다.

![HTTP Version 차이](/Network/img/http_connection.png)

<br/>
<h2>🤔 HOL Blocking 에 대해 설명해 주세요.</h2>

<h3>GPT의 대답</h3>

✅ HTTP에서의 Head Of Line (HOL) Blocking은 HTTP/1.1 이하의 버전에서 발생하는 주요 문제로, 한 번에 하나의 요청만 처리할 수 있는 제한 때문에 발생합니다.

- HTTP/1.1 프로토콜에서는 각 요청이 순차적으로 처리됩니다. 이는 서버가 이전 요청의 응답을 완료하고 나서야 다음 요청을 처리할 수 있음을 의미합니다. 예를 들어, 서버가 첫 번째 요청의 대량의 데이터를 처리하는 동안 두 번째 요청은 대기 상태에 머무릅니다. 이로 인해 "head-of-line blocking"이 발생하게 됩니다.

<br/>
<h2>🤔 HTTP/3.0의 주요 특징에 대해 설명해 주세요.</h2>

<h3>GPT의 대답</h3>

✅ QUIC 사용: HTTP/3는 TCP 대신 QUIC(Quick UDP Internet Connections)을 사용합니다. 이는 TCP에서 발생할 수 있는 헤드 오브 라인(HOL) 블로킹 문제를 해결하고, 연결 설정 시의 지연 시간을 줄입니다.

✅ 내장된 보안: QUIC는 기본적으로 TLS(Transport Layer Security) 1.3을 사용하여 보안을 제공합니다. 이로 인해 암호화가 기본적으로 적용되며, HTTP/3 연결 설정 시에 별도의 보안 핸드셰이크를 수행할 필요가 없습니다.

✅ 연결 전환: HTTP/3는 사용자가 네트워크를 전환할 때 연결이 끊어지지 않는 기능을 제공합니다. 예를 들어, Wi-Fi에서 LTE로 전환할 때에도 HTTP/3 연결은 유지됩니다.

</div>
</details>

<details>
<summary style="font-size:20px">TCP and UDP</summary>
<div markdown="1">
<br/>
<h2>🤔 TCP와 UDP의 차이에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- TCP와 UDP 모두 네트워크 연결을 맺을 때 사용하는 프로토콜입니다. TCP 연결 시 HandShake 과정을 통해 특정 연경을 맺지만 UDP는 같은 네트워크 내에 데이터를 BroadCast하여 연결을 맺습니다. 보안 측면에서 TCP가 우세하지만 오버헤드가 발생하며 데이터 전송 속도는 UDP가 더 빠릅니다.

<h3>GPT의 대답</h3>

- TCP와 UDP는 둘 다 데이터를 전송하는 방식에 대한 프로토콜이지만 그들의 작동 방식은 매우 다릅니다. TCP는 연결 지향적이며, 데이터의 전송이 누락 없이 정확하게 이루어진다는 것을 보장합니다. 이를 위해, 데이터를 전송하기 전에 송신자와 수신자 사이에 핸드쉐이크 과정을 거쳐 안정적인 연결을 확립합니다.

- 반면에, UDP는 연결이 없는 프로토콜로, 데이터의 도착을 보장하지 않습니다. 그 결과, UDP는 TCP보다 빠르지만, 신뢰성은 낮습니다. 이런 특성 때문에, 실시간 스트리밍 같은 빠른 전송 속도가 중요한 애플리케이션에서는 UDP가 사용됩니다.

<br/>
<h2>🤔 왜 HTTP는 TCP를 사용하나요?</h2>

<h3>📝 나의 대답</h3>

- 신뢰성 있는 연결을 맺어야 하기 때문에 TCP를 사용합니다. TCP 연결은 데이터의 전송이 누락 없이 정확하게 이뤄진다는 것을 보장합니다. 이를 위해 연결을 맺을 때, 핸드쉐이크 과정을 거쳐 안정적인 연결을 확립합니다.

<br/>
<h2>🤔 그렇다면, 왜 HTTP/3 에서는 UDP(QUIC) 를 사용하나요? 위에서 언급한 UDP의 문제가 해결되었나요?</h2>

<h3>📝 나의 대답</h3>

- TCP 연결을 맺어 신뢰성을 확보하고 데이터의 누락 없이 전송하는 것이 가능하지만 신뢰를 맺는 과정은 오버헤드 입니다. HTTP/3에선 QUIC를 사용해 한 번의 연결을 맺은 후 UDP 통신을 사용해 데이터를 전송합니다.

<h3>GPT의 대답</h3>

- QUIC는 기본적으로 UDP 위에 구축된 프로토콜로서, TCP의 신뢰성과 순서 보장 기능을 제공하면서 동시에 UDP의 속도를 유지하려는 목적으로 만들어졌습니다. QUIC는 TCP보다 빠른 연결 설정 시간을 제공하며, 패킷 손실이 발생했을 때의 복구 시간을 줄입니다.


<br/>
<h2>🤔 본인이 새로운 통신 프로토콜을 TCP나 UDP를 사용해서 구현한다고 하면, 어떤 기준으로 프로토콜을 선택하시겠어요?</h2>

<h3>📝 나의 대답</h3>

- 수신하는 측에서 데이터의 손실이 크게 비즈니스에 영향을 끼치지 않는 서비스라면 UDP 통신 프로토콜을 사용하고 그렇지 않고 데이터의 누락이 발생하면 안되는 서비스라면 TCP를 사용할 것 같습니다.

<br/>
<h2>🤔 Checksum이 무엇인가요?</h2>

<h3>📝 나의 대답</h3>

- Checksum은 데이터 수신 시 데이터의 누락을 체크하기 위해 존재합니다. 이를 통해 송신된 데이터가 옳게 전송되었는지 판단하며 그렇지 않았을 경우 송신 측에 데이터를 요청하는데 사용됩니다.

<h3>GPT의 대답</h3>

- 체크섬은 데이터의 무결성을 확인하기 위한 간단한 방법으로, 데이터 전송 중 오류가 발생했는지를 확인하기 위해 사용됩니다. 그러나 체크섬이 완벽하게 모든 오류를 잡아낼 수 있는 것은 아닙니다. 예를 들어, 동일한 수의 비트가 변경되었고 그것이 서로를 상쇄했다면, 체크섬은 오류를 발견하지 못할 수 있습니다.

<br/>
<h2>🤔 TCP와 UDP 중 어느 프로토콜이 Checksum을 수행할까요?</h2>

<h3>📝 나의 대답</h3>

- TCP가 Checksum을 수행합니다. 데이터의 누락이 발생하면 안되기 때문입니다.

<h3>GPT의 대답</h3>

- TCP와 UDP 모두 체크섬을 수행합니다. 체크섬은 데이터 패킷의 무결성을 확인하는 방법으로, 패킷의 데이터가 전송 중에 손상되거나 변경되지 않았는지를 확인하는 데 사용됩니다. TCP는 신뢰성 있는 데이터 전송을 보장하기 위해 추가적인 기능(패킷 재전송, 흐름 제어, 혼잡 제어 등)을 제공하지만, UDP는 이러한 기능을 제공하지 않습니다. 그러나 두 프로토콜 모두 체크섬을 통해 데이터의 무결성을 보호합니다.

<br/>
<h2>🤔 Checksum을 통해 오류를 정정할 수 있나요?</h2>

<h3>📝 나의 대답</h3>

- Checksum을 확인해 송신된 패킷과 수신된 패킷 사이 데이터 무결성을 확인할 수 있으며 TCP의 경우 패킷이 손상되면 송신 측에 요청해 데이터를 다시 전달받을 수 있습니다. 반면 UDP의 경우는 무결성만 확인할 뿐 이 후 처리는 따로 하지 않습니다.

<br/>
<h2>🤔 TCP가 신뢰성을 보장하는 방법에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- TCP가 신뢰성을 보장하는 방법으로 HandShake를 사용합니다. syn, syn + ack, ack를 통해 옳바른 연결을 맺었는지 확인하고 데이터를 주고 받습니다.

<h3>GPT의 대답</h3>

1. 첫째, TCP는 '3-way handshake'를 통해 연결을 초기화하고 종료합니다. 이를 통해 두 호스트 사이에 안정적인 연결이 확립되고 종료됨을 보장합니다. 

2. 둘째, TCP는 각 패킷에 시퀀스 번호를 부여하고, 수신자는 이 시퀀스 번호를 기반으로 패킷을 재정렬하고 누락된 패킷을 감지합니다. 

3. 셋째, TCP는 체크섬을 통해 각 패킷의 무결성을 확인합니다. 체크섬 오류가 감지되면 패킷은 버려지고 재전송이 요청됩니다. 

4. 넷째, TCP는 수신자가 패킷을 성공적으로 받았음을 알리는 ACK(Acknowledgment) 메시지를 사용합니다. 수신자가 패킷을 받으면 ACK 메시지를 보내어 송신자가 패킷의 성공적인 전송을 확인할 수 있게 합니다.

5. TCP는 흐름 제어와 혼잡 제어 메커니즘을 제공하여 네트워크의 상태에 따라 데이터 전송 속도를 조절합니다. 이러한 방법들을 통해 TCP는 네트워크 통신의 신뢰성을 보장합니다.

<br/>
<h2>🤔 TCP의 혼잡 제어 처리 방법에 대해 설명해 주세요.</h2>

<h3>GPT의 대답</h3>

✅ TCP의 혼잡 제어는 네트워크 통신의 효율성과 성능을 크게 개선하는 핵심 기능입니다. 혼잡 제어는 패킷 손실을 줄이고 네트워크 내의 효율적인 자원 사용을 목표로 합니다.

1. Slow Start: TCP 연결이 처음 시작될 때 혼잡 윈도우 크기를 1로 설정하고, 각 ACK가 도착할 때마다 크기를 두 배로 늘립니다. 이를 통해 네트워크 혼잡을 방지하며, 데이터 전송을 안정적으로 시작합니다.

2. Congestion Avoidance: 혼잡 윈도우가 임계값(ssthresh)에 도달하면, 혼잡 회피 알고리즘이 작동하며, 혼잡 윈도우의 크기는 각 라운드 트립마다 선형적으로 증가합니다. 이렇게 함으로써 네트워크 혼잡을 예방합니다.

3. Fast Retransmit: 패킷 손실을 빠르게 감지하고 재전송하는 방법으로, 3개의 중복 ACK가 수신되면 해당 패킷이 손실되었다고 간주하고 재전송합니다.

4. Fast Recovery: 패킷이 손실된 후에 혼잡 윈도우 크기를 줄이는 방법입니다. 중복 ACK를 받은 후, 혼잡 윈도우 크기를 절반으로 줄이고 혼잡 회피 알고리즘을 실행합니다.

</div>
</details>

<details>
<summary style="font-size:20px">DHCP</summary>
<div markdown="1">
<br/>
<h2>🤔 DHCP가 무엇인지 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- DHCP란 같은 네트워크 상에서 동적으로 IP를 할당해주는 프로토콜을 의미합니다.

<h3>GPT의 대답</h3>

- DHCP는 클라이언트 컴퓨터가 네트워크에 연결될 때 자동으로 IP 주소, 서브넷 마스크, 기본 게이트웨이 및 DNS(Domain Name System) 서버 주소 등의 네트워크 설정을 자동으로 가져올 수 있도록 도와줍니다.

- DHCP 서버는 사용 가능한 IP 주소 풀에서 IP 주소를 동적으로 할당하며, 이를 통해 IP 주소 충돌을 방지하고 네트워크 관리를 간편하게 만듭니다.

<br/>
<h2>🤔 DHCP는 몇 계층 프로토콜인가요</h2>

<h3>📝 나의 대답</h3>

- DHCP는 응용 계층에 속하는 프로토콜이며 사용자의 IP를 동적으로 할당해주는 역할을 수행합니다.

<h3>GPT의 대답</h3>

- DHCP는 클라이언트와 서버 간의 통신을 위해 UDP(User Datagram Protocol)를 사용하며, DHCP 메시지는 IP 패킷의 데이터 부분에 포함되어 전송됩니다.

<br/>
<h2>🤔 DHCP는 어떻게 동작하나요.</h2>

<h3>GPT의 대답</h3>

- DHCP Discover: 클라이언트는 네트워크에 처음 연결되면서 DHCP 서버를 찾기 위해 DHCP Discover 메시지를 브로드캐스트로 전송합니다.

- DHCP Offer: DHCP 서버는 DHCP Discover 메시지를 수신하고 사용 가능한 IP 주소 중 하나를 할당하여 DHCP Offer 메시지를 클라이언트에게 전송합니다. 이 메시지에는 클라이언트가 사용할 수 있는 IP 주소와 네트워크 설정 정보가 포함됩니다.

- DHCP Request: 클라이언트는 DHCP Offer를 받은 후 해당 IP 주소를 사용하고자 DHCP Request 메시지를 다시 DHCP 서버에게 전송하여 IP 주소를 요청합니다.

- DHCP Acknowledgment: DHCP 서버는 DHCP Request를 수신하고 해당 IP 주소를 클라이언트에게 할당합니다. 이후 DHCP Acknowledgment 메시지를 클라이언트에게 전송하여 IP 주소 할당을 확인합니다.

- DHCP Lease: 클라이언트는 할당받은 IP 주소를 사용하며, DHCP 서버로부터 할당된 IP 주소의 유효 기간(리스)를 받습니다. 유효 기간 동안 클라이언트는 해당 IP 주소를 유지하고 네트워크를 사용할 수 있습니다.

<br/>
<h2>🤔 DHCP에서 UDP를 사용하는 이유가 무엇인가요</h2>

<h3>📝 나의 대답</h3>

- 클라이언트가 네트워크에서 IP를 할당 받고자 할 때, DHCP Server를 찾는 과정에서 신뢰성이 보장된 연결보단 빠른 연결이 필요하기 때문에 UDP를 사용합니다.

<h3>GPT의 대답</h3>

- UDP는 신뢰성 있는 데이터 전송을 보장하지 않습니다. 이는 DHCP에서는 큰 문제가 되지 않는데, DHCP는 IP 주소 할당을 위한 단방향적인 요청-응답 방식으로 동작하며, 클라이언트와 서버 간의 데이터 무결성이나 순서 보장이 필요하지 않기 때문입니다.

- UDP는 연결 지향적인 프로토콜인 TCP에 비해 연결 설정 및 연결 해제 단계가 없어서 더 빠른 연결을 제공할 수 있습니다.

<br/>
<h2>🤔 DHCP에서, IP 주소 말고 추가로 제공해주는 정보가 있나요.</h2>

<h3>📝 나의 대답</h3>

- 네트워크 설정 정보가 포함되어 있습니다.

<h3>GPT의 대답</h3>

- 서브넷 마스크, 기본 게이트웨이, DNS 서버 주소, DHCP 서버 주소, 기타 옵션 정보를 함께 전달합니다.

<br/>
<h2>🤔 DHCP의 유효기간은 얼마나 긴가요.</h2>

<h3>GPT의 대답</h3>

- 유효 기간은 DHCP 서버가 할당된 IP 주소를 추적하고 관리하는 데 사용되며, 클라이언트는 해당 기간이 지나면 IP 주소를 반납하고 필요에 따라 새로운 IP 주소를 요청해야 합니다. 이를 통해 DHCP 서버는 할당된 IP 주소의 유휴 시간을 최소화하고 네트워크에서 IP 주소를 효율적으로 관리할 수 있습니다.

- 유효 기간은 네트워크 환경과 요구 사항에 따라 다를 수 있으며, 조정할 수 있는 유연성을 가지고 있습니다. 따라서, DHCP의 유효 기간은 설정에 따라 다양하게 설정될 수 있습니다.

</div>
</details>