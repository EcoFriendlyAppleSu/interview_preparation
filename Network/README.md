<details>
<summary style="font-size:20px">쿠키와 세션</summary>
<div markdown="1">
<br/>
<h2>🤔 쿠키와 세션의 차이에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 쿠키는 Http Stateless의 단점을 보완하기 위해 Client의 정보를 담고 있는 웹 저장소입니다. 세션은 Client에게 서버에서 발급되는 정보이며 이를 통해 Client는 서버의 다양한 리소스에 접근할 수 있습니다.

- 쿠키와 세션의 차이는 관리되는 공간에 차이가 존재합니다. Client에서 쿠키를 관리하며 세션은 서버에서 관리합니다.

<h3>GPT의 대답</h3>

- 쿠키와 세션 모두 사용자의 상태 정보를 저장하는 방법입니다. 하지만 그들이 데이터를 저장하고 사용하는 방식과 보안성에 차이가 있습니다. 쿠키는 클라이언트 측에서 데이터를 저장하며, 세션은 서버 측에서 데이터를 저장합니다.

- 쿠키는 사용자가 사이트에 방문할 때마다 보내지는 작은 데이터 조각입니다. 클라이언트는 이 세션 ID를 가지고 서버에 요청을 할 때마다 전달함으로써, 서버는 클라이언트를 식별할 수 있습니다. 보안은 서버에서 관리가되는 세션이 쿠키보다 좋습니다.

<br/>
<h2>🤔 세션 방식의 로그인 과정에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 먼저 가입된 클라이언트에 관한 정보가 서버에 존재해야 합니다. 로그인을 진행할 때, 세션이 생성되며 해당 세션에 관한 정보를 저장합니다. 이 후 요청에 대한 응답이 진행될 때, 쿠키 세션에 정보를 집어 넣어 Client에게 전달합니다.

<h3>GPT의 대답</h3>

- 세션 방식의 로그인 과정은 다음과 같습니다. 먼저, 사용자가 자신의 인증 정보 (예: 사용자 이름 및 암호)를 사용하여 로그인을 시도합니다. 서버는 이 정보를 받아 인증을 진행하고, **성공적인 경우 세션을 생성합니다.** 이 세션은 고유한 세션 ID를 포함하고, 이 ID는 서버가 사용자를 추적하고 사용자의 로그인 상태를 유지하는 데 사용됩니다.

- 생성된 세션 ID는 클라이언트에게 응답으로 전송되며, 이는 클라이언트 측의 쿠키에 저장됩니다. 그 후, 클라이언트는 이 세션 ID를 포함하여 서버에 요청을 보낼 때마다 이 쿠키를 함께 전송합니다. 서버는 이 세션 ID를 통해 사용자를 인식하고, 이에 대응하는 사용자 세션을 찾아 사용자의 로그인 상태를 유지합니다.

- 따라서 사용자가 로그아웃하거나 세션이 만료되면, 해당 세션 ID는 무효화되며, 사용자는 다시 로그인해야 합니다.

<br/>
<h2>🤔 HTTP의 특성인 Stateless에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- HTTP의 Stateless는 상태를 갖고 있지 않은 것을 의미하며 Stateful에 비해 흐름을 기억할 필요가 없어 리소스가 적게 듭니다. 하지만, 매 요청에서 상태값을 기억하지 못하기 때문에 쿠키의 도움을 받아 값을 저장하고 매 요청마다 서버에 함께 쿠키를 전달해 Stateless의 단점을 보완합니다.

<h3>GPT의 대답</h3>

- HTTP의 Stateless 특성은 서버가 클라이언트의 상태 정보를 저장하지 않는 것을 의미합니다. 즉, 각 요청이 독립적이며, 서버는 이전의 요청에 대한 정보를 기억하지 않습니다. 이는 성능 향상을 가져오며, 많은 수의 동시 연결을 처리할 수 있게 합니다.

<br/>
<h2>🤔 Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?</h2>

<h3>📝 나의 대답</h3>

- 아닙니다. 세션이 필요할 때가 존재합니다. Client의 상태를 추적하기 위해 그리고 Client의 잘못된 접근으로 Client를 제한하기 위해선 세션이 필요합니다.

<br/>
<h2>🤔 규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?</h2>

<h3>📝 나의 대답</h3>

- 여러 대의 서버에 요청이 가기 전 Entry Point에 세션 처리를 담당하는 서버를 하나 생성해 Client의 요청을 처리하는 것으로 세션을 관리할 수 있습니다.

<h3>GPT의 대답</h3>

- 규모가 커져 서버가 여러 개가 되었을 때 세션을 관리하는 방법은 여러 가지가 있습니다. 일반적으로 사용되는 방법 중 하나는 **세션 클러스터링**입니다. 이 방법은 여러 서버가 동일한 세션 정보를 공유할 수 있도록 합니다. 이를 통해, 한 서버에서 생성된 세션을 다른 서버에서도 사용할 수 있게 됩니다.

또 다른 방법은 **세션 정보를 중앙 데이터베이스 또는 캐시에 저장**하는 것입니다. 이 방법은 모든 서버가 동일한 저장소를 조회하므로 어느 서버로 요청이 들어오더라도 일관된 세션 정보를 제공할 수 있습니다.
</div>
</details>

<details>
<summary style="font-size:20px">HTTP 응답코드</summary>
<div markdown="1">
<br/>
<h2>🤔 HTTP 응답코드에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- HTTP 응답 코드는 200, 300, 400, 500 번대가 존재하며 200번대는 서버에 요청이 성공을 300번대는 리다이렉션, 400번대는 Client의 요청에 오류가 있을 경우, 500 번대는 서버 내부에서 요청을 처리하지 못한 경우 사용됩니다.

<br/>
<h2>🤔 401 (Unauthorized) 와 403 (Forbidden)은 의미적으로 어떤 차이가 있나요?</h2>

<h3>📝 나의 대답</h3>

- 401은 인가가 허락되지 않은 요청에 대한 상태코드이고 403은 인가와 상관 없이 금지된 서버 자원에 접근할 때 사용되는 상태코드입니다.

<h3>GPT의 대답</h3>

- 401 Unauthorized는 클라이언트가 자신을 인증하지 않았거나 인증이 실패한 경우에 반환되는 상태 코드입니다.

- 403 Forbidden은 서버가 클라이언트의 요청을 이해하고, 클라이언트의 신원도 알고 있지만, 해당 요청을 수행하는 것을 거부하는 상태 코드입니다.

- 401은 "인증되지 않음"을 의미하며, 403은 "접근이 거부됨"을 의미

<br/>
<h2>🤔 200 (ok) 와 201 (created) 의 차이에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 200 응답코드는 Client의 요청이 옳바르게 처리 됐음을 의미하고 201은 요청에의해 서버에 데이터가 추가됐다는 의미입니다.

<h3>GPT의 대답</h3>

- 201 Created 응답은 일반적으로 생성된 리소스의 위치를 가리키는 'Location' 헤더와 함께 제공됩니다.
</div>
</details>

<details>
<summary style="font-size:20px">HTTP Method</summary>
<div markdown="1">
<br/>
<h2>🤔 HTTP Method 에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- HTTP Method는 Client HTTP 요청 Header에 명시되며 전달되는 리소스의 행위를 지정할 수 있습니다.

- GET은 조회를, POST는 리소스 생성, PUT은 Update, Delete는 삭제를 서버에게 전달합니다.

<h3>GPT의 대답</h3>

- HTTP 메소드는 클라이언트가 웹 서버에 요청하는 작업의 종류를 나타냅니다.

- PUT: 존재하는 리소스를 새 데이터로 완전히 대체합니다. 이는 리소스의 전체 업데이트에 사용됩니다.

- PATCH: 존재하는 리소스의 일부를 수정합니다. 이는 리소스의 부분적인 업데이트에 사용됩니다.

<br/>
<h2>🤔 HTTP Method의 멱등성에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- HTTP 멱등성이란 HTTP Method 요청이 진행된다 하더라도 도출되는 값은 항상 같아야 한다는 것을 의미합니다. 멱등성을 지킴으로써 프로세스의 신뢰도를 높일 수 있습니다. ❌ 틀렸습니다. ❌

<h3>GPT의 대답</h3>

- HTTP 메소드의 멱등성(idempotency)이란 동일한 요청을 한 번 또는 여러 번 수행하더라도 서버에 똑같은 효과를 가져야 함을 의미합니다. 이것은 네트워크의 불안정성 등의 이유로 같은 요청이 여러 번 수행되는 경우에도 안전하게 시스템을 운영할 수 있도록 합니다. POST 요청은 멱등성을 갖지 않습니다.

<br/>
<h2>🤔 GET과 POST의 차이는 무엇인가요?</h2>

<h3>📝 나의 대답</h3>

- GET은 서버에게 자원을 요청하는 것이고 POST는 서버에게 자원 생성을 요청하는 것입니다.

<h3>GPT의 대답</h3>

- GET은 일반적으로 정보를 요청하는 데 사용됩니다. GET 요청은 웹 브라우저의 주소 표시 줄에 표시되며, 전송되는 모든 정보는 URL의 일부로 인코딩됩니다. GET은 멱등성을 가집니다, 즉 요청을 여러 번 수행해도 동일한 결과를 가져옵니다.

- POST는 서버에 새로운 데이터를 전송하거나 기존 데이터를 변경하는 데 사용됩니다. POST 요청은 HTTP 요청 본문에 데이터를 포함하여 보냅니다. 이는 데이터를 URL에 직접 포함시키지 않으므로, GET보다 더 많은 데이터를 보낼 수 있습니다. 또한, POST는 멱등성이 없으므로 동일한 요청을 여러 번 보내면 서버의 상태가 여러 번 변경될 수 있습니다."

<br/>
<h2>🤔 POST와 PUT, PATCH의 차이는 무엇인가요?</h2>

<h3>📝 나의 대답</h3>

- POST, PUT, PATCH 모두 HTTP Body에 데이터를 갖고 있습니다. POST는 자원을 생성하는 것이고 멱등성을 보장하지 않습니다. PUT은 전체 데이터를 수정하고 PATCH는 부분 데이터를 수정합니다. PUT과 PATCH는 멱등성을 갖습니다.


<br/>
<h2>🤔 HTTP 1.1 이후로, GET에도 Body에 데이터를 실을 수 있게 되었습니다. 그럼에도 불구하고 왜 아직도 이런 방식을 지양하는 것일까요?</h2>

<h3>📝 나의 대답</h3>

- 이전의 코드들에서 요청을 처리할 때 예전의 GET Method 방식을 택하고 있어 요청을 처리하지 못할 수 있기 때문입니다.

<h3>GPT의 대답</h3>

✅ 호환성 문제 : 많은 중간 프록시 및 서버가 HTTP/1.0 기준으로 구현되어 있으며, 이러한 구현체들은 GET 요청의 본문을 무시하거나 오류를 일으킬 수 있습니다.

✅ 의미론적 부적합성 : HTTP 메서드의 의미론(semantics)에 따라, GET은 서버로부터 정보를 조회하는 데 사용되는 것으로 정의되어 있습니다. 본문 데이터를 통해 서버에 추가 정보를 제공하는 것은 POST 또는 PUT, PATCH와 같은 다른 HTTP 메서드의 역할입니다.

✅ 캐싱 및 재시도(Retry) : GET 요청은 본문 데이터 없이 URL만으로 요청을 식별하므로, 캐싱이 가능하고, 요청이 실패한 경우 재시도할 수 있습니다. 본문 데이터를 포함하면 이러한 장점이 무력화될 수 있습니다.
</div>
</details>

<details>
<summary style="font-size:20px">HTTP</summary>
<div markdown="1">
<br/>
<h2>🤔 HTTP에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- HTTP는 WEB에서 HTML을 전달하기 위한 프로토콜이며 Header Body를 갖고 있습니다. HTTP는 Web의 Stateless 특성을 갖고 있어 서버의 정보를 Client가 갖고 있지 않습니다.

- HTTP는 연결을 맺을 때, TCP/IP Threehand Shake를 통해 검증을 거쳐 연결을 맺으며 현재 사용되는 많은 수의 HTTP는 단 건으로 요청에 대한 응답을 처리하는 것이 아닌 연결 파이프라인을 구축해 연결 리소스를 줄입니다.

<h3>GPT의 대답</h3>

- HTTP(Hypertext Transfer Protocol)는 클라이언트와 서버 간에 웹 기반 데이터를 주고받는 데 사용되는 프로토콜입니다. HTTP는 Stateless 프로토콜로, 각 요청이 독립적이며 이전 요청의 상태를 기억하지 않습니다.

- HTTP 메시지는 요청과 응답으로 나뉘며, 각각은 **헤더와 본문(Body)으로 구성됩니다. 헤더에는 메타데이터가 포함되며, 본문에는 실제 데이터가 포함**됩니다.

- HTTP 메소드는 클라이언트가 수행하려는 동작을 서버에게 알려줍니다. 이에는 GET, POST, PUT, DELETE 등이 있습니다.

- HTTP 상태 코드는 서버가 클라이언트에게 요청 처리 결과를 알려줍니다. 예를 들어 200은 성공을, 404는 Not Found를, 500은 Internal Server Error를 나타냅니다.

- HTTP/1.1에서는 **Keep-Alive 및 파이프라인 기능을 통해 연결을 재사용**하고, 여러 요청을 동시에 처리할 수 있게 되었습니다. HTTP/2.0에서는 이를 더욱 개선하여 멀티플렉싱과 서버 푸시 등의 기능을 추가하였습니다. 이러한 변화를 통해, 웹 성능이 크게 향상되었습니다.

<br/>
<h2>🤔 공개키와 대칭키에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 공개키와 대칭키 모두 암호화를 위해 사용되는 기법입니다. 대칭키는 보내는 클라이언트 쪽과 서버 쪽에서 동일한 암호화 키를 갖고 암호화, 복호화를 하는 것을 의미합니다. 이를 통해 암호화를 진행할 때, 초기 암호화 테이블을 보낼 시 네트워크 상에서 탈취당할 수 있습니다.

- 공개키(비공개키)는 클라이언트와 서버의 키가 다르며 CA에서 인증된 키를 사용자에게 발급하고 서버가 갖고 있는 개인키는 외부에 노출시키지 않는 것을 의미합니다.

<h3>GPT의 대답</h3>

- 대칭키 암호화는 동일한 키를 이용해 암호화와 복호화를 진행하는 방식입니다. 이 방식의 장점은 처리 속도가 빠르다는 것이며, 단점은 키의 배포와 관리가 어렵다는 점입니다. 왜냐하면 키를 안전하게 공유해야 하는데, 이는 간단하지 않기 때문입니다.

- 공개키(비대칭키) 암호화는 두 개의 키(공개키와 개인키)를 사용하는 방식입니다. 공개키로 암호화된 데이터는 오직 매칭되는 개인키를 가진 사람만이 복호화할 수 있습니다. 이 방식의 장점은 키 배포 문제가 해결된다는 것이며, 단점은 대칭키 암호화에 비해 처리 속도가 느리다는 점입니다.

<br/>
<h2>🤔 왜 HTTPS Handshake 과정에서는 인증서를 사용하는 것 일까요?</h2>

<h3>📝 나의 대답</h3>

- CA에서 발급되는 인증서를 사용하는 이유는 HTTPS 연결 시 옳바른 공개키를 사용하고 있음을 판단하기 위해서입니다. ❌ 틀렸습니다. ❌

<h3>GPT의 대답</h3>

- 인증서는 웹사이트가 그들이 주장하는 대로 신뢰할 수 있는 주체인지 확인하는 역할을 합니다. 이 인증서는 신뢰할 수 있는 제 3자(CA, Certificate Authority)에 의해 서명되며, CA는 공개키와 해당 웹사이트의 정보를 포함하고 있습니다.

- 클라이언트가 웹사이트에 접속할 때 HTTPS Handshake 과정에서 인증서가 전송되며, 클라이언트는 이 인증서를 검증하여 해당 웹사이트가 신뢰할 수 있는 주체인지 확인합니다. 만약 인증서가 유효하지 않다면, 클라이언트는 보안 경고를 받게 됩니다. 이 과정을 통해 사용자는 자신의 민감한 정보(예: 비밀번호, 신용카드 정보 등)가 피싱 사이트 같은 비신뢰할 수 있는 곳으로 가지 않게 됩니다.

<br/>
<h2>🤔 SSL과 TLS의 차이는 무엇인가요?</h2>

<h3>GPT의 대답</h3>

- SSL(Secure Sockets Layer)과 TLS(Transport Layer Security)는 암호화 프로토콜로서, 컴퓨터 네트워크에서 통신 보안을 제공하는데 사용됩니다. 이 두 프로토콜은 일반적으로 데이터를 안전하게 전송하기 위해 사용되며, SSL이 먼저 개발되었고, 그 후에 그것의 후속 버전으로 TLS가 개발되었습니다.

- SSL과 TLS는 비슷한 역할을 하지만, TLS는 보안 강화와 몇 가지 기능 개선을 통해 SSL의 노출된 취약점을 보완한 보다 현대적인 암호화 프로토콜입니다.
</div>
</details>

<details>
<summary style="font-size:20px">Web Socket</summary>
<div markdown="1">
<br/>
<h2>🤔 웹소켓과 소켓 통신의 차이에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 웹 소켓은 웹 통신 시 오고 가는 하나의 통신 단위이며, 소켓을 통해 통신이 이뤄집니다. ❌ 틀렸습니다. ❌

<h3>GPT의 대답</h3>

✅ 소켓 : 이는 네트워크에서 데이터를 교환하는 두 대의 장치 간의 점대점(end-to-end) 연결을 의미합니다. 소켓 통신은 TCP/IP 프로토콜을 사용하며, 서버와 클라이언트가 연결이 끊어질 때까지 양방향 통신을 수행할 수 있습니다.

✅ 웹소켓 : 이는 HTTP 프로토콜 기반의 연결 상에서 웹 서버와 클라이언트 간에 지속적인(full-duplex), 양방향 연결을 가능하게 하는 특수한 프로토콜입니다. 웹소켓은 웹 애플리케이션에서 실시간(real-time) 데이터 전송을 가능하게 하며, 주로 채팅 애플리케이션, 실시간 게임 등에서 사용됩니다.

- 웹소켓은 특정한 소켓 통신의 한 형태이지만, 그것은 웹 환경에서 실시간 양방향 통신을 가능하게 하는 특수한 목적을 가지고 있습니다.

<br/>
<h2>🤔 소켓과 포트의 차이가 무엇인가요?</h2>

<h3>📝 나의 대답</h3>

- 소켓은 네트워크에서 데이터를 교환하는 두 대의 장치 간의 점대점 연결을 의미하며 포트는 특정 네트워크 주소의 역할을 지정한 네트워크 창구입니다. 포트를 지정하게 되면 요청한 포트 번호를 읽어 해당 네트워크에 요청을 전달합니다.

<h3>GPT의 대답</h3>

- 소켓은 네트워크 통신의 한 종류로, 서버와 클라이언트 사이에서 데이터를 주고받을 수 있는 연결 통로를 의미합니다.

- 포트는 서버 내에서 실행되는 특정 프로세스나 서비스에 대한 연결 요청을 식별하는 데 사용되는 숫자입니다.

<br/>
<h2>🤔 여러 소켓이 있다고 할 때, 그 소켓의 포트 번호는 모두 다른가요?</h2>

<h3>📝 나의 대답</h3>

- 아니요. 같습니다. 소켓은 TCP/IP를 사용해 서버와 클라이언트 사이에 데이터를 주고 받을 수 있는 통로를 의미하며 포트는 특정 서비스 혹은 프로세스의 연결 요청을 식별하는데 사용되는 것이기 때문에 연결 통로는 다를 수 있어도 포트는 서버의 동일한 포트를 사용합니다.

<h3>GPT의 대답</h3>

- 서버 내에서 여러 개의 프로세스나 서비스가 동시에 실행될 수 있기 때문에 **각각의 프로세스는 자신만의 소켓을 가지며, 각 소켓은 서로 다른 포트 번호를 할당받을 수 있습니다.**

- 그렇다고 해서 모든 소켓이 반드시 다른 포트를 가지는 것은 아닙니다. 같은 프로세스 내에서 여러 개의 소켓이 동일한 포트를 공유할 수 있습니다. 예를 들어, 웹 서버는 수천 개의 클라이언트로부터 동시에 연결 요청을 받을 수 있으며, 이때 모든 클라이언트 연결은 웹 서버의 80포트 (HTTP) 또는 443포트 (HTTPS)를 사용합니다.

</div>
</details>

<details>
<summary style="font-size:20px">HTTP/1.1과 HTTP/2</summary>
<div markdown="1">
<br/>
<h2>🤔 HTTP/1.1과 HTTP/2의 차이점은 무엇인가요?</h2>

<h3>📝 나의 대답</h3>

- HTTP/1.1은 매 요청을 처리할 때마다 연결을 새로 맺지 않고 keep-alive를 제공합니다. 이를 통해 성능을 높일 수 있었고 HTTP/2는 Multi Flexing기능이 추가되어 비동기적 처리가 가능해 성능을 높였습니다. ❌ 틀렸습니다. ❌

<h3>GPT의 대답</h3>

- HTTP/1.1은 텍스트 기반의 프로토콜이며, 각 요청을 순차적으로 처리하고 각 요청에 대해 새로운 TCP 연결을 열었습니다. 이로 인해 "head-of-line blocking" 문제가 발생하였습니다. 이 문제는 한 번에 하나의 요청만 처리할 수 있다는 것을 의미하며, 이로 인해 웹사이트의 로딩 시간이 늘어나는 문제가 있었습니다.

- HTTP/2는 바이너리 기반의 프로토콜이며, 여러 개의 요청과 응답 메시지를 동시에 하나의 연결을 통해 전송할 수 있는 멀티플렉싱 기능을 제공합니다. 이는 서버와 클라이언트 간의 통신을 효율적으로 만들어줍니다. 또한, HTTP/2는 헤더 압축, 서버 푸시 등과 같은 여러 가지 성능 개선 기능을 제공합니다.

![HTTP Version 차이](/Network/img/http_connection.png)

<br/>
<h2>🤔 HOL Blocking 에 대해 설명해 주세요.</h2>

<h3>GPT의 대답</h3>

✅ HTTP에서의 Head Of Line (HOL) Blocking은 HTTP/1.1 이하의 버전에서 발생하는 주요 문제로, 한 번에 하나의 요청만 처리할 수 있는 제한 때문에 발생합니다.

- HTTP/1.1 프로토콜에서는 각 요청이 순차적으로 처리됩니다. 이는 서버가 이전 요청의 응답을 완료하고 나서야 다음 요청을 처리할 수 있음을 의미합니다. 예를 들어, 서버가 첫 번째 요청의 대량의 데이터를 처리하는 동안 두 번째 요청은 대기 상태에 머무릅니다. 이로 인해 "head-of-line blocking"이 발생하게 됩니다.

<br/>
<h2>🤔 HTTP/3.0의 주요 특징에 대해 설명해 주세요.</h2>

<h3>GPT의 대답</h3>

✅ QUIC 사용: HTTP/3는 TCP 대신 QUIC(Quick UDP Internet Connections)을 사용합니다. 이는 TCP에서 발생할 수 있는 헤드 오브 라인(HOL) 블로킹 문제를 해결하고, 연결 설정 시의 지연 시간을 줄입니다.

✅ 내장된 보안: QUIC는 기본적으로 TLS(Transport Layer Security) 1.3을 사용하여 보안을 제공합니다. 이로 인해 암호화가 기본적으로 적용되며, HTTP/3 연결 설정 시에 별도의 보안 핸드셰이크를 수행할 필요가 없습니다.

✅ 연결 전환: HTTP/3는 사용자가 네트워크를 전환할 때 연결이 끊어지지 않는 기능을 제공합니다. 예를 들어, Wi-Fi에서 LTE로 전환할 때에도 HTTP/3 연결은 유지됩니다.

</div>
</details>

<details>
<summary style="font-size:20px">TCP and UDP</summary>
<div markdown="1">
<br/>
<h2>🤔 TCP와 UDP의 차이에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- TCP와 UDP 모두 네트워크 연결을 맺을 때 사용하는 프로토콜입니다. TCP 연결 시 HandShake 과정을 통해 특정 연경을 맺지만 UDP는 같은 네트워크 내에 데이터를 BroadCast하여 연결을 맺습니다. 보안 측면에서 TCP가 우세하지만 오버헤드가 발생하며 데이터 전송 속도는 UDP가 더 빠릅니다.

<h3>GPT의 대답</h3>

- TCP와 UDP는 둘 다 데이터를 전송하는 방식에 대한 프로토콜이지만 그들의 작동 방식은 매우 다릅니다. TCP는 연결 지향적이며, 데이터의 전송이 누락 없이 정확하게 이루어진다는 것을 보장합니다. 이를 위해, 데이터를 전송하기 전에 송신자와 수신자 사이에 핸드쉐이크 과정을 거쳐 안정적인 연결을 확립합니다.

- 반면에, UDP는 연결이 없는 프로토콜로, 데이터의 도착을 보장하지 않습니다. 그 결과, UDP는 TCP보다 빠르지만, 신뢰성은 낮습니다. 이런 특성 때문에, 실시간 스트리밍 같은 빠른 전송 속도가 중요한 애플리케이션에서는 UDP가 사용됩니다.

<br/>
<h2>🤔 왜 HTTP는 TCP를 사용하나요?</h2>

<h3>📝 나의 대답</h3>

- 신뢰성 있는 연결을 맺어야 하기 때문에 TCP를 사용합니다. TCP 연결은 데이터의 전송이 누락 없이 정확하게 이뤄진다는 것을 보장합니다. 이를 위해 연결을 맺을 때, 핸드쉐이크 과정을 거쳐 안정적인 연결을 확립합니다.

<br/>
<h2>🤔 그렇다면, 왜 HTTP/3 에서는 UDP(QUIC) 를 사용하나요? 위에서 언급한 UDP의 문제가 해결되었나요?</h2>

<h3>📝 나의 대답</h3>

- TCP 연결을 맺어 신뢰성을 확보하고 데이터의 누락 없이 전송하는 것이 가능하지만 신뢰를 맺는 과정은 오버헤드 입니다. HTTP/3에선 QUIC를 사용해 한 번의 연결을 맺은 후 UDP 통신을 사용해 데이터를 전송합니다.

<h3>GPT의 대답</h3>

- QUIC는 기본적으로 UDP 위에 구축된 프로토콜로서, TCP의 신뢰성과 순서 보장 기능을 제공하면서 동시에 UDP의 속도를 유지하려는 목적으로 만들어졌습니다. QUIC는 TCP보다 빠른 연결 설정 시간을 제공하며, 패킷 손실이 발생했을 때의 복구 시간을 줄입니다.


<br/>
<h2>🤔 본인이 새로운 통신 프로토콜을 TCP나 UDP를 사용해서 구현한다고 하면, 어떤 기준으로 프로토콜을 선택하시겠어요?</h2>

<h3>📝 나의 대답</h3>

- 수신하는 측에서 데이터의 손실이 크게 비즈니스에 영향을 끼치지 않는 서비스라면 UDP 통신 프로토콜을 사용하고 그렇지 않고 데이터의 누락이 발생하면 안되는 서비스라면 TCP를 사용할 것 같습니다.

<br/>
<h2>🤔 Checksum이 무엇인가요?</h2>

<h3>📝 나의 대답</h3>

- Checksum은 데이터 수신 시 데이터의 누락을 체크하기 위해 존재합니다. 이를 통해 송신된 데이터가 옳게 전송되었는지 판단하며 그렇지 않았을 경우 송신 측에 데이터를 요청하는데 사용됩니다.

<h3>GPT의 대답</h3>

- 체크섬은 데이터의 무결성을 확인하기 위한 간단한 방법으로, 데이터 전송 중 오류가 발생했는지를 확인하기 위해 사용됩니다. 그러나 체크섬이 완벽하게 모든 오류를 잡아낼 수 있는 것은 아닙니다. 예를 들어, 동일한 수의 비트가 변경되었고 그것이 서로를 상쇄했다면, 체크섬은 오류를 발견하지 못할 수 있습니다.

<br/>
<h2>🤔 TCP와 UDP 중 어느 프로토콜이 Checksum을 수행할까요?</h2>

<h3>📝 나의 대답</h3>

- TCP가 Checksum을 수행합니다. 데이터의 누락이 발생하면 안되기 때문입니다.

<h3>GPT의 대답</h3>

- TCP와 UDP 모두 체크섬을 수행합니다. 체크섬은 데이터 패킷의 무결성을 확인하는 방법으로, 패킷의 데이터가 전송 중에 손상되거나 변경되지 않았는지를 확인하는 데 사용됩니다. TCP는 신뢰성 있는 데이터 전송을 보장하기 위해 추가적인 기능(패킷 재전송, 흐름 제어, 혼잡 제어 등)을 제공하지만, UDP는 이러한 기능을 제공하지 않습니다. 그러나 두 프로토콜 모두 체크섬을 통해 데이터의 무결성을 보호합니다.

<br/>
<h2>🤔 Checksum을 통해 오류를 정정할 수 있나요?</h2>

<h3>📝 나의 대답</h3>

- Checksum을 확인해 송신된 패킷과 수신된 패킷 사이 데이터 무결성을 확인할 수 있으며 TCP의 경우 패킷이 손상되면 송신 측에 요청해 데이터를 다시 전달받을 수 있습니다. 반면 UDP의 경우는 무결성만 확인할 뿐 이 후 처리는 따로 하지 않습니다.

<br/>
<h2>🤔 TCP가 신뢰성을 보장하는 방법에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- TCP가 신뢰성을 보장하는 방법으로 HandShake를 사용합니다. syn, syn + ack, ack를 통해 옳바른 연결을 맺었는지 확인하고 데이터를 주고 받습니다.

<h3>GPT의 대답</h3>

1. 첫째, TCP는 '3-way handshake'를 통해 연결을 초기화하고 종료합니다. 이를 통해 두 호스트 사이에 안정적인 연결이 확립되고 종료됨을 보장합니다. 

2. 둘째, TCP는 각 패킷에 시퀀스 번호를 부여하고, 수신자는 이 시퀀스 번호를 기반으로 패킷을 재정렬하고 누락된 패킷을 감지합니다. 

3. 셋째, TCP는 체크섬을 통해 각 패킷의 무결성을 확인합니다. 체크섬 오류가 감지되면 패킷은 버려지고 재전송이 요청됩니다. 

4. 넷째, TCP는 수신자가 패킷을 성공적으로 받았음을 알리는 ACK(Acknowledgment) 메시지를 사용합니다. 수신자가 패킷을 받으면 ACK 메시지를 보내어 송신자가 패킷의 성공적인 전송을 확인할 수 있게 합니다.

5. TCP는 흐름 제어와 혼잡 제어 메커니즘을 제공하여 네트워크의 상태에 따라 데이터 전송 속도를 조절합니다. 이러한 방법들을 통해 TCP는 네트워크 통신의 신뢰성을 보장합니다.

<br/>
<h2>🤔 TCP의 혼잡 제어 처리 방법에 대해 설명해 주세요.</h2>

<h3>GPT의 대답</h3>

✅ TCP의 혼잡 제어는 네트워크 통신의 효율성과 성능을 크게 개선하는 핵심 기능입니다. 혼잡 제어는 패킷 손실을 줄이고 네트워크 내의 효율적인 자원 사용을 목표로 합니다.

1. Slow Start: TCP 연결이 처음 시작될 때 혼잡 윈도우 크기를 1로 설정하고, 각 ACK가 도착할 때마다 크기를 두 배로 늘립니다. 이를 통해 네트워크 혼잡을 방지하며, 데이터 전송을 안정적으로 시작합니다.

2. Congestion Avoidance: 혼잡 윈도우가 임계값(ssthresh)에 도달하면, 혼잡 회피 알고리즘이 작동하며, 혼잡 윈도우의 크기는 각 라운드 트립마다 선형적으로 증가합니다. 이렇게 함으로써 네트워크 혼잡을 예방합니다.

3. Fast Retransmit: 패킷 손실을 빠르게 감지하고 재전송하는 방법으로, 3개의 중복 ACK가 수신되면 해당 패킷이 손실되었다고 간주하고 재전송합니다.

4. Fast Recovery: 패킷이 손실된 후에 혼잡 윈도우 크기를 줄이는 방법입니다. 중복 ACK를 받은 후, 혼잡 윈도우 크기를 절반으로 줄이고 혼잡 회피 알고리즘을 실행합니다.

</div>
</details>

<details>
<summary style="font-size:20px">DHCP</summary>
<div markdown="1">
<br/>
<h2>🤔 DHCP가 무엇인지 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- DHCP란 같은 네트워크 상에서 동적으로 IP를 할당해주는 프로토콜을 의미합니다.

<h3>GPT의 대답</h3>

- DHCP는 클라이언트 컴퓨터가 네트워크에 연결될 때 자동으로 IP 주소, 서브넷 마스크, 기본 게이트웨이 및 DNS(Domain Name System) 서버 주소 등의 네트워크 설정을 자동으로 가져올 수 있도록 도와줍니다.

- DHCP 서버는 사용 가능한 IP 주소 풀에서 IP 주소를 동적으로 할당하며, 이를 통해 IP 주소 충돌을 방지하고 네트워크 관리를 간편하게 만듭니다.

<br/>
<h2>🤔 DHCP는 몇 계층 프로토콜인가요</h2>

<h3>📝 나의 대답</h3>

- DHCP는 응용 계층에 속하는 프로토콜이며 사용자의 IP를 동적으로 할당해주는 역할을 수행합니다.

<h3>GPT의 대답</h3>

- DHCP는 클라이언트와 서버 간의 통신을 위해 UDP(User Datagram Protocol)를 사용하며, DHCP 메시지는 IP 패킷의 데이터 부분에 포함되어 전송됩니다.

<br/>
<h2>🤔 DHCP는 어떻게 동작하나요.</h2>

<h3>GPT의 대답</h3>

- DHCP Discover: 클라이언트는 네트워크에 처음 연결되면서 DHCP 서버를 찾기 위해 DHCP Discover 메시지를 브로드캐스트로 전송합니다.

- DHCP Offer: DHCP 서버는 DHCP Discover 메시지를 수신하고 사용 가능한 IP 주소 중 하나를 할당하여 DHCP Offer 메시지를 클라이언트에게 전송합니다. 이 메시지에는 클라이언트가 사용할 수 있는 IP 주소와 네트워크 설정 정보가 포함됩니다.

- DHCP Request: 클라이언트는 DHCP Offer를 받은 후 해당 IP 주소를 사용하고자 DHCP Request 메시지를 다시 DHCP 서버에게 전송하여 IP 주소를 요청합니다.

- DHCP Acknowledgment: DHCP 서버는 DHCP Request를 수신하고 해당 IP 주소를 클라이언트에게 할당합니다. 이후 DHCP Acknowledgment 메시지를 클라이언트에게 전송하여 IP 주소 할당을 확인합니다.

- DHCP Lease: 클라이언트는 할당받은 IP 주소를 사용하며, DHCP 서버로부터 할당된 IP 주소의 유효 기간(리스)를 받습니다. 유효 기간 동안 클라이언트는 해당 IP 주소를 유지하고 네트워크를 사용할 수 있습니다.

<br/>
<h2>🤔 DHCP에서 UDP를 사용하는 이유가 무엇인가요</h2>

<h3>📝 나의 대답</h3>

- 클라이언트가 네트워크에서 IP를 할당 받고자 할 때, DHCP Server를 찾는 과정에서 신뢰성이 보장된 연결보단 빠른 연결이 필요하기 때문에 UDP를 사용합니다.

<h3>GPT의 대답</h3>

- UDP는 신뢰성 있는 데이터 전송을 보장하지 않습니다. 이는 DHCP에서는 큰 문제가 되지 않는데, DHCP는 IP 주소 할당을 위한 단방향적인 요청-응답 방식으로 동작하며, 클라이언트와 서버 간의 데이터 무결성이나 순서 보장이 필요하지 않기 때문입니다.

- UDP는 연결 지향적인 프로토콜인 TCP에 비해 연결 설정 및 연결 해제 단계가 없어서 더 빠른 연결을 제공할 수 있습니다.

<br/>
<h2>🤔 DHCP에서, IP 주소 말고 추가로 제공해주는 정보가 있나요.</h2>

<h3>📝 나의 대답</h3>

- 네트워크 설정 정보가 포함되어 있습니다.

<h3>GPT의 대답</h3>

- 서브넷 마스크, 기본 게이트웨이, DNS 서버 주소, DHCP 서버 주소, 기타 옵션 정보를 함께 전달합니다.

<br/>
<h2>🤔 DHCP의 유효기간은 얼마나 긴가요.</h2>

<h3>GPT의 대답</h3>

- 유효 기간은 DHCP 서버가 할당된 IP 주소를 추적하고 관리하는 데 사용되며, 클라이언트는 해당 기간이 지나면 IP 주소를 반납하고 필요에 따라 새로운 IP 주소를 요청해야 합니다. 이를 통해 DHCP 서버는 할당된 IP 주소의 유휴 시간을 최소화하고 네트워크에서 IP 주소를 효율적으로 관리할 수 있습니다.

- 유효 기간은 네트워크 환경과 요구 사항에 따라 다를 수 있으며, 조정할 수 있는 유연성을 가지고 있습니다. 따라서, DHCP의 유효 기간은 설정에 따라 다양하게 설정될 수 있습니다.

</div>
</details>

<details>
<summary style="font-size:20px">IP Address</summary>
<div markdown="1">
<br/>
<h2>🤔 IP 주소는 무엇이며, 어떤 기능을 하고 있나요.</h2>

<h3>📝 나의 대답</h3>

- IP 주소는 네트워크 안에 존재하는 서버의 주소입니다. 이를 통해 해당 서버의 위치를 알고 요청을 전달할 수 있습니다.

<h3>GPT의 대답</h3>

- IP 주소는 인터넷 프로토콜(Internet Protocol)에서 사용되는 주소 체계로, **네트워크에 연결된 기기들을 구별하기 위해 사용**됩니다. IP 주소는 네트워크 안의 호스트(기기)들에게 고유한 식별자를 제공합니다.

<br/>
<h2>🤔 IPv6는 IPv4의 주소 고갈 문제를 해결하기 위해 만들어졌지만, 아직도 수많은 기기가 IPv4를 사용하고 있습니다. 고갈 문제를 어떻게 해결할 수 있을까요.</h2>

<h3>📝 나의 대답</h3>

- 내부망으로 네트워크를 구축해 해당 네트워크에서 기기를 추가해 사용한다면 하나의 주소를 할당 받아도 하위에 여러 네트워크 기기를 연결해 사용할 수 있습니다.

<h3>GPT의 대답</h3>

- 이중 스택(Dual Stack) 구현: 이중 스택은 IPv4와 IPv6를 동시에 지원하는 방법입니다.

- NAT(Network Address Translation) 기술: NAT는 사설 IP 주소를 공인 IP 주소로 변환하여 주소 공간을 효율적으로 사용하는 방법입니다.

<br/>
<h2>🤔 IPv4와 IPv6의 차이에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- IPv6는 할당할 수 있는 IPv4주소가 고갈되어 개발된 새로운 주소체계이며 총 48bit으로 이루어져 IPv4보다 표현할 수 있는 주소가 많습니다.

<h3>GPT의 대답</h3>

- 주소 형식: IPv4 주소는 "x.x.x.x" 형식으로 4개의 8비트로 구성된 10진수로 표현됩니다. IPv6 주소는 "x:x:x:x:x:x:x:x" 형식으로 8개의 16비트로 구성된 16진수로 표현됩니다. 따라서, 표현할 수 있는 주소가 더 많습니다.

- 주소 할당 방식: IPv4는 주소 할당에 대한 중앙 관리와 통제가 필요합니다. 주소 할당은 네트워크 관리자나 DHCP 서버를 통해 이루어집니다. IPv6는 기본적으로 Stateless Address Autoconfiguration(SLAAC)이라는 자동 주소 구성 방식을 사용하여 클라이언트가 자동으로 주소를 할당받을 수 있도록 합니다.

<br/>
<h2>🤔 IPv4를 사용하는 장비와 IPv6를 사용하는 같은 네트워크 내에서 통신이 가능한가요? 가능하다면 어떤 방법을 사용하나요.</h2>

<h3>📝 나의 대답</h3>

- 이중 스택을 지원하는 경우에 두 네트워크 사이에서 통신이 가능합니다. IPv6 주소는 압축 표기법을 사용해 8개의 16비트로 구성된 16진수를 4개 8비트로 구성된 10진수로 변경합니다.

<h3>GPT의 대답</h3>

- 터널링(Tunneling): 터널링은 IPv4 네트워크를 통해 IPv6 패킷을 전송하는 방법입니다. IPv6 패킷을 IPv4 패킷으로 캡슐화하여 IPv4 네트워크를 통해 전달하고, 수신 측에서 다시 IPv6로 패킷을 추출하여 처리합니다. 대표적인 터널링 프로토콜로는 6to4, ISATAP, Teredo 등이 있습니다.

- 중계(Translation): 중계는 IPv4와 IPv6 간의 주소 및 프로토콜 변환을 수행하여 상호 통신 가능하도록 하는 방법입니다. 중계 기능을 수행하는 장비나 서버가 IPv4와 IPv6 간의 주소 변환을 처리하고, 패킷의 내용을 변환하여 상호 통신을 지원합니다.

<br/>
<h2>🤔 IP가 송신자와 수신자를 정확하게 전송되는 것을 보장해 주나요.</h2>

<h3>📝 나의 대답</h3>

- 아닙니다. IP는 송신자 수신자의 주소 값이지 전송을 보장해주진 않습니다.

<h3>GPT의 대답</h3>

- **IP 프로토콜은 주소 지정 및 패킷 라우팅을 담당**하며, 송신자와 수신자의 IP 주소를 사용하여 패킷을 전송합니다. 하지만 IP 프로토콜 자체는 패킷 전송의 신뢰성이나 보장성을 제공하지 않습니다.

<br/>
<h2>🤔 IPv4에서 수행하는 Checksum과 TCP에서 수행하는 Checksum은 어떤 차이가 있나요?</h2>

<h3>📝 나의 대답</h3>

- IPv4에서 수행하는 Checksum은 옳바른 네트워크 주소 지정과 패킷 라우팅을 확인하는 것이고 TCP Checksum은 전달하는 패킷의 송신/수신을 확인해 데이터의 무결성을 확인하는 역할을 수행합니다.

<h3>GPT의 대답</h3>

- IPv4 Checksum: IPv4 패킷 헤더의 무결성을 검사하는 것이 주된 목적입니다. IPv4 패킷은 헤더와 데이터로 구성되며, IPv4 Checksum은 헤더 부분의 오류를 검출하기 위해 사용됩니다.

- TCP Checksum: TCP 패킷 전체(헤더와 데이터)의 무결성을 검사하는 것이 목적입니다. TCP Checksum은 TCP 헤더와 TCP 데이터 부분을 모두 포함하여 오류를 검출합니다.

<br/>
<h2>🤔 TTL(Hop Limit)이란 무엇인가요.</h2>

<h3>GPT의 대답</h3>

✅ TTL(Time to Live) 또는 Hop Limit은 네트워크에서 패킷의 수명을 나타내는 값입니다. 이 값은 IPv4와 IPv6에서 모두 사용되며, 패킷이 네트워크를 통과할 때마다 감소됩니다.

- TTL은 라우팅 제한, 네트워크 진단에 사용됩니다.

<br/>
<h2>🤔 IP 주소와 MAC 주소의 차이에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- MAC 주소는 네트워크 기기가 갖고 있는 물리적 주소이며 오직 하나의 값을 갖습니다. IP 주소는 동적으로 할당되는 논리적 주소이며 같은 주소라도 다른 네트워크에 존재할 수 있습니다.

<h3>GPT의 대답</h3>

- MAC 주소는 물리적인 주소로 네트워크 인터페이스에 고유하게 할당되는 반면, IP 주소는 논리적인 주소로 네트워크 상에서 호스트를 식별하기 위해 동적으로 할당되거나 정적으로 설정됩니다.

- 주소 유형: MAC 주소는 물리적인 주소로, 네트워크 인터페이스 카드(NIC)에 고유하게 할당된 식별자입니다. 이 주소는 네트워크 계층 아래에서 작동하며, 네트워크 장비 간의 통신을 위해 사용됩니다. 반면, IP 주소는 논리적인 주소로, TCP/IP 프로토콜 스택에서 사용되는 주소입니다. IP 주소는 네트워크 상에서 호스트들을 구별하기 위해 사용됩니다.

- 주소 형식: MAC 주소는 48비트 또는 6바이트로 구성된 고정 길이의 주소입니다. 일반적으로 16진수로 표현되며, 12자리의 숫자와 문자(A-F)로 구성됩니다. 반면, IP 주소는 IPv4의 경우 32비트 또는 4바이트로 구성된 10진수와 점으로 구분된 4개의 숫자로 표현되며, IPv6의 경우 128비트로 구성된 16진수와 콜론으로 구분된 8개의 숫자와 문자로 표현됩니다.

- 할당 방식: MAC 주소는 NIC 제조사에 의해 고유하게 할당되며, 일반적으로 변경할 수 없습니다. 한 장비당 하나의 MAC 주소를 가지게 됩니다. 반면, IP 주소는 네트워크 관리자 또는 DHCP(Dynamic Host Configuration Protocol) 서버를 통해 동적으로 할당되거나 정적으로 설정될 수 있습니다.

- 사용 목적: MAC 주소는 네트워크 인터페이스를 식별하기 위해 사용됩니다. 패킷은 해당 MAC 주소를 기반으로 직접적으로 인터페이스로 전송됩니다. IP 주소는 호스트를 식별하고, 라우팅을 위해 사용됩니다. 패킷은 해당 IP 주소를 기반으로 라우팅되고, IP 주소를 사용하여 호스트 간 통신이 이루어집니다.

- 범위: MAC 주소는 로컬 영역 네트워크(LAN)에서만 유효합니다. 즉, 같은 LAN에 있는 호스트들 간의 통신에 사용됩니다. 반면, IP 주소는 전역 네트워크인 인터넷과 같은 네트워크에서 사용되며, 다른 네트워크와 호스트들 간의 통신에 사용됩니다.

</div>
</details>

<details>
<summary style="font-size:20px">OSI 7 Layer</summary>
<div markdown="1">
<br/>
<h2>🤔 OSI 7계층에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- OSI 7 Layer는 네트워크 사이 데이터 전송을 계층화해서 나타낸 것입니다. 계층별로 담당하는 책임과 역할을 명시해 데이터 전송 시 각 계층에서 발생하는 일들을 구체화해 프로그래머의 이해를 돕습니다.

<br/>
<h2>🤔 Transport Layer와, Network Layer의 차이에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 전송 계층은 호스트 사이 신뢰성 있는 데이터 전송을 담당합니다. TCP, UDP 프로토콜이 이 계층에서 동작합니다. 네트워크 계층은 IP 프로토콜을 사용해 여러 개의 노드를 거칠 때 패킷을 목적지까지 전달하는 라우팅 기능을 담당합니다.

<br/>
<h2>🤔 L3 Switch와 Router의 차이에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- Switch는 같은 네트워크 안에 존재하는 네트워크 기기들 사이에서 데이터의 전송을 중계하는 장치이며 Router는 외부 네트워크와 연결을 중계하는 기계입니다.

<h3>GPT의 대답</h3>

- L3 Switch는 같은 네트워크 내에서 스위칭 및 라우팅을 수행하는 장치로, Layer 2 스위치와 Layer 3 라우터의 기능을 결합한 형태입니다. 반면에 Router는 서로 다른 네트워크 간의 패킷 전송을 중계하는 장치로, 외부 네트워크와의 연결을 담당합니다.

<br/>
<h2>🤔 각 Layer는 패킷을 어떻게 명칭하나요? 예를 들어, Transport Layer의 경우 Segment라 부릅니다.</h2>

<h3>📝 나의 대답</h3>

- 응용 계층에선 Data/Message라고 부릅니다. 전송 계층에선 Segment라고 부르며 네트워크 계층에선 패킷이라고 합니다. 마지막 데이터 링크 계층에선 프레임이라고 칭합니다.

<br/>
<h2>🤔 각각의 Header의 Packing Order에 대해 설명해 주세요.
</h2>

<h3>GPT의 대답</h3>

✅ 헤더의 패킹 순서는 각 계층에서 프로토콜의 요구 사항과 효율성을 고려하여 설계되었습니다. 보통 필드는 크기에 따라 정렬되어 있고, 프로토콜의 명세에 따라 순차적으로 배치됩니다. 패킹 순서는 데이터의 구성과 효율적인 처리를 위해 중요한 역할을 합니다.

- 응용 계층 : 응용 계층의 헤더는 일반적으로 데이터의 형식, 길이 등에 대한 정보를 포함합니다. 응용 계층은 상위 계층으로부터 받은 데이터를 그대로 사용하므로, 추가적인 헤더를 포함하지 않습니다.

- 전송 계층 : 전송 계층의 헤더는 전송 계층 프로토콜에 따라 다릅니다. 예를 들어, TCP 헤더는 순서번호, 확인응답(ACK) 번호, 윈도우 크기 등의 정보를 포함합니다. 일반적으로 TCP 헤더는 순서대로 필드가 정렬되어 있습니다.

- 네트워크 계층 : 네트워크 계층의 헤더는 IP 헤더로 알려져 있으며, 패킷의 출발지 IP 주소, 목적지 IP 주소, 패킷의 길이 등을 포함합니다. IP 헤더의 필드는 크기에 따라 정렬되어 있습니다.

- 데이터 링크 계층 : 데이터 링크 계층의 헤더는 데이터 링크 프로토콜에 따라 다르지만, 일반적으로 목적지 MAC 주소, 출발지 MAC 주소, 유형 등의 정보를 포함합니다.

<br/>
<h2>🤔 ARP에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- ARP는 IP 주소를 MAC주소로 변경하는 프로토콜이며 전송 계층에 존재하는 프로토콜입니다. ❌ 틀렸습니다.

<h3>GPT의 대답</h3>

- ARP는 네트워크에서 IP 주소를 MAC 주소로 매핑하기 위해 사용되는 프로토콜입니다. 이는 주로 이더넷 또는 로컬 네트워크에서 사용됩니다.

- ARP는 IP 주소를 MAC 주소로 변환하여 호스트 간 통신에 사용되는 프로토콜이며, 주로 네트워크 계층에 위치합니다.

</div>
</details>

<details>
<summary style="font-size:20px">3-Way HandShake</summary>
<div markdown="1">
<br/>
<h2>🤔 3-Way Handshake에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 3-Way HandShake는 TCP 프로토콜을 사용한 신뢰성 있는 연결을 맺을 시 사용되는 기법이며 syn, syn + ack, ack을 사용해 연결을 맺습니다. 먼저 송신측에서 연결을 맺을 수 있는지 syn을 요청을 수신측에 보내고 받은 수신측에서 연결을 맺을 수 있다면 ack을 담아 응답을 보냅니다. 그리고 다시 수신 측에서 ack을 보내 연결을 맺습니다.


<h3>GPT의 대답</h3>

- 3-Way Handshake는 TCP 프로토콜에서 사용되는 신뢰성 있는 연결 설정 기법으로, SYN, SYN-ACK, ACK 패킷을 통해 송신자와 수신자 간의 초기 연결을 맺습니다.

<br/>
<h2>🤔 ACK, SYN 같은 정보는 어떻게 전달하는 것 일까요.</h2>

<h3>📝 나의 대답</h3>

- Ack, Syn과 같은 패킷은 시퀀스 번호와 함께 송/수신에게 전달되며 연결이 성공했다면 해당 시퀀스 번호를 1 증가시켜 응답합니다. ❌ 틀렸습니다.

<h3>GPT의 대답</h3>

- ACK(Acknowledge)와 SYN(Synchronize)은 TCP 프로토콜에서 사용되는 특정 제어 비트 또는 플래그입니다. 이러한 정보는 TCP 헤더의 플래그 필드에 포함되어 송신자와 수신자 사이에서 전달됩니다.

- TCP 헤더의 플래그 필드에는 여러 가지 제어 비트가 포함되어 있습니다. 가장 일반적으로 사용되는 플래그는 다음과 같습니다:

✅ ACK(Acknowledgment): ACK 플래그가 설정되면, 해당 패킷이 수신된 것을 확인하는 응답을 나타냅니다.

✅ SYN(Synchronize): SYN 플래그가 설정되면, 송신자가 연결을 초기화하고 연결 설정을 요청하는 메시지를 보내는 것을 나타냅니다.

- 수신자는 시퀀스 번호를 사용하여 세그먼트의 순서를 확인하고 데이터의 정확성과 완전성을 보장합니다. ACK 플래그가 설정된 세그먼트는 수신자에게 이전 세그먼트의 시퀀스 번호를 확인했다는 응답을 전달합니다.

<br/>
<h2>🤔 2-Way Handshaking 를 하지않는 이유에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 양방향 연결을 맺기 때문에 신뢰성 있는 양방향 연결을 맺기 위해선 마지막 Ack 전송 과정을 거쳐야하기 때문에 2-Way HandShaking을 사용하지 않습니다.

<h3>GPT의 대답</h3>

- 이중 연결 방지: 3-Way Handshaking은 이중 연결을 방지하는 역할을 합니다. 송신자가 SYN 패킷을 보내고 수신자가 SYN-ACK 패킷을 보낼 때, 이중으로 연결 설정 요청을 수신하는 경우를 방지합니다.

- 초기 순서 번호 교환: 3-Way Handshaking을 통해 송신자와 수신자는 초기 시퀀스 번호를 교환할 수 있습니다. 이는 데이터 전송에 있어서 시퀀스 번호의 초기화와 데이터의 순서 보장에 중요한 역할을 합니다.

<br/>
<h2>🤔 두 호스트가 동시에 연결을 시도하면, 연결이 가능한가요? 가능하다면 어떻게 통신 연결을 수행하나요.</h2>

<h3>📝 나의 대답</h3>

- 연결을 시도하면 연결을 맺을 순있습니다만 동시 요청으로 인한 공유 자원의 정합성이 깨지는 동시성 이슈가 발생할 수 있습니다. 따라서 요청을 대기 큐에 쌓고 먼저 들어온 요청을 처리해 동시성을 관리합니다.

<h3>GPT의 대답</h3>

- 두 호스트가 동시에 연결을 시도할 경우에는 동시성 이슈가 발생할 수 있으며, 이를 관리하기 위해 일정한 방법으로 연결을 수행합니다.

- 대기 큐, 3-Way HandShaking, 경합 상황 관리를 사용해 동시성 이슈를 최소화하고, 신뢰성 있는 연결을 구성할 수 있습니다.

- 경합 상황 관리는 대기 큐에 요청을 쌓았더라도, 동시에 연결을 시도한 호스트 중 하나의 요청이 먼저 처리될 수 있습니다. 이러한 경우, 다른 요청은 연결이 거부될 수 있습니다. Client에게 RST(Reset) 패킷을 보내 연결을 거부합니다.

<br/>
<h2>🤔 SYN Flooding 에 대해 설명해 주세요.</h2>

<h3>GPT의 대답</h3>

✅ SYN Flooding은 네트워크 공격 중 하나로, TCP 3-Way Handshake 과정을 악용하여 서비스 거부 (DoS, Denial of Service) 상태를 유발하는 공격입니다.

- 공격자는 대량의 SYN 패킷을 가짜 송신자 IP 주소와 랜덤한 포트 번호와 함께 대상 서버로 전송합니다.

- 서버는 SYN 패킷을 받으면 해당 송신자와 연결을 맺으려고 시도합니다. 그러나 이는 가짜 송신자 IP 주소이므로 실제로는 응답할 수 없는 주소입니다. 따라서 서버는 SYN/ACK 응답을 가짜 송신자 주소로 전송하고, 연결 설정을 대기 상태로 유지합니다.

- 공격자는 이후에 ACK 패킷을 전송하지 않거나, ACK 패킷을 지연하여 서버에 대한 연결 설정을 완료하지 않습니다. 이러한 과정을 계속 반복하면 서버의 리소스(대기 큐, 연결 테이블, 메모리 등)가 과도하게 사용되며, 유효한 연결 요청을 처리할 수 없는 상태가 됩니다. 이로 인해 서비스 거부 상태가 발생하며, 서버의 성능이 저하되거나 완전히 중단될 수 있습니다.

</div>
</details>

<details>
<summary style="font-size:20px">4-Way Handshaking</summary>
<div markdown="1">
<br/>
<h2>🤔 4-Way Handshake에 대해 설명해 주세요.</h2>

<h3>GPT의 대답</h3>

✅ 4-way handshake는 TCP 연결을 종료할 때 사용되는 프로토콜입니다. 이것은 TCP의 특성 중 하나인 연결 지향성(connection-oriented)의 일부로, 두 장치 사이에 논리적인 연결을 설정하고 종료하는 방법을 제공합니다.

<br/>
<h2>🤔 패킷이 4-way handshake 목적인지 어떻게 파악할 수 있을까요.</h2>

<h3>GPT의 대답</h3>

✅ 4-way handshake를 이해하려면 TCP (Transmission Control Protocol) 패킷의 헤더를 살펴보아야 합니다. TCP 헤더에는 여러 플래그(fields)가 있고, 이들 중 FIN (Finish) 플래그와 ACK (Acknowledgement) 플래그가 4-way handshake에 관련되어 있습니다.

<br/>
<h2>🤔 빨리 끊어야 할 경우엔, (즉, 4-way Handshake를 할 여유가 없다면) 어떻게 종료할 수 있을까요.</h2>

<h3>GPT의 대답</h3>

✅ TCP에서 연결을 강제로 끊어야 하는 상황이 발생하면, RST (Reset) 플래그가 설정된 TCP 패킷을 보내어 강제로 연결을 종료할 수 있습니다. 이 RST 패킷은 대상 호스트에게 "이 연결을 즉시 닫고, 관련된 자원을 해제하라"는 명령을 보내는 것입니다.

<br/>
<h2>🤔 4-Way Handshake 과정에서 중간에 한쪽 네트워크가 강제로 종료된다면, 반대쪽은 이를 어떻게 인식할 수 있을까요.</h2>

<h3>GPT의 대답</h3>

✅ 4-Way Handshake 과정 중에 한쪽 네트워크가 강제로 종료되면, 반대쪽은 일정 시간동안 대응하는 ACK(Acknowledgement) 패킷이 도착하지 않음으로써 이를 인식하게 됩니다. TCP에서는 패킷이 전송되고 나면 그에 대한 ACK 패킷을 기다리는데, 이를 타임아웃(timeout)이라고 합니다.

✅ 이와 같이, 네트워크 프로토콜은 일반적으로 응답을 기다리는 타임아웃 메커니즘을 갖추고 있으며, 이를 통해 네트워크의 다른 쪽이 강제로 종료되거나 응답이 없는 상황을 처리할 수 있습니다.

<br/>
<h2>🤔 왜 종료 후에 바로 끝나지 않고, TIME_WAIT 상태로 대기하는 것 일까요</h2>

<h3>GPT의 대답</h3>

✅ 기존 패킷의 처리: 네트워크 지연으로 인해 아직 네트워크 상에서 도착하지 않은 패킷이 있을 수 있습니다. TIME_WAIT 상태는 이러한 패킷들이 안전하게 도착하고 처리될 수 있는 시간을 제공합니다.

✅ 신뢰할 수 있는 연결 종료: TCP는 양방향 연결 프로토콜이므로, 각 방향에 대해 별도로 종료해야 합니다. TIME_WAIT 상태는 먼저 연결을 종료한 측이 상대방의 연결 종료 확인 메시지를 받을 수 있는 시간을 제공합니다.
</div>
</details>

<details>
<summary style="font-size:20px">웹에서 URL 검색 시 발생하는 일</summary>
<div markdown="1">
<br/>
<h2>🤔 www.github.com을 브라우저에 입력하고 엔터를 쳤을 때, 네트워크 상 어떤 일이 일어나는지 최대한 자세하게 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 웹 엔진 주소를 입력하는 공간에 www.github.com를 입력한 후 엔터를 친다면 외부와 통신을 위해 메세지(URL주소)가 TCP/IP 4계층인 응용 - 전송 - 네트워크 - 데이터 링크 계층을 거쳐 ISP가 운영하는 인터넷 망을 타고 목적지 까지 tier 3 - 2 - 1 - 1 - 2 - 3 tier를 거쳐 DNS 서버로 해당 주소를 보냅니다.

- URL 주소를 받은 DNS는 해당 URL 주소에 맞는 IP 주소로 변경해 연결을 맺습니다.

<h3>GPT의 대답</h3>

- 사용자가 웹 브라우저에 "www.github.com"을 입력하고 엔터를 치면, 브라우저는 도메인 이름 시스템(DNS)을 사용하여 "www.github.com"의 IP 주소를 찾습니다.

- 브라우저가 DNS 서버에 쿼리를 보내고, DNS 서버는 해당 도메인에 대한 IP 주소를 반환합니다.

- 이 IP 주소를 통해 브라우저는 GitHub의 서버와 TCP 연결을 설정합니다. 이는 일반적으로 3-way handshake라는 과정을 통해 이루어집니다.

- HTTPS를 사용하는 경우 (기본적으로 GitHub는 HTTPS를 사용합니다), 브라우저와 서버 사이에는 SSL/TLS 핸드셰이크가 이루어집니다. 이 과정에서는 서버의 인증서를 확인하고, 클라이언트와 서버 사이에서 사용할 암호화 키를 교환합니다.

- 브라우저는 이제 HTTP GET 요청을 보내서 "www.github.com"의 메인 페이지를 요청합니다.

- GitHub 서버는 요청된 페이지의 HTML, CSS, JavaScript 등의 내용을 포함하는 HTTP 응답을 보냅니다.

- 브라우저는 이 응답을 받아서 웹 페이지를 렌더링하고 사용자에게 보여줍니다.

<br/>
<h2>🤔 DNS 쿼리를 통해 얻어진 IP는 어디를 가리키고 있나요.</h2>

<h3>📝 나의 대답</h3>

- DNS 쿼리를 통해 얻어진 IP 주소는 DNS 서버를 가리키는 것이 아니라, 요청한 도메인 이름의 실제 위치, 즉 해당 웹 서버를 가리킵니다.

<br/>
<h2>🤔 Web Server와 Web Application Server의 차이에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- Web Application Server는 프로그래머가 Web의 구성 요소를 편집하는 것이고 Web Server는 WAS를 실행한 실행 결과입니다. ❌ 틀렸습니다.

<h3>GPT의 대답</h3>

✅ 웹 서버(Web Server)는 HTTP 프로토콜을 이용해 웹 브라우저에서 요청하는 HTML 문서나 오브젝트(이미지, 텍스트 등)을 전달하는 역할을 합니다. 가장 대표적인 웹 서버 소프트웨어로는 Apache, Nginx 등이 있습니다.

✅ 웹 애플리케이션 서버(Web Application Server, WAS)는 동적인 컨텐츠를 제공하기 위해 사용됩니다. 웹 애플리케이션 서버는 클라이언트(브라우저)로부터 HTTP 요청을 받으면, 그 요청에 맞는 데이터를 생성하여 응답합니다. 이런 데이터는 종종 데이터베이스 조회나 비즈니스 로직에 의해 생성되며, 이로 인해 동적인 웹 페이지나 웹 애플리케이션이 가능해집니다. 대표적인 웹 애플리케이션 서버로는 Tomcat, JBoss 등이 있습니다.

- 웹 서버는 클라이언트의 요청을 받아 정적인 컨텐츠(HTML 문서, 이미지 등)를 제공하는 반면, 웹 애플리케이션 서버는 동적인 컨텐츠를 생성하여 제공하는 역할을 합니다.

<br/>
<h2>🤔 URL, URI, URN은 어떤 차이가 있나요</h2>

<h3>GPT의 대답</h3>

✅ 모두 인터넷 리소스를 찾기 위한 방식을 표현하는데 사용됩니다.

- URI (Uniform Resource Identifier): URI는 인터넷에서 특정 자원을 고유하게 식별하거나 이름을 부여하는데 사용됩니다. 모든 URL과 URN은 URI입니다. 즉, URI는 URL과 URN의 상위 개념이라고 볼 수 있습니다.

- URL (Uniform Resource Locator): URL은 웹에 있는 특정 자원의 위치를 나타내며, 그 자원에 접근하는 데 사용할 수 있는 프로토콜을 지정합니다. 예를 들어, 'http://www.example.com'은 웹에서 'www.example.com'이라는 위치의 자원을 찾는 데 사용되는 URL입니다. 즉, URL은 특정 웹 리소스의 구체적인 위치를 나타냅니다.

- URN (Uniform Resource Name): URN은 자원의 고유 이름을 제공하는 URI의 한 부분입니다. URN은 위치에 독립적이며, 해당 자원이 어디에 위치하고 있는지, 어떻게 접근해야 하는지에 대한 정보를 포함하지 않습니다. 대신, URN은 항상 그 자원을 고유하게 식별하는 이름을 제공합니다.

</div>
</details>

<details>
<summary style="font-size:20px">DNS</summary>
<div markdown="1">
<br/>
<h2>🤔 DNS에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- DNS는 도메인을 갖고 있는 서버로 해당 도메인이 입력되면 도메인 주소에 맞는 IP 주소로 변경시켜 사용자에게 전달하는 역할을 수행합니다. 이를 통해 사용자는 기억하기 어려운 IP 주소가 아닌 도메인 주소를 알면 되어 사용자 편의성이 증가합니다.

<h3>GPT의 대답</h3>

- 클라이언트가 도메인 이름에 대한 IP 주소를 요청하면, 요청은 계층 구조를 따라 위에서 아래로 전달되어 정확한 서버에서 요청을 처리하고 IP 주소를 반환합니다. 이러한 방식으로 DNS는 인터넷 상에서 도메인 이름을 사용한 효율적인 통신을 지원합니다.

<br/>
<h2>🤔 DNS는 몇 계층 프로토콜인가요</h2>

<h3>GPT의 대답</h3>

✅ DNS는 프로토콜 스택 위에서 동작합니다: DNS는 TCP/IP 프로토콜 스택 위에서 동작하며, 애플리케이션과 트랜스포트 계층 간의 인터페이스 역할을 수행합니다.

✅ DNS는 도메인 이름과 IP 주소 간의 매핑을 수행하여 애플리케이션에서 사용되는 도메인 이름을 IP 주소로 변환하고, 역으로 IP 주소를 도메인 이름으로 변환하는 기능을 제공합니다.

<br/>
<h2>🤔 UDP와 TCP 중 어떤 것을 사용하나요</h2>

<h3>📝 나의 대답</h3>

- 둘 다 사용합니다. TCP와 UDP는 신뢰성 있는 연결을 맺고 데이터의 정합성의 중요함에 따라 사용하는 프로토콜이 다른 것을 의미합니다. 예를들어 스트리밍 서비의와 같은 경우 신뢰성 있는 연결을 맺고 데이터를 주고 받는 것보다 UDP 통신을 맺어 실시간성을 제공합니다. 그 때도 DNS를 사용해 해당 스트리밍 서비스의 IP 주소를 Client가 얻을 수 있음으로 UDP, TCP 모두에 DNS가 사용됩니다.

<h3>GPT의 대답</h3>

- UDP와 TCP는 상황에 따라 다르게 사용됩니다. TCP(Transmission Control Protocol)는 연결 지향적인 프로토콜로, 신뢰성 있는 데이터 전송을 보장하며 패킷의 순서를 유지합니다. 따라서 데이터의 정확성과 신뢰성이 중요한 작업에 주로 사용됩니다.

- 반면에 UDP(User Datagram Protocol)는 연결이 이루어지지 않는 프로토콜로, 데이터의 신뢰성보다는 빠른 전송 속도와 실시간성이 중요한 작업에 사용됩니다.

- TCP나 UDP 모두 DNS를 이용해 해당 서비스의 IP 주소를 찾는데 사용됩니다.

<br/>
<h2>🤔 DNS Recursive Query, Iterative Query가 무엇인가요.</h2>

<h3>GPT의 대답</h3>

✅ Client와 DNS 서버 사이 상호작용 방식을 설명하는 용어입니다.

✅ 재귀적 질의는 클라이언트가 DNS 서버에게 모든 작업을 의뢰하고 완전한 응답을 받는 방식입니다. DNS 서버가 필요한 정보를 찾기 위해 필요한 모든 중간 단계를 처리하므로, 클라이언트는 단일 요청으로 필요한 정보를 얻을 수 있습니다.

✅ 반복적 질의는 클라이언트가 DNS 서버에게 정보를 요청하고, DNS 서버가 가지고 있는 가장 적절한 정보를 반환하는 방식입니다. 클라이언트는 받은 정보를 기반으로 새로운 질의를 수행하여 필요한 정보를 얻게 됩니다. 이 과정은 여러 번의 질의와 응답을 거치게 되며, 클라이언트는 원하는 정보를 얻을 때까지 반복적으로 질의를 수행합니다.

<br/>
<h2>🤔 DNS 쿼리 과정에서 손실이 발생한다면, 어떻게 처리하나요.</h2>

<h3>GPT의 대답</h3>

✅ Client는 일정 시간 동안 응답을 받지 못하면 재시도, 타임아웃, 재경로 설정, 에러 처리를 통해 쿼리 과정에서 손실을 최소화합니다.

<br/>
<h2>🤔 DNS 레코드 타입 중 A, CNAME, AAAA의 차이에 대해서 설명해주세요.</h2>

<h3>GPT의 대답</h3>

✅ A 레코드는 도메인 이름을 IPv4 주소로 매핑하고, CNAME 레코드는 도메인 이름에 대한 별칭을 제공하여 호스트 위치를 변경시킬 수 있습니다. AAAA 레코드는 도메인 이름을 IPv6 주소로 매핑하여 IPv6 네트워크 및 호스트에 대한 주소 확인을 제공합니다.

<br/>
<h2>🤔 hosts 파일은 어떤 역할을 하나요? DNS와 비교하였을 때 어떤 것이 우선순위가 더 높나요.</h2>

<h3>GPT의 대답</h3>

❓ Hosts file이란?

- 호스트 이름에 대응하는 IP 주소가 저장되어 있어 DNS에서 주소 정보를 제공받지 않고도 서버의 위치를 찾게 해주는 파일입니다.

✅ 일반적으로 DNS가 hosts 파일보다 우선순위가 더 높습니다. 시스템은 먼저 DNS 서버에 도메인 이름을 해석해보고, 해당 DNS 서버에서 IP 주소를 찾지 못하면 hosts 파일을 확인합니다. DNS는 네트워크를 통해 도메인 이름 해석을 수행하고, 중앙 집중화된 서버에서 최신 정보를 유지하기 때문에 보다 유연하고 확장 가능한 방식으로 동작합니다.
</div>
</details>

<details>
<summary style="font-size:20px">SOP</summary>
<div markdown="1">
<br/>
<h2>🤔 SOP 정책에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- SOP 정책은 동일한 Origin에서 접근을 수행해야 하는 정책입니다. 이를 통해 무분별한 접근을 어느정도 통제할 수 있습니다.

<h3>GPT의 대답</h3>

✅ SOP, 즉 동일 출처 정책(Same-Origin Policy)은 웹 보안에 있어 중요한 원칙 중 하나로, 어떤 출처에서 불러온 문서나 스크립트가 다른 출처에서 가져온 리소스와 상호작용하는 것을 제한하는 중요한 보안 방식입니다.

✅ 출처의 정의는 프로토콜, 도메인, 포트가 같으면 동일한 출처라고 이야기합니다.

<br/>
<h2>🤔 CORS 정책이 무엇인가요.</h2>

<h3>📝 나의 대답</h3>

- CORS는 웹 보안에 있어 중요한 정책입니다. 동일한 출처에서 보낸 요청이 아니라면 서버에선 접근을 제한합니다. ❌ 틀렸습니다. ❌

<h3>GPT의 대답</h3>

✅ CORS(Cross-Origin Resource Sharing)는 보안상의 이유로 동일 출처 정책(Same-Origin Policy)에 의해 제한된 웹 페이지가 다른 출처의 리소스에 접근하는 것을 가능하게 하는 정책입니다. SOP는 기본적으로 다른 출처에서의 요청을 막지만, CORS는 이를 안전하게 우회하게 해 줍니다.

✅ 서버는 HTTP 응답 헤더인 'Access-Control-Allow-Origin'를 통해 어떤 출처가 자신의 리소스에 접근할 수 있는지를 설정할 수 있습니다. 이 때, 복잡한 요청의 경우 'preflight' 요청이 발생하여 서버로부터 안전하게 요청을 보낼 수 있는지를 확인합니다. 따라서, CORS는 사용자의 데이터를 보호하면서 필요에 따라 다른 출처의 리소스에 접근하는 유연성을 제공합니다.

<br/>
<h2>🤔 Preflight에 대해 설명해 주세요.</h2>

<h3>GPT의 대답</h3>

✅ Preflight는 웹 애플리케이션에서 CORS 정책을 준수하기 위한 사전 요청 단계를 이야기합니다. 이를 통해 웹 애플리케이션은 안전한 교차 출처 요청을 수행하고, 사용자의 데이터 및 보안을 보호할 수 있습니다.

</div>
</details>

<details>
<summary style="font-size:20px">Stateless와 Connectionless</summary>
<div markdown="1">
<br/>
<h2>🤔 Stateless와 Connectionless에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- Stateless는 무상태를 이야기하며 객체가 어떤 상태를 갖고 있지 않음을 뜻합니다. HTTP는 무상태성을 갖고 있으며 응답에 대한 정보를 저장하고 있지 않습니다. 따라서, 서버는 연결을 지속적으로 맺을 필요 없이 각 요청을 별개의 요청으로 처리할 수 있습니다. Connectionless는 모르겠습니다.

<h3>GPT의 대답</h3>

- Stateless는 시스템이 이전의 요청 또는 사용자 세션에 대한 정보를 기억하지 않는 상태를 뜻합니다. 예를 들어, HTTP 프로토콜은 무상태성을 가지고 있으므로, 서버는 클라이언트의 이전 요청을 기억하지 않습니다. 이는 서버의 메모리를 효율적으로 사용할 수 있게 해주며, 각 요청을 독립적으로 처리할 수 있게 합니다.

- Connectionless는 통신이 일반적으로 연결을 맺고 해제하는 과정 없이 진행되는 것을 의미합니다. 예를 들어, UDP(User Datagram Protocol)는 연결 없는 프로토콜로, 데이터를 전송하기 전에 사전 연결 설정 과정이 없습니다. 이는 데이터 전송의 실시간성을 중요시하는 응용에서 유용하게 사용됩니다.

❓ HTTP는 Stateless라고들 하는데 Cookie를 통해 정보를 기억하는 것은 상태를 갖는 것이 아닌가요?

<br/>
<h2>🤔 왜 HTTP는 Stateless 구조를 채택하고 있을까요.</h2>

<h3>📝 나의 대답</h3>

- Stateless 구조를 택함으로서 서버의 리소스를 절감할 수 있기 때문입니다. 만약 Stateful한 구조를 갖고 있을 경우 매 요청에 사용자의 정보가 쌓이게 될 것입니다. 이 것은 요청이 갈 때마다 정보의 가중을 불러옵니다. 따라서, 서버에서 불필요한 요청을 걸러내는 추가적인 작업이 필요할 뿐더러 서버에 전달되는 데이터가 많아져 서버에 부하가 심해집니다.

<h3>GPT의 대답</h3>

- 만약 HTTP가 Stateful한 구조를 가지고 있다면, 서버는 각 클라이언트의 상태 정보를 유지하고 관리해야 합니다. 이는 서버에 부가적인 리소스와 복잡성을 초래합니다. 또한, 클라이언트와의 연결이 종료되면 상태 정보를 지우는 등의 추가 작업이 필요합니다.

<br/>
<h2>🤔 HTTP Persistence Connection 이 무엇인가요.</h2>

<h3>GPT의 대답</h3>

✅ HTTP 지속 연결(HTTP Persistent Connection)은 웹 브라우저와 웹 서버 간의 통신에서 사용되는 기술입니다. 이 기술은 여러 개의 요청과 응답을 하나의 TCP 연결을 통해 전송하여 네트워크 지연을 줄이고 성능을 향상시킵니다.

✅ 일반적으로 HTTP 요청은 클라이언트가 서버에 요청을 보내고, 서버는 해당 요청에 대한 응답을 반환한 후에 연결을 종료합니다. 그러나 HTTP 지속 연결을 사용하면 한 번의 TCP 연결을 유지한 상태에서 여러 개의 요청과 응답을 주고받을 수 있습니다. 이를 통해 연결 설정 및 해제에 필요한 시간과 리소스를 절약할 수 있습니다.

✅ HTTP 지속 연결은 HTTP/1.1 버전부터 기본적으로 지원되며, "Connection: keep-alive" 헤더를 통해 요청에 지속 연결을 요청할 수 있습니다.

<br/>
<h2>🤔 TCP의 keep-alive와 HTTP의 keep-alive의 차이는 무엇인가요.</h2>

<h3>GPT의 대답</h3>

✅ TCP의 keep-alive는 네트워크 연결이 활성 상태인지 확인하는 메커니즘입니다. TCP keep-alive는 이러한 상황을 방지하기 위해 주기적으로 "keep-alive" 메시지를 전송하여 연결의 상태를 확인합니다. 연결이 여전히 활성 상태라면 keep-alive 메시지에 대한 응답이 도착해야 합니다. 그렇지 않으면 연결이 종료될 수 있습니다.

✅ HTTP의 keep-alive는 웹 브라우저와 웹 서버 간의 통신에서 사용되는 기술입니다. HTTP keep-alive는 한 번의 TCP 연결을 유지한 상태에서 여러 개의 요청과 응답을 주고받을 수 있도록 합니다.
</div>
</details>

<details>
<summary style="font-size:20px">Router Forwoarding</summary>
<div markdown="1">
<br/>
<h2>🤔 라우터 내의 포워딩 과정에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 네트워크는 라우터를 통해 외부 네트워크와 연결되며 목적지 서버까지 최단 거리로 이동하게 됩니다. 라우터 안에 존재하는 포워딩 테이블엔 주변에 연결된 다른 라우터 주소를 저장하고 있으며 이를 바탕으로 최단 거리를 찾습니다.

<h3>GPT의 대답</h3>

✅ 라우터는 패킷을 수신하고 목적지로 전달하기 위한 핵심 장비입니다. 라우터는 패킷을 받았을 때 해당 패킷을 적절한 인터페이스로 전송하기 위해 포워딩 과정을 수행합니다. 포워딩은 패킷이 라우터를 통과하여 목적지로 전달되는 과정을 이야기합니다.

- 포워딩 과정은 패킷 수신 - 패킷 분석 - 포워딩 테이블 조회 - 적합한 경로 선택 - 패킷 전송을 통해 이뤄집니다.

<br/>
<h2>🤔 라우팅과 포워딩의 차이는 무엇인가요</h2>

<h3>📝 나의 대답</h3>

- 라우팅은 주변 라우터에세 패킷을 BroadCasting으로 전달하는 것이고 포워딩은 적합한 라우터를 지정해 패킷을 전송하는 것을 이야기합니다. ❌ 틀렸습니다. ❌

<h3>GPT의 대답</h3>

- 라우팅은 네트워크에서 최적의 경로를 결정하는 과정이고, 포워딩은 결정된 경로를 통해 패킷을 전송하는 과정을 의미합니다.

- 라우팅은 네트워크에서 패킷이 전송되어야 할 최적의 경로를 결정하는 과정입니다. 이는 라우터의 라우팅 테이블에 의해 제어되며, 다양한 라우팅 알고리즘에 따라 결정됩니다.
 
- 반면에, 포워딩은 패킷이 라우터 내에서 입력 인터페이스에서 출력 인터페이스로 이동하는 과정을 의미합니다. 포워딩은 라우팅에 의해 결정된 경로를 따라 패킷을 전송하는 과정입니다.

<br/>
<h2>🤔 라우팅 알고리즘에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 라우팅 알고리즘은 다익스트라 최단 거리 알고리즘을 사용하고 있습니다. 다익스트라 알고리즘은 가중치가 있는 그래프에서 사용되며 주로 최단 경로를 찾는 데 활용됩니다.

<br/>
<h2>🤔 포워딩 테이블의 구조에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 포워딩 테이블은 라우팅을 통해 최단 거리를 기준으로 정렬되어 있으며 다음 라우터의 IP 주소를 갖고 있습니다. 이를 통해 패킷을 최단 경로로 목적지에 전달할 수 있습니다.

<h3>GPT의 대답</h3>

- 포워딩 테이블은 라우터 내부에 유지되는 데이터 구조로, 패킷을 수신하고 해당 패킷을 어떤 인터페이스로 전달해야 하는지 결정하는 데 사용됩니다. 포워딩 테이블은 다음 라우터의 IP 주소와 관련된 정보를 가지고 있습니다.

</div>
</details>

<details>
<summary style="font-size:20px">로드밸런서</summary>
<div markdown="1">
<br/>
<h2>🤔 로드밸런서가 무엇인가요?</h2>

<h3>📝 나의 대답</h3>

- 로드 밸런서는 스케일 아웃 된 서버들에 요청이 전달되기 전 요청의 부하가 걸리지 않기 위해 요청을 나눠 전달하는 역할을 수행합니다.

- 또한, 특정 요청을 처리하는데 있어 내부적으로 조작을 거쳐 서버에 전달할 수도 있습니다.

<h3>GPT의 대답</h3>

- 로드 밸런서는 네트워크 트래픽이나 애플리케이션의 요청을 여러 서버 간에 균등하게 분산시키는 장치나 소프트웨어를 말합니다. 이는 전체 시스템의 성능을 향상시키고, 서비스의 가용성을 높이며, 장애에 대한 대응 능력을 향상시킵니다.

<br/>
<h2>🤔 L4 로드밸런서와, L7 로드밸런서의 차이에 대해 설명해 주세요.</h2>

<h3>GPT의 대답</h3>

✅ L4와 L7 로드 밸런서는 OSI 참조 모델의 계층에 따라 패킷을 처리하는 방식이 다릅니다. L4 로드 밸런서는 전송 계층에서 작동하며, 주로 IP 주소와 포트 정보를 기반으로 트래픽을 분산시킵니다. 이는 비교적 간단한 작업으로, 빠른 처리 속도와 높은 처리 능력을 가집니다.

✅ 반면에, L7 로드 밸런서는 응용 계층에서 작동하며, HTTP/HTTPS 헤더, 쿠키, 메시지 및 앱레벨 정보와 같은 더 복잡한 데이터를 분석하여 트래픽을 분산시킵니다. 이는 더 세밀한 로드 분산 방식을 제공하며, 사용자 세션을 유지하거나 콘텐츠 기반 라우팅을 수행하는 데 유용합니다.

<br/>
<h2>🤔 로드밸런서 알고리즘에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 로드밸런서 알고리즘은 다양한 것이 존재하지만 Round Robin에 대해서 설명하겠습니다. 정해진 Time Slice안에선 특정 서버에 요청이 전달되게 요청을 처리함으로써 부하를 분산시킵니다.

<br/>
<h2>🤔 로드밸런서 장치를 사용하지 않고, DNS를 활용해서 유사하게 로드밸런싱을 하는 방법에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- DNS에 같은 도메인에 여러 IP를 연결해 요청이 들어올 때 DNS에서 일련의 알고리즘을 거쳐 부하를 분산하는 형태로 DNS를 로드밸런서처럼 사용할 수 있습니다.

</div>
</details>

<details>
<summary style="font-size:20px">서브넷 마스크와 게이트웨이</summary>
<div markdown="1">
<br/>
<h2>🤔 서브넷 마스크와, 게이트웨이에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- SubNet Mask는 할당 받은 네트워크를 효율적으로 사용하기 위해 서브넷 마스킹을 통해 네트워크를 분할해 사용하는 것을 의미하며 이를 통해 얻을 수 있는 장점은 브로드캐스팅 시 데이터를 전달 받는 네트워크 내 기기를 제한해 네트워크에 부하를 줄일 수 있는 장점을 얻을 수 있습니다.

- 게이트웨이는 해당 네트워크로 접속하는 접속 주소를 뜻하며 보통 x.x.x.1의 주소를 갖고 있습니다.

<h3>GPT의 대답</h3>

- 서브넷 마스크는 IP 주소의 네트워크 부분과 호스트 부분을 구분하는데 사용됩니다. 서브넷 마스크를 사용하면 네트워크 관리자는 IP 주소 공간을 효율적으로 분할하고 조직 내의 서브넷을 구성할 수 있습니다. 이를 통해 네트워크 트래픽을 효과적으로 관리하고, 네트워크의 성능과 보안을 향상시킬 수 있습니다.

- 게이트웨이는 네트워크 간에 통신을 가능하게 하는 장치 또는 프로그램을 의미합니다. 일반적으로, 로컬 네트워크에서 다른 네트워크로 데이터를 전송하려면 게이트웨이를 통해야 합니다. 예를 들어, 홈 네트워크에서 인터넷으로 데이터를 전송하려면 라우터(게이트웨이)를 통해야 합니다.

<br/>
<h2>🤔 NAT에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- NAT은 IP 주소 공간의 효율적인 활용을 위해 사설 IP를 공인 IP를 할당하는 것을 의미ㅣ합니다.

<h3>GPT의 대답</h3>

- NAT를 사용하면, 하나의 공인 IP 주소를 여러 사설 IP 주소와 매핑하여 여러 디바이스가 인터넷과 통신할 수 있게 해줍니다.

- NAT을 사용하면 IP 주소 공간의 효율적인 활용, 보안 강화, IP 주소 충돌 문제 해결 문제를 해결할 수 있습니다.

<br/>
<h2>🤔 서브넷 마스크의 표현 방식에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 서브넷 마스크 표현 방식을 기존 IP 주소 뒤에 슬레쉬('/')를 붙이고 숫자를 입력합니다. IPv4 기준으로 32개의 서브넷 마스크를 사용할 수 있으며 서브넷 마스킹을 통해 네트워크 부, 호스트 부를 나눠 할당 받은 네트워크를 효율적으로 나눠 사용할 수 있습니다.

<br/>
<h2>🤔 그렇다면, 255.0.255.0 같은 꼴의 서브넷 마스크도 가능한가요</h2>

<h3>📝 나의 대답</h3>

- 네 가능합니다. 할당 받은 주소가 255.0.255.0이라면 C Class의 공인 IP이고 이 네트워크 안에 여러 서브넷을 만들 수 있습니다.

<h3>GPT의 대답</h3>

- 아니요, 255.0.255.0 같은 서브넷 마스크는 일반적으로 사용되지 않습니다. 서브넷 마스크는 이진수로 표현했을 때 왼쪽에서부터 연속된 1들을 나타낸 다음 나머지는 모두 0으로 채워집니다. 이 규칙에 따르면, 255.0.255.0은 11111111.00000000.11111111.00000000로 표현되므로 유효한 서브넷 마스크가 아닙니다. 즉, 서브넷 마스크에서 '1'과 '0'은 섞일 수 없으며, '1'이 끝나는 지점에서 '0'이 시작되어야 합니다.
</div>
</details>

<details>
<summary style="font-size:20px">멀티플렉싱과 디멀티플렉싱</summary>
<div markdown="1">
<br/>
<h2>🤔 멀티플렉싱과 디멀티플렉싱에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 멀티 플렉싱은 HTTP 2.0에서 사용되는 Stream 요청 처리 방식이며 응답에 대한 요청을 기다리지 않고 각 스트림이 요청을 보냅니다. 응답을 주는 쪽에선 요청을 처리한대로 완료된 결과를 응답으로 보냅니다.

- 디멀티플렉싱은 HTTP 2.0 이전 버전에서 사용되는 Stream 처리 방식이며 요청을 보낸 후 응답이 돌아올 때까지 맺은 연결에서 다른 요청을 보내지 않습니다.

<h3>GPT의 대답</h3>

- 멀티플렉싱은 여러 개의 신호나 데이터 스트림을 하나의 채널을 통해 동시에 전송하는 기술을 일반적으로 말합니다.

- 디멀티플렉싱은 멀티플렉싱의 반대 개념이며, 하나의 통신 채널을 통해 동시에 전송된 여러 신호나 데이터 스트림을 분리하는 과정을 말합니다.
</div>
</details>

<details>
<summary style="font-size:20px">XSS</summary>
<div markdown="1">
<br/>
<h2>🤔 XSS에 대해서 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- XSS는 웹 스크립트에 조작된 코드를 넣어 의도하지 않은 코드를 서버에 전달해 시도하는 공격입니다.

<h3>GPT의 대답</h3>

- XSS(크로스 사이트 스크립팅)는 웹 애플리케이션의 보안 취약점 중 하나로, 악의적인 사용자가 제공한 악성 스크립트를 다른 사용자에게 전달하는 공격 형태입니다.

- XSS 공격은 악성 스크립트가 실행되는 동안 사용자의 세션 정보를 탈취하거나, 사용자가 신뢰하는 웹 사이트에서 악의적인 동작을 수행할 수 있습니다. 이로 인해 피해자의 계정이 탈취되거나, 사이트의 데이터가 조작되는 등의 보안 문제가 발생할 수 있습니다.


<br/>
<h2>🤔 CSRF랑 XSS는 어떤 차이가 있나요.</h2>

<h3>GPT의 대답</h3>

- CSRF: CSRF 공격은 인증된 사용자의 웹 애플리케이션 요청을 악용합니다. 악의적인 사용자가 피해자의 브라우저를 통해 특정 요청을 보냄으로써 공격을 수행합니다.

- CSRF: CSRF 공격은 악의적인 웹 사이트나 이메일 등을 통해, 피해자가 이미 인증된 상태에서 특정 요청을 보내도록 유도합니다. 피해자가 악의적인 요청을 수행하면, 이는 사용자의 인증 정보를 함께 포함하여 웹 애플리케이션에 전송됩니다.

<br/>
<h2>🤔 XSS는 프론트엔드에서만 막을 수 있나요.</h2>

<h3>GPT의 대답</h3>

✅ 입력 데이터 검증과 출력 데이터 이스케이프를 서버에서 관리한다면 XSS 공격을 방어할 수 있습니다.

</div>
</details>