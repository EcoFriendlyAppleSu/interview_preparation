<details>
<summary style="font-size:20px">Transactional이란</summary>
<div markdown="1">
<br/>
<h3>🤔 Transactional은 무엇을 하나요?</h3>

- Transactional은 **하나의 논리적 작업 단위로 수행되는 일련의 작업**을 이야기합니다.
<br/>

<h3>🤔 Transactional 특성은 어떤 것이 있나요?</h3>

- Transactiona이 가져야 하는 특성에는 ACID이 있습니다.

✅ Atomicity: 원자성은 트랜잭션과 관련된 작업들이 부분적으로 실행되다가 중단되지 않는 것을 보장하는 능력이다. 예를 들어, 자금 이체는 성공할 수도 실패할 수도 있지만 보내는 쪽에서 돈을 빼 오는 작업만 성공하고 받는 쪽에 돈을 넣는 작업을 실패해서는 안된다. 원자성은 이와 같이 중간 단계까지 실행되고 실패하는 일이 없도록 하는 것이다.

✅ Consistency: 일관성은 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것을 의미한다. 무결성 제약이 모든 계좌는 잔고가 있어야 한다면 이를 위반하는 트랜잭션은 중단된다.

✅ Isolation: 고립성은 트랜잭션을 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하는 것을 의미한다. 이것은 트랜잭션 밖에 있는 어떤 연산도 중간 단계의 데이터를 볼 수 없음을 의미한다. 은행 관리자는 이체 작업을 하는 도중에 쿼리를 실행하더라도 특정 계좌간 이체하는 양 쪽을 볼 수 없다. 공식적으로 고립성은 트랜잭션 실행내역은 연속적이어야 함을 의미한다. 성능관련 이유로 인해 이 특성은 가장 유연성 있는 제약 조건이다. 자세한 내용은 관련 문서를 참조해야 한다.

✅ Durability: 지속성은 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함을 의미한다. 시스템 문제, DB 일관성 체크 등을 하더라도 유지되어야 함을 의미한다. 전형적으로 모든 트랜잭션은 로그로 남고 시스템 장애 발생 전 상태로 되돌릴 수 있다. 트랜잭션은 로그에 모든 것이 저장된 후에만 commit 상태로 간주될 수 있다.

<h3>❓ Spring Project에서 @Transactional은 어떻게 동작하나요?</h3>

- @Transactional를 통해 DB와의 상호작용이 Transactional으로 묶일 수 있습니다.

1. 메서드가 호출되면 Spring은 Transactional을 시작합니다.
2. 메서드 내에서 수행되는 DB 작업은 Transactional 내에서 실행됩니다. 이러한 작업은 일련의 데이터 변경 작업이 포함될 수 있습니다.
3. 메서드가 성공적으로 완료되면, Spring은 Transaction을 Commit하여 DB의 변경 사항을 영구적으로 반영합니다.
4. 메서드 실행 도중 예외가 발생하면, Spring은 Transaction을 롤백하고 이전 상태로 DB를 되돌립니다. 이는 메서드 내에서 발생한 모든 변경 사항을 취소합니다.

<h3>❓ Transactional을 사용할 때, DataSource 이야기가 많이 나오는데 어떤 상관관계가 존재하나요?</h3>

- DataSource는 Spring에서 DB와의 연결을 관리하는 Interface입니다. Spring은 DataSource Interface를 사용하여 DB ConnectionPool을 구성하고, DB 연결을 관리하며, DB와의 상호작용을 처리합니다.

- DataSource는 DB 연결 설정 및 Transaction 관리 등을 제공합니다. @Transactional 어노테이션과 함께 사용될 때 데이터베이스 연결과 트랜잭션 관리를 담당하는 주요한 요소입니다.

</div>
</details>

<details>
<summary style="font-size:20px">시스템 콜은 무엇인가요?</summary>
<div markdown="1">
<br/>
<h2>🤔 시스템 콜이란?</h2>

<h3>📝 나의 대답</h3>

- 시스템 콜이란 프로세스가 시스템 자원을 사용하기 위해 운영체제에게 자원을 할당 받기 위해 사용되는 트리거입니다.

<h3>GPT의 대답</h3>

- 시스템 콜은 운영체제의 기능과 자원을 사용하기 위해 프로세스가 운영체제에게 요청하는 인터페이스 또는 메커니즘입니다.

<br/>
<h2>🤔 우리가 사용하는 시스템 콜의 예시를 들어주세요</h2>

<h3>📝 나의 대답</h3>

- 예를 들어 프로세스에서 연산이 필요한 필요한 작업을 수행할 때 프로세스는 CPU를 통해 연산을 수행해야하는데 이 때 연산이 필요한 프로세스는 운영체제에게 시스템 콜을 요청합니다.

<h3>GPT의 대답</h3>

- 시스템 콜은 다양한 작업을 포함하며, 예들 들어 파일 입출력, 네트워크 통신, 메모리 관리 등을 포함하고 있습니다.

<br/>
<h2>🤔 시스템 콜이 운영체제에서 어떤 과정으로 실행되는지 설명해 주세요</h2>

<h3>📝 나의 대답</h3>

- 프로세스가 원한다고 해서 즉시 운영체제에게 시스템 콜을 발생해 요청할 수 없습니다. 운영체제의 스케쥴링에 따라 자원을 할당 받을 수 있으며 준비 - 대기 - 실행 상태를 순회하며 컴퓨터 자원을 할당 받습니다.

<h3>GPT의 대답</h3>

- 시스템 콜이 운영체제에서 실행되는 과정은 다음과 같습니다:

1. 프로세스가 시스템 콜을 호출합니다. 이는 프로세스가 운영체제의 특정 기능 또는 자원에 접근하기 위해 필요한 요청입니다.
2. 운영체제는 시스템 콜을 감지하고, 해당 요청을 처리하기 위해 해당 기능 또는 자원에 대한 작업을 시작합니다.
3. 운영체제는 프로세스의 상태를 변경하여 시스템 콜을 처리합니다. 이는 대부분의 경우 프로세스를 사용 가능한 대기 상태로 변경합니다.
4. 운영체제는 필요한 작업을 수행하고, 요청된 자원 또는 기능을 프로세스에 할당합니다. 이를 위해 운영체제는 자원을 관리하고, 프로세스 간의 우선 순위 및 스케줄링 정책을 고려합니다.
5. 운영체제가 요청된 작업을 완료하면, 프로세스는 다시 실행 가능한 상태로 전환되어 해당 작업을 계속합니다.
6. 프로세스는 할당된 자원을 사용하여 원하는 작업을 수행하고, 시스템 콜을 호출한 이후에는 보통 이전 상태로 돌아갑니다.


<br/>
<h2>🤔 시스템 콜의 유형에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 시스템 콜의 유형은 자원을 할당 받았을 때와 할당 받지 못했을 때로 나뉩니다.(표현하는 단어가 생각나지 않습니다.) ❌ 완벽히 틀렸습니다. ❌

<h3>GPT의 대답</h3>

- 프로세스 제어, 파일 조작, 장치 관리, 파일 시스템, 네트워킹, 메모리 관리, 보안 시스템 콜이 존재합니다.

<br/>
<h2>🤔 운영체제의 Dual Mode 에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 시스템 콜의 유형은 자원을 할당 받았을 때와 할당 받지 못했을 때로 나뉩니다.(표현하는 단어가 생각나지 않습니다.) ❌ 완벽히 틀렸습니다. ❌

<h3>GPT의 대답</h3>

- 운영체제의 Dual Mode는 컴퓨터 시스템에서 사용자 모드와 커널 모드라는 두 가지 모드를 지원하는 기능을 말합니다.

- 사용자 모드는 응용 프로그램이 실행되는 모드로, 일반적인 프로세시의 동작 범위를 의미합니다. 사용자 모드에서는 제한된 자원에 접근하고, 일부 민감한 명령어나 하드웨어에 직접적인 접근이 제한됩니다.

- 반면, 커널 모드는 운영체제의 핵심 부분인 커널이 동작하는 모드로, 시스템의 모든 자원과 기능에 접근할 수 있습니다. 커널 모드에서는 시스템 콜과 같은 특권 명령어를 실행하거나 하드웨어를 직접적으로 제어할 수 있습니다.

🍎 Dual Mode 사용 이유

- **Dual Mode의 주요 목적은 운영체제가 시스템 자원을 보호하고, 응용 프로그램이 실수나 악의적인 동작으로 시스템을 손상시키지 못하도록 제한하는 것입니다.** 응용 프로그램은 사용자 모드에서 실행되며, 시스템 자원에 접근하기 위해 시스템 콜을 호출하여 커널 모드로 전환됩니다. 

<br/>
<h2>🤔 서로 다른 시스템 콜을 어떻게 구분할 수 있을까요?</h2>

<h3>📝 나의 대답</h3>

- PID를 통해 구분할 수 있습니다.

<h3>GPT의 대답</h3>

- PID는 프로세스를 식별하는 데 사용되는 고유한 식별자이며, 시스템 콜은 프로세스가 운영체제에 요청하는 인터페이스입니다.

- 시스템 콜을 구분하는 주요 방법은 시스템 콜의 번호나 식별자를 사용하는 것입니다.

</div>
</details>

<details>
<summary style="font-size:20px">인터럽트</summary>
<div markdown="1">
<br/>
<h2>🤔 인터럽트가 무엇인지 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 인터럽트란 프로세스 진행 시 운영체제에게 자원을 요청하는 트리거입니다.

<h3>GPT의 대답</h3>

- 인터럽트는 컴퓨터 시스템에서 발생하는 이벤트나 예외 상황으로, 프로세스의 정상적인 실행 흐름을 중단하고 운영체제에게 어떤 처리를 요청하는 신호입니다.

<br/>
<h2>🤔 인터럽트는 어떻게 처리하나요</h2>

<h3>📝 나의 대답</h3>

- 인터럽트는 서브 루틴을 사용해 처리합니다. 서브 루틴은 Stack의 구조를 띄고 있으며 LIFO으로 요청이 처리됩니다.

<h3>GPT의 대답</h3>

- 인터럽트 처리는 인터럽트 서비스 루틴(ISR)을 호출하여 해당 인터럽트에 대한 처리를 수행하고, 상태를 저장하고 복원하여 중단된 프로세스의 실행을 재개하는 과정으로 이루어진다는 것입니다.

<br/>
<h2>🤔 Polling 방식에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- Polling 방식은 인터럽트에 대한 처리가 끝났는지 지속적으로 확인하는 방식입니다. ❌ 완벽히 틀렸습니다. ❌

<h3>GPT의 대답</h3>

- Polling 방식은 **CPU가 주기적으로 특정 장치나 상태를 확인**하며 인터럽트나 이벤트 발생 여부를 체크하는 방식으로, 인터럽트가 발생하면 해당 인터럽트를 처리하는 과정을 수행한다는 것입니다.

<br/>
<h2>🤔 HW / SW 인터럽트에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 모르겠습니다.

<h3>GPT의 대답</h3>

- HW 인터럽트 : 하드웨어 인터럽트는 주로 하드웨어 장치에서 발생하는 이벤트에 의해 발생합니다. 이벤트는 입출력(I/O) 장치의 데이터 전송 완료, 타이머 경과, 외부 신호 등 다양한 형태일 수 있습니다. 하드웨어 인터럽트는 컴퓨터 시스템의 하드웨어 제어러에 의해 처리됩니다.

- SW 인터럽트 : 소프트웨어 인터럽트는 소프트웨어 실행 중에 발생하는 이벤트에 의해 발생합니다. 주로 운영체제나 프로세스가 직접 발생시키는 인터럽트입니다. 소프트웨어 인터럽트는 프로세스의 특정 상황이나 요청에 의해 발생할 수 있습니다. 

</div>
</details>

<details>
<summary style="font-size:20px">프로세스</summary>
<div markdown="1">
<br/>
<h2>🤔 프로세스란 무엇인가요</h2>

<h3>📝 나의 대답</h3>

- 프로세스란 하나의 동작하는 프로그램입니다.

<h3>GPT의 대답</h3>

- 프로세스는 컴퓨터에서 실행중인 프로그램입니다. 프로세스는 OS에 의해 관리되며 프로그램의 인스턴스로서 메모리와 CPU 등의 시스템 리소스를 할당받아 실행됩니다.

- 각 프로세스는 독립적으로 실행됩니다.


<br/>
<h2>🤔 프로그램과 프로세스, 스레드의 차이에 대해 설명해 주세요.
</h2>

<h3>📝 나의 대답</h3>

- 프로세스는 컴퓨터에서 실행중인 프로그램을 의미하며 스레드는 그 안에 존재해 작업을 처리하는 역할을 수행합니다. 하나의 프로세스 내에서 여러 개의 스레드가 존재할 수 있습니다.

<h3>GPT의 대답</h3>

- 프로세스에 대한 설명은 맞습니다. 스레드는 프로세스 안에 존재하며, **프로세스의 자원을 공유**하면서 작업을 처리하는 작은 실행 단위입니다. 

- 프로세스는 최소한 하나의 스레드를 가지고 있어야 하지만, 여러 개의 스레드를 가질 수도 있습니다. 스레드는 프로세스 내에서 병렬적으로 동작하며, 서로 다른 스레드는 프로세스의 자원을 공유하면서 작업을 수행할 수 있습니다.

<br/>
<h2>🤔 스레드는 PCB를 갖고 있을까요?</h2>

<h3>📝 나의 대답</h3>

- 아니요. 스레드는 PCB를 갖고 있지 않습니다. PCB는 실행중인 프로세스에게 할당되는 고유한 값이고 스레드는 PCB ID와 같은 정보를 알고 있습니다.

<h3>GPT의 대답</h3>

- "스레드는 PCB(Process Control Block)를 직접 갖고 있는 것은 아닙니다. PCB는 실행 중인 프로세스에게 할당되는 고유한 값으로, 프로세스의 상태, 우선순위, 자원 할당 정보 등을 포함합니다. 
  
- 스레드는 프로세스 내에서 실행되는 작은 실행 단위로, 여러 개의 스레드는 하나의 프로세스의 자원을 공유하면서 병렬적으로 동작합니다. 각 스레드는 프로세스의 PCB ID와 같은 정보를 알고 있어 해당 프로세스의 자원에 접근하고 조작할 수 있습니다."

<br/>
<h2>🤔 리눅스에서, 프로세스와 스레드는 각각 어떻게 생성될까요?</h2>

<h3>📝 나의 대답</h3>

- 리눅스 환경에서 프로세스는 Root 프로세스에서 자식 프로세스의 형식으로 생성되며 스레드는 생성된 프로세스에 기본값으로 스레드가 할당됩니다.

<h3>GPT의 대답</h3>

- 리눅스에서 프로세스는 **'fork()' 시스템 콜**을 통해 생성됩니다. 이 'fork()' 함수는 호출한 프로세스의 **복사**본인 자식 프로세스를 만들며, 이 둘은 독립된 메모리 공간을 갖게 됩니다. 이후 **'exec()' 시스템 콜**을 사용하여 자식 프로세스의 **메모리에 새로운 프로그램을 로드**할 수 있습니다.

- 스레드의 생성은 'pthread_create()' 함수를 통해 이루어집니다. 이 함수를 호출하면 호출한 프로세스 내에서 새로운 스레드가 생성됩니다.

<br/>
<h2>🤔 자식 프로세스가 상태를 알리지 않고 죽거나, 부모 프로세스가 먼저 죽게 되면 어떻게 처리하나요?</h2>

<h3>📝 나의 대답</h3>

- ❗️ 모르겠습니다.

<h3>GPT의 대답</h3>

✅ 자식 프로세스가 상태를 알리지 않고 종료될 경우

- 이 경우 자식 프로세스는 'Zombie 프로세스'가 됩니다. 이는 프로세스가 종료되었지만 부모 프로세스가 그 상태 정보를 아직 회수하지 않은 상태를 말합니다. 이 정보를 회수하지 않으면 프로세스 테이블에 불필요한 정보가 계속 남아 있어, 자원 낭비를 초래할 수 있습니다. 이를 해결하기 위해 부모 프로세스는 'wait()' 또는 'waitpid()' 함수를 호출하여 자식 프로세스의 상태 정보를 회수합니다.

✅ 부모 프로세스가 먼저 종료될 경우

- 이 경우 자식 프로세스는 'Orphan 프로세스'가 됩니다. 부모 프로세스가 종료되면 그의 자식 프로세스들은 init 프로세스(프로세스 ID가 1인 프로세스)가 자동으로 채택하여 그 부모로 만듭니다. init 프로세스는 주기적으로 'wait()'를 호출하여 종료된 자식 프로세스의 상태 정보를 회수하므로, Orphan 프로세스가 Zombie 프로세스가 되는 것을 방지합니다.

<br/>
<h2>🤔 리눅스에서, 데몬프로세스에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 데몬 프로세스란 백그라운드에서 실행되는 프로세스를 의미하며 운영체제가 구동될 수 있게 도와주는 역할을 수행합니다.

<h3>GPT의 대답</h3>

- 데몬 프로세스는 사용자와의 상호작용 없이 백그라운드에서 실행되는 프로세스로, 주로 시스템 작업이나 서비스를 관리하며 일반적으로 시스템 부팅 시에 시작되어 시스템이 종료될 때까지 계속 실행됩니다.
  
- 예를 들어, 웹 서버, FTP 서버, 데이터베이스 서버 등의 서비스는 모두 데몬 프로세스로서 동작하며, 이들은 사용자의 요청에 응답하고 필요한 작업을 수행합니다.

</div>
</details>

<details>
<summary style="font-size:20px">프로세스 주소 공간</summary>
<div markdown="1">
<br/>
<h2>🤔 프로세스 주소공간에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 프로세스 주소 공간엔 5가지 영역이 존재합니다. 코드, 데이터, 힙, 스텍, 메모리 영역이 존재합니다. 코드 영역은 실행할 프로그램의 코드를 저장. 데이터 영역은 전역 변수와 정적 변수를 저장, 힙 영역은 인스턴스를 할당 해제하는 메모리 공간, 스택 영역은 프로그램이 자동으로 사용하는 메모리 영역입니다.

<h3>GPT의 대답</h3>

- 코드(Code) 영역: 프로세스가 실행할 코드, 즉 컴파일된 프로그램의 기계어를 저장합니다. 이 영역은 읽기 전용이므로 프로세스가 자신의 코드를 수정하는 것을 막습니다.

- 데이터(Data) 영역: 전역 변수와 정적 변수가 저장되는 영역입니다. 프로그램 시작 시 할당되며 프로그램 종료 시 소멸합니다.

- 힙(Heap) 영역: 동적 메모리 할당이 이루어지는 영역으로, 개발자에 의해 메모리 할당과 해제가 이루어집니다. 메모리 요구량이 커질수록 힙 영역은 코드 영역의 방향으로 확장됩니다.

- 스택(Stack) 영역: 지역 변수, 함수 매개변수, 반환 주소 등이 저장되는 영역입니다. 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸됩니다. 메모리 요구량이 커질수록 스택 영역은 데이터 영역의 방향으로 확장됩니다.

<br/>
<h2>🤔 초기화 하지 않은 변수들은 어디에 저장될까요?</h2>

<h3>📝 나의 대답</h3>

- 초기화 하지 않은 변수들은 코드 영역에 저장됩니다. ❌ 틀렸습니다.

<h3>GPT의 대답</h3>

- 초기화 하지 않은 변수들은 데이터 영역에 존재합니다.

- 데이터 영역은 전역 변수가 존재하는 영역이지만 그 안에 초기화된 전역 변수가 위치하는 공간과 초기화 되지 않은 전역변수가 위치하는 공간이 따로 존재합니다.이를 BSS(Block Started By Symbol)영역 이라고 부릅니다.

<h3>❓ 초기화된 전역 변수와 초기화 되지 않은 전역 변수는 어떤 다른점이 있나요?</h3>

- 메모리를 효율적으로 사용할 수 있게 됩니다. 초기화되지 않은 변수의 값은 실행 도중 채워질 것이므로 변수의 값을 따로 기억할 필요가 없기 때문에 메모리 공간을 절약할 수 있습니다.

<br/>
<h2>🤔 일반적인 주소공간 그림처럼, Stack과 Heap의 크기는 매우 크다고 할 수 있을까요? 그렇지 않다면, 그 크기는 언제 결정될까요?</h2>

<h3>📝 나의 대답</h3>

- 프로세스 실행 시 기본적으로 필요한 인스턴스 공간을 제외하고 런타임 시 크기가 결정됩니다.

<h3>GPT의 대답</h3>

- 스택과 힙의 크기는 프로세스가 실행되는 동안 동적으로 변경됩니다.

<br/>
<h2>🤔 Stack과 Heap 공간에 대해, 접근 속도가 더 빠른 공간은 어디일까요?</h2>

<h3>📝 나의 대답</h3>

- 답은 Stack입니다. Stack에선 지역 변수, 함수 매개변수, 반환 주소 등을 저장해 사용하고 이를 바탕으로 Heap 공간의 인스턴스들을 사용하기 때문에 접근 속도는 Heap 보다 Stack이 더 빠릅니다. ❌ 틀린 답변입니다. ❌

<h3>GPT의 대답</h3>

- Stack 메모리는 구조상 연속적으로 구조가 고정되어 있어, 메모리 접근 속도가 힙에 비해 빠릅니다.

<br/>
<h2>🤔 프로세스 주소 공간을 분할하는 이유는 무엇인가요</h2>

<h3>📝 나의 대답</h3>

- 공간을 분리하는 이유는 각 영역의 책임과 역할이 다르기 때문입니다. 어떤 영역에서는 프로그램 실행 시 크기를 예측할 수 있는 정적 영역을 관리하고 어떤 영역에서는 동적으로 영역을 확보해 사용합니다.

- 이를 한 곳의 영역에서 관리한다면 복잡성이 늘어날 것이기 때문에 공간을 분리하는 것입니다.

<h3>GPT의 대답</h3>

- 프로세스 주소 공간을 분할하는 이유는 각 영역의 책임과 역할이 다르기 때문이며, 이는 프로그램의 복잡성을 줄여주고, 프로그램의 안정성을 높여줍니다. 또한, 각 영역은 다른 권한을 갖고 있기 때문에 **메모리 보호**를 위해서도 주소 공간을 분할합니다.

<br/>
<h2>🤔 스레드의 주소공간은 어떻게 구성되어 있을까요?</h2>

<h3>📝 나의 대답</h3>

- 스레드는 동적으로 생성되어 사용되며 프로세스의 힙, 데이터, 코드 영역을 공유해 사용합니다. 스택 영역은 독립적으로 사용합니다.

<h3>GPT의 대답</h3>

- 스레드는 동일한 프로세스 내에서 실행되며, 따라서 코드, 데이터, 힙 영역을 공유합니다. 그러나 각 스레드는 자신만의 스택 영역을 가지고 있어, 함수 호출과 반환, 지역 변수 등 스레드 별로 다른 정보를 관리할 수 있습니다.
 
- 이는 **스레드의 독립적인 실행 흐름을 보장**하는 데 중요한 역할을 합니다. 
</div>
</details>

<details>
<summary style="font-size:20px">단기, 중기, 장기 스케쥴러</summary>
<div markdown="1">
<br/>
<h2>🤔 단기, 중기, 장기 스케쥴러에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 모르겠습니다.

<h3>GPT의 대답</h3>

✅ 장기 스케줄러 :  하드 디스크에 저장된 프로세스들 중 어떤 것을 메인 메모리에 적재할지 결정합니다. 이 스케줄러의 주된 목적은 적절한 프로세스의 조합을 통해 메모리의 효율적인 사용을 달성하는 것입니다.

✅ 중기 스케줄러 : 실행 중인 프로세스를 잠시 중지하고 하드 디스크에 다시 저장하는 스왑 인/아웃(Swapping in/out) 과정을 담당합니다.

✅ 단기 스케줄러 :  메모리에 있는 프로세스 중 어떤 것을 CPU에 할당할지를 결정합니다. 즉, 어떤 프로세스가 다음에 실행될지를 결정합니다.

<br/>
<h2>🤔 현대 OS에는 단기, 중기, 장기 스케쥴러를 모두 사용하고 있나요?</h2>

<h3>📝 나의 대답</h3>

- 네 현대 OS에는 단기, 중기, 장기 스케줄러를 사용하며 성능을 더욱 끌어 올리기 위해 캐시 메모리를 적용해 사용합니다.

<h3>GPT의 대답</h3>

- 현대의 운영 체제 대부분은 장기 스케줄러와 단기 스케줄러를 사용합니다. 이는 각각 어떤 프로세스를 메모리에 적재할지, 그리고 어떤 프로세스를 CPU에 할당할지를 결정합니다. 
  
- 중기 스케줄러는 오래된 시스템에서 스왑 작업을 관리하는 데 사용되었지만, 현대의 운영 체제에서는 대체로 사용되지 않습니다. 

<br/>
<h2>🤔 preemptive/non-preemptive 에서 존재할 수 없는 상태가 있을까요?</h2>

<h3>📝 나의 대답</h3>

- 모르겠습니다.

<h3>GPT의 대답</h3>

- 스케줄링에 있어서 preemptive와 non-preemptive는 **운영체제가 CPU를 어떻게 관리하는지**에 대한 전략을 의미합니다.

✅ Preemptive 스케줄링은 운영 체제가 현재 실행 중인 프로세스를 중지하고 다른 프로세스를 실행할 수 있는 권한을 가지고 있는 상황을 말합니다.

✅ Non-preemptive 스케줄링은 현재 실행 중인 프로세스가 자발적으로 CPU를 반환할 때만 다른 프로세스가 실행될 수 있는 상황을 말합니다.

<br/>
<h2>🤔 Memory가 부족할 경우, Process는 어떠한 상태로 변화할까요?
</h2>

<h3>📝 나의 대답</h3>

- 메모리가 부족할 경우, 만약 사용 가능한 메모리 범위를 넘어섰을 때, 프로세스는 Overflow Error를 반환하며 운영체제에 의해 강제 종료됩니다. 프로세스가 강제종료 되지 않게 내부적으로 메모리 Clean 과정이 강제로 이뤄질 수도 있습니다. 자바에서는 GC를 통해 관리됩니다.

<h3>GPT의 대답</h3>

- 메모리가 부족할 경우, 프로세스는 운영 체제에 의해 '대기' 상태로 전환될 수 있습니다. 이는 메모리가 다시 사용 가능해질 때까지 프로세스가 실행되지 않음을 의미합니다. 이런 상황은 주로 운영 체제의 스왑 메커니즘이 작동할 때 발생합니다. 

- 또한, 만약 사용 가능한 메모리 범위를 넘어서는 동작이 시도될 경우, 프로세스는 오류를 반환하며 강제로 종료될 수 있습니다. 이외에도, 일부 프로그래밍 언어나 환경에서는 메모리 관리를 위한 별도의 메커니즘을 제공하기도 합니다. 예를 들어, 자바에서는 가비지 컬렉터(GC)를 통해 사용되지 않는 메모리를 정리합니다

<br/>
</div>
</details>

<details>
<summary style="font-size:20px">컨텍스트 스위칭</summary>
<div markdown="1">
<h2>🤔 컨텍스트 스위칭 시에는 어떤 일들이 일어나나요?</h2>

<h3>📝 나의 대답</h3>

- 컨텍스트 스위칭이 일어나면 기존에 존재하는 프로세스의 기록을 해당 프로세스의 PCB에 업데이트를 진행하고 다음 실행될 프로세스가 OS에게 시스템 콜이 발생시켜 시스템 자원을 사용할 수 있게 됩니다.

<h3>GPT의 대답</h3>

- 컨텍스트 스위칭이 일어나면, 운영 체제는 현재 실행 중인 프로세스의 상태를 PCB에 저장합니다. 그런 다음, 새롭게 실행될 프로세스의 PCB 정보를 불러와 CPU 레지스터 및 프로그램 카운터를 업데이트합니다. 이 과정은 새로운 프로세스가 이전에 중단된 지점부터 실행을 계속할 수 있게 해줍니다.
  
- 또한, 필요에 따라 메모리 관리 정보도 업데이트 될 수 있습니다. 이러한 과정을 통해 운영 체제는 다수의 프로세스나 스레드가 동시에 실행되는 것처럼 보이게 할 수 있습니다.

<br/>
<h2>🤔 프로세스와 쓰레드는 컨텍스트 스위칭이 발생했을 때 어떤 차이가 있을까요?</h2>

<h3>📝 나의 대답</h3>

- 차이점을 이야기 하기 전에 공통점을 먼저 말하자면 문맥을 교환한다는 것과 교환 시 오버헤드가 발생한 다는 것입니다. 차이점은 스레드 스위칭은 프로세스 내부에서 발생한다는 것입니다.

<h3>GPT의 대답</h3>

- 프로세스 컨텍스트 스위칭과 스레드 컨텍스트 스위칭 사이의 주요 차이점은 **저장하고 복구해야 하는 컨텍스트의 양과 복잡도**에 있습니다.

- 프로세스 컨텍스트 스위칭에서는 프로세스의 전체 상태, 즉 모든 레지스터 값, 메모리 맵, 열린 파일 디스크립터 등을 저장하고 복구해야 합니다. 
  
- 그러나 스레드 컨텍스트 스위칭에서는 스레드가 속한 프로세스의 코드, 데이터, 힙 등을 공유하기 때문에, 보통 스택 포인터와 프로그램 카운터, 레지스터 값 등만 저장하고 복구하면 됩니다.

<br/>
<h2>🤔 컨텍스트 스위칭이 발생할 때, 기존의 프로세스 정보는 커널스택에 어떠한 형식으로 저장되나요?</h2>

<h3>📝 나의 대답</h3>

- 커널 스택에 PCB 주소 값을 갖는 형태로 저장됩니다.

<h3>GPT의 대답</h3>

- 컨텍스트 스위칭이 발생할 때, 현재 실행 중인 프로세스의 상태는 그 프로세스의 프로세스 제어 블록(PCB)에 저장됩니다. PCB는 프로세스의 중요한 정보를 포함하고 있습니다. 예를 들어 프로세스 상태, 프로그램 카운터, CPU 레지스터 값, 스케줄링 및 메모리 정보 등이 여기에 포함됩니다.


- 이 PCB는 커널 메모리 공간에 저장되며, 컨텍스트 스위칭이 발생할 때 이 정보를 사용하여 이전의 프로세스 상태를 복원합니다.

<br/>
<h2>🤔 컨텍스트 스위칭은 언제 일어날까요?</h2>

<h3>📝 나의 대답</h3>

- 컨텍스트 스위칭은 기존에 컴퓨터 리소스를 점유하고 있는 프로세스를 교체할 때 발생합니다. ❌ 틀린 답변입니다.

<h3>GPT의 대답</h3>

- 프로세스가 I/O 작업을 요청하면 해당 작업이 완료될 때까지 프로세스는 CPU에서 제거되고 다른 프로세스가 CPU를 사용하게 됩니다.

- 운영체제의 스케줄러가 특정 프로세스의 CPU 사용 시간을 할당한 시간을 모두 사용했을 때 발생합니다.

- 또한, 프로세스가 종료되거나, 자식 프로세스를 생성하거나, 시그널이나 인터럽트가 발생할 경우에도 컨텍스트 스위칭이 발생합니다.
</div>
</details>

<details>
<summary style="font-size:20px">프로세스 스케줄링 알고리즘</summary>
<div markdown="1">
<br/>
<h2>🤔 프로세스 스케줄링 알고리즘엔 어떤 것이 있나요?</h2>

<h3>📝 나의 대답</h3>

- 프로세스 스케줄링은 다양한 알고리즘이 존재합니다. SJF, LJF, RR 알고리즘 기법이 존재하며 지향하는 목표는 효율적인 작업 처리입니다. 알고리즘을 분류화할 때 선점형 스케줄링과 비선점 스케줄링으로 나눌 수 있습니다.

- 선점형 스케줄링은 선점하고 있는 프로세스의 사용을 중단하고 다른 프로세스가 CPU를 사용할 수 있는 스케줄링이고 비선점형 스케줄링은 하나의 프로세스의 CPU bound 작업이 끝날 때까지 자원을 점유하는 스케줄링 기법입니다.

<h3>GPT의 대답</h3>

- 선점형 스케줄링은 우선순위가 더 높은 프로세스가 실행되어야 할 때 현재 실행 중인 프로세스를 중지하고 CPU를 빼앗는 방식입니다.

- 반면 비선점형 스케줄링은 현재 프로세스가 완료될 때까지 CPU를 점유하게 됩니다. 이렇게 다양한 스케줄링 알고리즘들은 상황에 따라 적절하게 사용되어 시스템의 성능과 효율성을 높입니다.

<br/>
<h2>🤔 RR을 사용할 때, Time Slice에 따른 trade-off를 설명해 주세요?</h2>

<h3>📝 나의 대답</h3>

- RR(Round Robin) 알고리즘을 사용하면 시분할을 통해 CPU 사용을 관리합니다. RR 사용 시 시분할 시간에 따라 문제가 발생할 수 있습니다.

- 먼저, 시분할 시간이 짧다면 작업을 수행하는 시간보다 프로세스를 교체하는 오버헤드 비용이 커져 성능이 좋지 않을 수 있습니다.

- 다음으로 시분할 시간이 길다면 비선점형 스케줄링인 First Job First와 같은 상황이 발생합니다. 이는 선점형 스케줄링을 사용해 얻을 수 있는 장점을 사용하지 못합니다.

<h3>GPT의 대답</h3>

- RR(Round Robin) 알고리즘을 사용하면 시분할을 통해 CPU 사용을 관리합니다. 하지만 이 때 시간 할당량(time slice) 크기에 따라 여러 trade-offs가 발생할 수 있습니다.

- 시간 할당량이 너무 작다면, 실제 작업 수행 시간보다 프로세스 교체(Context Switching)로 인한 오버헤드가 높아질 수 있습니다. 이는 프로세스를 너무 자주 전환하게 되어, 전환 시 발생하는 비용이 시스템의 전반적인 성능을 저하시키게 됩니다.

- 반대로 시간 할당량이 너무 크다면, 일부 프로세스가 과도하게 오래 기다리게 될 수 있습니다. 이는 특히, I/O 바운드 작업을 수행하는 프로세스들에게 문제가 될 수 있습니다. 이 경우, 프로세스는 대부분의 시간을 I/O 대기 상태로 보내고, 그 사이에 CPU는 대부분 시간을 유휴 상태로 보내게 됩니다. 이렇게 되면 **RR 알고리즘의 기본적인 목표인 CPU 사용의 공정성과 효율성을 해치게 됩니다**.

<br/>
<h2>🤔 싱글 스레드 CPU 에서 상시로 돌아가야 하는 프로세스가 있다면, 어떤 스케쥴링 알고리즘을 사용하는 것이 좋을까요? 또 왜 그럴까요?</h2>

<h3>📝 나의 대답</h3>

- 선점형 스케줄링 알고리즘이 좋다고 생각합니다. 이유는 CPU를 효율적으로 사용할 수 있기 때문입니다. 물론 컨텍스트 스위칭 비용이 발생하지만 여럿 프로세스에게 CPU를 골고루 나눠줌으로써 사용자에게 적합한 응답시간을 제공해줄 수 있기 때문입니다.

<h3>GPT의 대답</h3>

- 상시로 돌아가야 하는 프로세스가 있는 경우, 선점형 우선순위 스케줄링(Priority Scheduling) 알고리즘이 적합합니다. 이 알고리즘은 각 프로세스에 우선순위를 부여하며, 우선순위가 높은 프로세스가 CPU를 먼저 사용하게 됩니다. 이런 방식으로, 상시로 돌아가야 하는 프로세스에게 높은 우선순위를 부여함으로써 해당 프로세스가 CPU 사용을 보장받을 수 있습니다.

<br/>
<h2>🤔 동시성과 병렬성의 차이에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 동시성은 하나의 작업을 여럿으로 나눠 실행하는 것이고 병렬성은 여러 작업을 동시에 수행하는 것을 의미합니다. ❌ 동시성 설명은 틀렸습니다.

- 동기와 동시를 잘 구분해야합니다. 또한, 동시성과 병렬성은 같지 않습니다.

<h3>GPT의 대답</h3>

- 동시성(Concurrency)은 논리적으로 여러 작업이 동시에 실행되는 것처럼 보이도록 만드는 것을 말합니다. 이는 실제로는 하나의 CPU가 여러 작업을 번갈아 가며 수행하는 것입니다. 

- 병렬성(Parallelism)은 실제로 여러 작업을 동시에 수행하는 것을 말합니다. 병렬 처리를 위해서는 여러 개의 CPU 또는 코어가 필요하며, 각각의 CPU나 코어가 독립적으로 작업을 수행합니다.

<br/>
<h2>🤔 타 스케쥴러와 비교하여, Multi-level Feedback Queue는 어떤 문제점들을 해결한다고 볼 수 있을까요?</h2>

<h3>📝 나의 대답</h3>

- 큐마다 책임을 나눠 각각 다른 시분할을 적용해 선점 알고리즘을 수행할 수 있습니다. ❌ 틀린 답변입니다.

<h3>GPT의 대답</h3>

- Multi-level Feedback Queue(MFQ)는 여러 대기열을 사용하고, 각 대기열이 다른 우선순위를 가지도록 설계된 스케줄링 알고리즘입니다. 이 알고리즘은 기본적으로 **CPU-bound 프로세스와 I/O-bound 프로세스를 효과적으로 구별하고 관리함**으로써 복잡한 스케줄링 요구사항을 만족시킵니다.

- CPU Bound 작업이 많다면 우선순위를 낮게 설정하고 I/O Bound 작업이 많다면 우선순위를 높게 책정합니다. 이는 각각의 Bound 작업에 더 많은 시간을 사용할 수 있는 이점을 줍니다.

</div>
</details>