<details>
<summary style="font-size:20px">Transactional이란</summary>
<div markdown="1">
<br/>
<h3>🤔 Transactional은 무엇을 하나요?</h3>

- Transactional은 **하나의 논리적 작업 단위로 수행되는 일련의 작업**을 이야기합니다.
<br/>

<h3>🤔 Transactional 특성은 어떤 것이 있나요?</h3>

- Transactiona이 가져야 하는 특성에는 ACID이 있습니다.

✅ Atomicity: 원자성은 트랜잭션과 관련된 작업들이 부분적으로 실행되다가 중단되지 않는 것을 보장하는 능력이다. 예를 들어, 자금 이체는 성공할 수도 실패할 수도 있지만 보내는 쪽에서 돈을 빼 오는 작업만 성공하고 받는 쪽에 돈을 넣는 작업을 실패해서는 안된다. 원자성은 이와 같이 중간 단계까지 실행되고 실패하는 일이 없도록 하는 것이다.

✅ Consistency: 일관성은 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것을 의미한다. 무결성 제약이 모든 계좌는 잔고가 있어야 한다면 이를 위반하는 트랜잭션은 중단된다.

✅ Isolation: 고립성은 트랜잭션을 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하는 것을 의미한다. 이것은 트랜잭션 밖에 있는 어떤 연산도 중간 단계의 데이터를 볼 수 없음을 의미한다. 은행 관리자는 이체 작업을 하는 도중에 쿼리를 실행하더라도 특정 계좌간 이체하는 양 쪽을 볼 수 없다. 공식적으로 고립성은 트랜잭션 실행내역은 연속적이어야 함을 의미한다. 성능관련 이유로 인해 이 특성은 가장 유연성 있는 제약 조건이다. 자세한 내용은 관련 문서를 참조해야 한다.

✅ Durability: 지속성은 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함을 의미한다. 시스템 문제, DB 일관성 체크 등을 하더라도 유지되어야 함을 의미한다. 전형적으로 모든 트랜잭션은 로그로 남고 시스템 장애 발생 전 상태로 되돌릴 수 있다. 트랜잭션은 로그에 모든 것이 저장된 후에만 commit 상태로 간주될 수 있다.

<h3>❓ Spring Project에서 @Transactional은 어떻게 동작하나요?</h3>

- @Transactional를 통해 DB와의 상호작용이 Transactional으로 묶일 수 있습니다.

1. 메서드가 호출되면 Spring은 Transactional을 시작합니다.
2. 메서드 내에서 수행되는 DB 작업은 Transactional 내에서 실행됩니다. 이러한 작업은 일련의 데이터 변경 작업이 포함될 수 있습니다.
3. 메서드가 성공적으로 완료되면, Spring은 Transaction을 Commit하여 DB의 변경 사항을 영구적으로 반영합니다.
4. 메서드 실행 도중 예외가 발생하면, Spring은 Transaction을 롤백하고 이전 상태로 DB를 되돌립니다. 이는 메서드 내에서 발생한 모든 변경 사항을 취소합니다.

<h3>❓ Transactional을 사용할 때, DataSource 이야기가 많이 나오는데 어떤 상관관계가 존재하나요?</h3>

- DataSource는 Spring에서 DB와의 연결을 관리하는 Interface입니다. Spring은 DataSource Interface를 사용하여 DB ConnectionPool을 구성하고, DB 연결을 관리하며, DB와의 상호작용을 처리합니다.

- DataSource는 DB 연결 설정 및 Transaction 관리 등을 제공합니다. @Transactional 어노테이션과 함께 사용될 때 데이터베이스 연결과 트랜잭션 관리를 담당하는 주요한 요소입니다.

</div>
</details>

<details>
<summary style="font-size:20px">시스템 콜은 무엇인가요?</summary>
<div markdown="1">
<br/>
<h2>🤔 시스템 콜이란?</h2>

<h3>📝 나의 대답</h3>

- 시스템 콜이란 프로세스가 시스템 자원을 사용하기 위해 운영체제에게 자원을 할당 받기 위해 사용되는 트리거입니다.

<h3>GPT의 대답</h3>

- 시스템 콜은 운영체제의 기능과 자원을 사용하기 위해 프로세스가 운영체제에게 요청하는 인터페이스 또는 메커니즘입니다.

<br/>
<h2>🤔 우리가 사용하는 시스템 콜의 예시를 들어주세요</h2>

<h3>📝 나의 대답</h3>

- 예를 들어 프로세스에서 연산이 필요한 필요한 작업을 수행할 때 프로세스는 CPU를 통해 연산을 수행해야하는데 이 때 연산이 필요한 프로세스는 운영체제에게 시스템 콜을 요청합니다.

<h3>GPT의 대답</h3>

- 시스템 콜은 다양한 작업을 포함하며, 예들 들어 파일 입출력, 네트워크 통신, 메모리 관리 등을 포함하고 있습니다.

<br/>
<h2>🤔 시스템 콜이 운영체제에서 어떤 과정으로 실행되는지 설명해 주세요</h2>

<h3>📝 나의 대답</h3>

- 프로세스가 원한다고 해서 즉시 운영체제에게 시스템 콜을 발생해 요청할 수 없습니다. 운영체제의 스케쥴링에 따라 자원을 할당 받을 수 있으며 준비 - 대기 - 실행 상태를 순회하며 컴퓨터 자원을 할당 받습니다.

<h3>GPT의 대답</h3>

- 시스템 콜이 운영체제에서 실행되는 과정은 다음과 같습니다:

1. 프로세스가 시스템 콜을 호출합니다. 이는 프로세스가 운영체제의 특정 기능 또는 자원에 접근하기 위해 필요한 요청입니다.
2. 운영체제는 시스템 콜을 감지하고, 해당 요청을 처리하기 위해 해당 기능 또는 자원에 대한 작업을 시작합니다.
3. 운영체제는 프로세스의 상태를 변경하여 시스템 콜을 처리합니다. 이는 대부분의 경우 프로세스를 사용 가능한 대기 상태로 변경합니다.
4. 운영체제는 필요한 작업을 수행하고, 요청된 자원 또는 기능을 프로세스에 할당합니다. 이를 위해 운영체제는 자원을 관리하고, 프로세스 간의 우선 순위 및 스케줄링 정책을 고려합니다.
5. 운영체제가 요청된 작업을 완료하면, 프로세스는 다시 실행 가능한 상태로 전환되어 해당 작업을 계속합니다.
6. 프로세스는 할당된 자원을 사용하여 원하는 작업을 수행하고, 시스템 콜을 호출한 이후에는 보통 이전 상태로 돌아갑니다.


<br/>
<h2>🤔 시스템 콜의 유형에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 시스템 콜의 유형은 자원을 할당 받았을 때와 할당 받지 못했을 때로 나뉩니다.(표현하는 단어가 생각나지 않습니다.) ❌ 완벽히 틀렸습니다. ❌

<h3>GPT의 대답</h3>

- 프로세스 제어, 파일 조작, 장치 관리, 파일 시스템, 네트워킹, 메모리 관리, 보안 시스템 콜이 존재합니다.

<br/>
<h2>🤔 운영체제의 Dual Mode 에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 시스템 콜의 유형은 자원을 할당 받았을 때와 할당 받지 못했을 때로 나뉩니다.(표현하는 단어가 생각나지 않습니다.) ❌ 완벽히 틀렸습니다. ❌

<h3>GPT의 대답</h3>

- 운영체제의 Dual Mode는 컴퓨터 시스템에서 사용자 모드와 커널 모드라는 두 가지 모드를 지원하는 기능을 말합니다.

- 사용자 모드는 응용 프로그램이 실행되는 모드로, 일반적인 프로세시의 동작 범위를 의미합니다. 사용자 모드에서는 제한된 자원에 접근하고, 일부 민감한 명령어나 하드웨어에 직접적인 접근이 제한됩니다.

- 반면, 커널 모드는 운영체제의 핵심 부분인 커널이 동작하는 모드로, 시스템의 모든 자원과 기능에 접근할 수 있습니다. 커널 모드에서는 시스템 콜과 같은 특권 명령어를 실행하거나 하드웨어를 직접적으로 제어할 수 있습니다.

🍎 Dual Mode 사용 이유

- **Dual Mode의 주요 목적은 운영체제가 시스템 자원을 보호하고, 응용 프로그램이 실수나 악의적인 동작으로 시스템을 손상시키지 못하도록 제한하는 것입니다.** 응용 프로그램은 사용자 모드에서 실행되며, 시스템 자원에 접근하기 위해 시스템 콜을 호출하여 커널 모드로 전환됩니다. 

<br/>
<h2>🤔 서로 다른 시스템 콜을 어떻게 구분할 수 있을까요?</h2>

<h3>📝 나의 대답</h3>

- PID를 통해 구분할 수 있습니다.

<h3>GPT의 대답</h3>

- PID는 프로세스를 식별하는 데 사용되는 고유한 식별자이며, 시스템 콜은 프로세스가 운영체제에 요청하는 인터페이스입니다.

- 시스템 콜을 구분하는 주요 방법은 시스템 콜의 번호나 식별자를 사용하는 것입니다.

</div>
</details>

<details>
<summary style="font-size:20px">인터럽트</summary>
<div markdown="1">
<br/>
<h2>🤔 인터럽트가 무엇인지 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 인터럽트란 프로세스 진행 시 운영체제에게 자원을 요청하는 트리거입니다.

<h3>GPT의 대답</h3>

- 인터럽트는 컴퓨터 시스템에서 발생하는 이벤트나 예외 상황으로, 프로세스의 정상적인 실행 흐름을 중단하고 운영체제에게 어떤 처리를 요청하는 신호입니다.

<br/>
<h2>🤔 인터럽트는 어떻게 처리하나요</h2>

<h3>📝 나의 대답</h3>

- 인터럽트는 서브 루틴을 사용해 처리합니다. 서브 루틴은 Stack의 구조를 띄고 있으며 LIFO으로 요청이 처리됩니다.

<h3>GPT의 대답</h3>

- 인터럽트 처리는 인터럽트 서비스 루틴(ISR)을 호출하여 해당 인터럽트에 대한 처리를 수행하고, 상태를 저장하고 복원하여 중단된 프로세스의 실행을 재개하는 과정으로 이루어진다는 것입니다.

<br/>
<h2>🤔 Polling 방식에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- Polling 방식은 인터럽트에 대한 처리가 끝났는지 지속적으로 확인하는 방식입니다. ❌ 완벽히 틀렸습니다. ❌

<h3>GPT의 대답</h3>

- Polling 방식은 **CPU가 주기적으로 특정 장치나 상태를 확인**하며 인터럽트나 이벤트 발생 여부를 체크하는 방식으로, 인터럽트가 발생하면 해당 인터럽트를 처리하는 과정을 수행한다는 것입니다.

<br/>
<h2>🤔 HW / SW 인터럽트에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 모르겠습니다.

<h3>GPT의 대답</h3>

- HW 인터럽트 : 하드웨어 인터럽트는 주로 하드웨어 장치에서 발생하는 이벤트에 의해 발생합니다. 이벤트는 입출력(I/O) 장치의 데이터 전송 완료, 타이머 경과, 외부 신호 등 다양한 형태일 수 있습니다. 하드웨어 인터럽트는 컴퓨터 시스템의 하드웨어 제어러에 의해 처리됩니다.

- SW 인터럽트 : 소프트웨어 인터럽트는 소프트웨어 실행 중에 발생하는 이벤트에 의해 발생합니다. 주로 운영체제나 프로세스가 직접 발생시키는 인터럽트입니다. 소프트웨어 인터럽트는 프로세스의 특정 상황이나 요청에 의해 발생할 수 있습니다. 

</div>
</details>

<details>
<summary style="font-size:20px">프로세스</summary>
<div markdown="1">
<br/>
<h2>🤔 프로세스란 무엇인가요</h2>

<h3>📝 나의 대답</h3>

- 프로세스란 하나의 동작하는 프로그램입니다.

<h3>GPT의 대답</h3>

- 프로세스는 컴퓨터에서 실행중인 프로그램입니다. 프로세스는 OS에 의해 관리되며 프로그램의 인스턴스로서 메모리와 CPU 등의 시스템 리소스를 할당받아 실행됩니다.

- 각 프로세스는 독립적으로 실행됩니다.


<br/>
<h2>🤔 프로그램과 프로세스, 스레드의 차이에 대해 설명해 주세요.
</h2>

<h3>📝 나의 대답</h3>

- 프로세스는 컴퓨터에서 실행중인 프로그램을 의미하며 스레드는 그 안에 존재해 작업을 처리하는 역할을 수행합니다. 하나의 프로세스 내에서 여러 개의 스레드가 존재할 수 있습니다.

<h3>GPT의 대답</h3>

- 프로세스에 대한 설명은 맞습니다. 스레드는 프로세스 안에 존재하며, **프로세스의 자원을 공유**하면서 작업을 처리하는 작은 실행 단위입니다. 

- 프로세스는 최소한 하나의 스레드를 가지고 있어야 하지만, 여러 개의 스레드를 가질 수도 있습니다. 스레드는 프로세스 내에서 병렬적으로 동작하며, 서로 다른 스레드는 프로세스의 자원을 공유하면서 작업을 수행할 수 있습니다.

<br/>
<h2>🤔 스레드는 PCB를 갖고 있을까요?</h2>

<h3>📝 나의 대답</h3>

- 아니요. 스레드는 PCB를 갖고 있지 않습니다. PCB는 실행중인 프로세스에게 할당되는 고유한 값이고 스레드는 PCB ID와 같은 정보를 알고 있습니다.

<h3>GPT의 대답</h3>

- "스레드는 PCB(Process Control Block)를 직접 갖고 있는 것은 아닙니다. PCB는 실행 중인 프로세스에게 할당되는 고유한 값으로, 프로세스의 상태, 우선순위, 자원 할당 정보 등을 포함합니다. 
  
- 스레드는 프로세스 내에서 실행되는 작은 실행 단위로, 여러 개의 스레드는 하나의 프로세스의 자원을 공유하면서 병렬적으로 동작합니다. 각 스레드는 프로세스의 PCB ID와 같은 정보를 알고 있어 해당 프로세스의 자원에 접근하고 조작할 수 있습니다."

<br/>
<h2>🤔 리눅스에서, 프로세스와 스레드는 각각 어떻게 생성될까요?</h2>

<h3>📝 나의 대답</h3>

- 리눅스 환경에서 프로세스는 Root 프로세스에서 자식 프로세스의 형식으로 생성되며 스레드는 생성된 프로세스에 기본값으로 스레드가 할당됩니다.

<h3>GPT의 대답</h3>

- 리눅스에서 프로세스는 **'fork()' 시스템 콜**을 통해 생성됩니다. 이 'fork()' 함수는 호출한 프로세스의 **복사**본인 자식 프로세스를 만들며, 이 둘은 독립된 메모리 공간을 갖게 됩니다. 이후 **'exec()' 시스템 콜**을 사용하여 자식 프로세스의 **메모리에 새로운 프로그램을 로드**할 수 있습니다.

- 스레드의 생성은 'pthread_create()' 함수를 통해 이루어집니다. 이 함수를 호출하면 호출한 프로세스 내에서 새로운 스레드가 생성됩니다.

<br/>
<h2>🤔 자식 프로세스가 상태를 알리지 않고 죽거나, 부모 프로세스가 먼저 죽게 되면 어떻게 처리하나요?</h2>

<h3>📝 나의 대답</h3>

- ❗️ 모르겠습니다.

<h3>GPT의 대답</h3>

✅ 자식 프로세스가 상태를 알리지 않고 종료될 경우

- 이 경우 자식 프로세스는 'Zombie 프로세스'가 됩니다. 이는 프로세스가 종료되었지만 부모 프로세스가 그 상태 정보를 아직 회수하지 않은 상태를 말합니다. 이 정보를 회수하지 않으면 프로세스 테이블에 불필요한 정보가 계속 남아 있어, 자원 낭비를 초래할 수 있습니다. 이를 해결하기 위해 부모 프로세스는 'wait()' 또는 'waitpid()' 함수를 호출하여 자식 프로세스의 상태 정보를 회수합니다.

✅ 부모 프로세스가 먼저 종료될 경우

- 이 경우 자식 프로세스는 'Orphan 프로세스'가 됩니다. 부모 프로세스가 종료되면 그의 자식 프로세스들은 init 프로세스(프로세스 ID가 1인 프로세스)가 자동으로 채택하여 그 부모로 만듭니다. init 프로세스는 주기적으로 'wait()'를 호출하여 종료된 자식 프로세스의 상태 정보를 회수하므로, Orphan 프로세스가 Zombie 프로세스가 되는 것을 방지합니다.

</div>
</details>