<details>
<summary style="font-size:20px">시간 복잡도와 공간 복잡도</summary>
<div markdown="1">
<br/>
<h2>🤔 시간복잡도와 공간복잡도에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 시간 복잡도와 공간 복잡도는 모두 성능 측정에 요인이 되는 측정값입니다.

- 시간 복잡도는 프로세스 실행 시 소요되는 시간을 의미하며 공간 복잡도는 프로세스 실행 시 사용하는 메모리의 양을 의미합니다.

<h3>GPT의 대답</h3>

- 시간 복잡도와 공간 복잡도는 알고리즘의 효율성을 측정하는 두 가지 주요 방법입니다.

- 시간 복잡도는 알고리즘이 문제를 해결하는 데 걸리는 시간을 측정합니다. 이는 일반적으로 입력 데이터의 크기에 따라 결정되며, 이를 통해 알고리즘이 큰 데이터 세트에 대해 얼마나 잘 확장되는지를 판단할 수 있습니다. 

- 공간 복잡도는 알고리즘이 문제를 해결하는 데 필요한 메모리 양을 측정합니다. 일부 알고리즘은 매우 빠르지만 많은 양의 메모리를 사용할 수 있으며, 이는 제한된 메모리 리소스를 가진 시스템에서는 문제가 될 수 있습니다.

<br/>
<h2>🤔 Big-O, Big-Theta, Big-Omega 에 대해 설명해 주세요.</h2>

<h3>GPT의 대답</h3>

✅ Big-O (O) : 이 표기법은 알고리즘의 최악의 경우의 실행 시간을 표현합니다. 즉, 입력 크기에 따른 알고리즘의 실행 시간의 상한을 나타냅니다.

✅ Big-Theta (Θ) : 이 표기법은 알고리즘의 평균 혹은 일반적인 경우의 실행 시간을 나타냅니다. 즉, 입력 크기에 따른 알고리즘의 실행 시간의 상한과 하한을 모두 만족시키는 경우를 의미합니다.

✅ Big-Omega (Ω) : 이 표기법은 알고리즘의 최선의 경우의 실행 시간을 나타냅니다. 즉, 입력 크기에 따른 알고리즘의 실행 시간의 하한을 나타냅니다.

<br/>
<h2>🤔 다른 것을 사용하지 않고, Big-O를 사용하는 이유가 있을까요?</h2>

<h3>📝 나의 대답</h3>

- 최악의 실행 시간을 표현함으로써 풀고자하는 문제에 적합함을 알 수 있기 때문입니다.

<h3>GPT의 대답</h3>

- Big-O 표기법은 알고리즘의 최악의 경우의 실행 시간을 나타냄으로써, 특정 문제에 대해 알고리즘이 어떻게 수행될 수 있는지에 대한 가장 보수적인 추정을 제공합니다. 이는 **최악의 경우에도 시스템이 어떻게 수행될지 이해하는 것이 중요한 많은 실제 상황에서 유용**합니다.

<br/>
<h2>🤔 O(1)은 O(N^2) 보다 무조건적으로 빠른가요?</h2>

<h3>📝 나의 대답</h3>

- 아니요. 어떤 메모리를 사용하는지가 두 Big-O 결과에 영향을 끼칠 수 있습니다. 만약 알고리즘을 해결할 때 O(1)에서 메모리 스위칭 비용이 많이 O(N^2)보다 많이 발생하게 된다면 O(1)이 더 느릴 수도 있습니다.

<h3>GPT의 대답</h3>

- 아니요, O(1)이 O(N^2)보다 무조건적으로 빠르다고 말할 수 없습니다. Big-O 표기법은 입력 크기에 따른 알고리즘의 실행 시간의 상한을 나타내는 것으로, 입력 크기가 커질수록 O(N^2)은 O(1)보다 더 많은 시간이 소요될 것입니다.

- 그러나 이것은 '항상'이라는 말이 아닙니다. 실제 실행 시간은 알고리즘의 구현, 하드웨어, 데이터 분포 등 많은 다른 요인들에 의해 결정됩니다. 예를 들어, O(1)의 알고리즘이 상당히 큰 상수 시간을 가지거나, O(N^2)의 알고리즘이 매우 작은 입력 크기에 대해 사용될 경우, 실제로는 O(N^2)의 알고리즘이 더 빠를 수 있습니다.

- 또한, 당신이 언급한 것처럼, 메모리 스위칭, 캐시 히트 등의 하드웨어 요인도 실행 시간에 영향을 줄 수 있습니다. 이러한 모든 요인을 고려하면, Big-O 표기법만으로는 실제 실행 시간을 완벽하게 예측할 수 없습니다.

</div>
</details>

<details>
<summary style="font-size:20px">링크드 리스트</summary>
<div markdown="1">
<br/>
<h2>🤔 링크드 리스트에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 링크드 리스트는 자료구조의 하나로 노드의 연결로 구성되어 있습니다. 단일 링크드 리스트, 양방향 링크드 리스트로 구성할 수 있으며 노드 안엔 데이터와 다음 노드의 위치를 담아 연결을 맺습니다.

<h3>GPT의 대답</h3>

- 링크드 리스트의 주요 장점 중 하나는 요소의 삽입과 삭제가 배열에 비해 상대적으로 간단하다는 것입니다. 배열에서는 요소를 삽입하거나 삭제할 때마다 다른 요소들을 이동시켜야 하지만, 링크드 리스트에서는 단순히 몇 개의 포인터를 수정하면 됩니다.

- 그러나, 이런 유연성 때문에 링크드 리스트는 포인터를 통한 노드 접근이 필요하므로, 임의 접근(random access)가 불가능하며, 이는 배열과 비교했을 때의 단점으로 볼 수 있습니다.

<br/>
<h2>🤔 일반 배열과, 링크드 리스트를 비교해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 일반 배열은 메모리에 연속적으로 존재하지만 링크드 리스트는 그렇지 않습니다. 데이터 조회 속도는 일반 배열이 링크드 리스트보다 좋습니다. 이유는 일반 배열의 경우엔 데이터가 연속으로 존재하기 때문입니다. 하지만 중간에 데이터를 삽입, 삭제 시 일반 배열의 경우 삽입, 삭제 기준으로 데이터를 이동시켜야 하기 때문에 링크드 리스트보다 리소스가 많이 소모됩니다.

<h3>GPT의 대답</h3>

- 일반 배열은 메모리의 연속적인 영역에 데이터를 저장합니다. 이로 인해 배열은 인덱스를 통해 임의의 요소에 빠르게 접근할 수 있는 장점이 있습니다. 그러나, 배열의 크기는 선언 시점에서 결정되며, 이후에는 크기를 변경할 수 없습니다. 또한, 배열의 중간에 요소를 삽입하거나 삭제하려면 다른 요소들을 이동시켜야 하므로, 이러한 작업은 비효율적입니다.

- 반면에 링크드 리스트는 메모리의 비연속적인 영역에 데이터를 저장하며, 각 노드가 다음 노드를 가리키는 방식으로 연결됩니다. 이로 인해 링크드 리스트는 동적으로 크기를 조정할 수 있으며, 중간에 요소를 삽입하거나 삭제하는 것이 상대적으로 간단합니다.

- 단지 연결을 끊고 새로 연결하는 것만으로도 가능하기 때문입니다. 그러나 이는 링크드 리스트가 임의 접근을 지원하지 않는다는 단점을 가지고 있습니다. 링크드 리스트에서 특정 요소에 접근하려면 처음부터 순차적으로 접근해야 합니다.

<br/>
<h2>🤔 링크드 리스트를 사용해서 구현할 수 있는 다른 자료구조에 대해 설명해 주세요.</h2>

<h3>📝 나의 대답</h3>

- 링크드 리스트로 다양한 자료구조를 구현할 수 있습니다. 스택, 큐, 그래프 등 만들 수 있습니다.

<br/>
<h2>🤔 Array와 LinkedList 장/단점</h2>

<h3>📝 나의 대답</h3>

- Array :  RandomAccess가 가능해 속도가 빠르다는 장점이 있습니다. 하지만 삽입 또는 삭제의 과정에서 각 원소들을 shift 해줘야 하는 비용이 생겨 이 경우 시간 복잡도는 O(n)이 된다는 단점이 있습니다.
  
- 각각의 원소들은 자기 자신 다음에 어떤 원소인지만을 기억하고 있기 때문에 이 부분만 다른 값으로 바꿔주면 삽입과 삭제를 O(1)로 해결할 수 있습니다.
하지만LinkedList는 원하는 위치에 한 번에 접근할 수 없다는 단점이 있습니다. 원하는 위치에 삽입을 하고자 하면 원하는 위치를 Search 과정에 있어서 첫번째 원소부터 다 확인해봐야 합니다.
</div>
</details>